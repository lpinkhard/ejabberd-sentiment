From cb6ec4fc6ad6c710f9c88c8ff349cea4f91a7312 Mon Sep 17 00:00:00 2001
From: Oleg Palij <o.palij@gmail.com>
Date: Mon, 23 Jul 2018 11:01:29 +0300
Subject: [PATCH 1/2] apply mod_logdb to 18.06

---
 priv/msgs/nl.msg          |   14 +
 priv/msgs/pl.msg          |   26 +
 priv/msgs/ru.msg          |   30 +
 priv/msgs/uk.msg          |   30 +
 rebar.config              |    4 +-
 src/gen_logdb.erl         |  162 ++
 src/mod_logdb.erl         | 1952 ++++++++++++++++
 src/mod_logdb.hrl         |   33 +
 src/mod_logdb_mnesia.erl  |  555 +++++
 src/mod_logdb_mysql.erl   | 1052 +++++++++
 src/mod_logdb_mysql5.erl  |  981 +++++++++
 src/mod_logdb_pgsql.erl   | 1106 ++++++++++
 src/mod_muc_room.erl.orig | 4411 +++++++++++++++++++++++++++++++++++++
 src/mod_roster.erl        |   77 +-
 src/mod_roster.erl.orig   | 1224 ++++++++++
 15 files changed, 11651 insertions(+), 6 deletions(-)
 create mode 100644 src/gen_logdb.erl
 create mode 100644 src/mod_logdb.erl
 create mode 100644 src/mod_logdb.hrl
 create mode 100644 src/mod_logdb_mnesia.erl
 create mode 100644 src/mod_logdb_mysql.erl
 create mode 100644 src/mod_logdb_mysql5.erl
 create mode 100644 src/mod_logdb_pgsql.erl
 create mode 100644 src/mod_muc_room.erl.orig
 create mode 100644 src/mod_roster.erl.orig

diff --git a/priv/msgs/nl.msg b/priv/msgs/nl.msg
index 9dfd896b99..f35ff07ad4 100644
--- a/priv/msgs/nl.msg
+++ b/priv/msgs/nl.msg
@@ -386,3 +386,17 @@
 {"Your Jabber account was successfully created.","Uw Jabber-account is succesvol gecreeerd."}.
 {"Your Jabber account was successfully deleted.","Uw Jabber-account is succesvol verwijderd."}.
 {"Your messages to ~s are being blocked. To unblock them, visit ~s","Uw berichten aan ~s worden geblokkeerd. Om ze te deblokkeren, ga naar ~s"}.
+% mod_logdb
+{"Users Messages", "Gebruikersberichten"}.
+{"Date", "Datum"}.
+{"Count", "Aantal"}.
+{"Logged messages for ~s", "Gelogde berichten van ~s"}.
+{"Logged messages for ~s at ~s", "Gelogde berichten van ~s op ~s"}.
+{" at ", " op "}.
+{"No logged messages for ~s", "Geen gelogde berichten van ~s"}.
+{"No logged messages for ~s at ~s", "Geen gelogde berichten van ~s op ~s"}.
+{"Date, Time", "Datum en tijd"}.
+{"Direction: Jid", "Richting: Jabber ID"}.
+{"Subject", "Onderwerp"}.
+{"Body", "Berichtveld"}.
+{"Messages", "Berichten"}.
diff --git a/priv/msgs/pl.msg b/priv/msgs/pl.msg
index 6b303cc930..664f1c9579 100644
--- a/priv/msgs/pl.msg
+++ b/priv/msgs/pl.msg
@@ -390,3 +390,29 @@
 {"Your Jabber account was successfully created.","Twoje konto zostało stworzone."}.
 {"Your Jabber account was successfully deleted.","Twoje konto zostało usunięte."}.
 {"Your messages to ~s are being blocked. To unblock them, visit ~s","Twoje wiadomości do ~s są blokowane. Aby je odblokować, odwiedź ~s"}.
+% mod_logdb
+{"Users Messages", "Wiadomości użytkownika"}.
+{"Date", "Data"}.
+{"Count", "Liczba"}.
+{"Logged messages for ~s", "Zapisane wiadomości dla ~s"}.
+{"Logged messages for ~s at", "Zapisane wiadomości dla ~s o ~s"}.
+{" at ", " o "}.
+{"No logged messages for ~s", "Brak zapisanych wiadomości dla ~s"}.
+{"No logged messages for ~s at ~s", "Brak zapisanych wiadomości dla ~s o ~s"}.
+{"Date, Time", "Data, Godzina"}.
+{"Direction: Jid", "Kierunek: Jid"}.
+{"Subject", "Temat"}.
+{"Body", "Treść"}.
+{"Messages","Wiadomości"}.
+{"Filter Selected", "Odfiltruj zaznaczone"}.
+{"Do Not Log Messages", "Nie zapisuj wiadomości"}.
+{"Log Messages", "Zapisuj wiadomości"}.
+{"Messages logging engine", "System zapisywania historii rozmów"}.
+{"Default", "Domyślne"}.
+{"Set logging preferences", "Ustaw preferencje zapisywania"}.
+{"Messages logging engine settings", "Ustawienia systemu logowania"}.
+{"Set run-time settings", "Zapisz ustawienia systemu logowania"}.
+{"Groupchat messages logging", "Zapisywanie rozmów z konferencji"}.
+{"Jids/Domains to ignore", "JID/Domena która ma być ignorowana"}.
+{"Purge messages older than (days)", "Usuń wiadomości starsze niż (w dniach)"}.
+{"Poll users settings (seconds)", "Czas aktualizacji preferencji użytkowników (sekundy)"}.
diff --git a/priv/msgs/ru.msg b/priv/msgs/ru.msg
index 05849f51e0..b87bf9bb64 100644
--- a/priv/msgs/ru.msg
+++ b/priv/msgs/ru.msg
@@ -386,3 +386,33 @@
 {"Your Jabber account was successfully created.","Ваш Jabber-аккаунт был успешно создан."}.
 {"Your Jabber account was successfully deleted.","Ваш Jabber-аккаунт был успешно удален."}.
 {"Your messages to ~s are being blocked. To unblock them, visit ~s","Ваши сообщения к ~s блокируются. Для снятия блокировки перейдите по ссылке ~s"}.
+% mod_logdb.erl
+{"Users Messages", "Сообщения пользователей"}.
+{"Date", "Дата"}.
+{"Count", "Количество"}.
+{"Logged messages for ~s", "Сохранённые cообщения для ~s"}.
+{"Logged messages for ~s at ~s", "Сохранённые cообщения для ~s за ~s"}.
+{" at ", " за "}.
+{"No logged messages for ~s", "Отсутствуют сообщения для ~s"}.
+{"No logged messages for ~s at ~s", "Отсутствуют сообщения для ~s за ~s"}.
+{"Date, Time", "Дата, Время"}.
+{"Direction: Jid", "Направление: Jid"}.
+{"Subject", "Тема"}.
+{"Body", "Текст"}.
+{"Messages", "Сообщения"}.
+{"Filter Selected", "Отфильтровать выделенные"}.
+{"Do Not Log Messages", "Не сохранять сообщения"}.
+{"Log Messages", "Сохранять сообщения"}.
+{"Messages logging engine", "Система логирования сообщений"}.
+{"Default", "По умолчанию"}.
+{"Set logging preferences", "Задайте настройки логирования"}.
+{"Messages logging engine users", "Пользователи системы логирования сообщений"}.
+{"Messages logging engine settings", "Настройки системы логирования сообщений"}.
+{"Set run-time settings", "Задайте текущие настройки"}.
+{"Groupchat messages logging", "Логирование сообщений типа groupchat"}.
+{"Jids/Domains to ignore", "Игнорировать следующие jids/домены"}.
+{"Purge messages older than (days)", "Удалять сообщения старее чем (дни)"}.
+{"Poll users settings (seconds)", "Обновлять настройки пользователей через (секунд)"}.
+{"Drop", "Удалять"}.
+{"Do not drop", "Не удалять"}.
+{"Drop messages on user removal", "Удалять сообщения при удалении пользователя"}.
diff --git a/priv/msgs/uk.msg b/priv/msgs/uk.msg
index a1159b5313..4bdab4c507 100644
--- a/priv/msgs/uk.msg
+++ b/priv/msgs/uk.msg
@@ -390,3 +390,33 @@
 {"Your Jabber account was successfully created.","Ваш Jabber-акаунт було успішно створено."}.
 {"Your Jabber account was successfully deleted.","Ваш Jabber-акаунт було успішно видалено."}.
 {"Your messages to ~s are being blocked. To unblock them, visit ~s","Ваші повідомлення до ~s блокуються. Для розблокування відвідайте ~s"}.
+% mod_logdb
+{"Users Messages", "Повідомлення користувачів"}.
+{"Date", "Дата"}.
+{"Count", "Кількість"}.
+{"Logged messages for ~s", "Збережені повідомлення для ~s"}.
+{"Logged messages for ~s at ~s", "Збережені повідомлення для ~s за ~s"}.
+{" at ", " за "}.
+{"No logged messages for ~s", "Відсутні повідомлення для ~s"}.
+{"No logged messages for ~s at ~s", "Відсутні повідомлення для ~s за ~s"}.
+{"Date, Time", "Дата, Час"}.
+{"Direction: Jid", "Напрямок: Jid"}.
+{"Subject", "Тема"}.
+{"Body", "Текст"}.
+{"Messages", "Повідомлення"}.
+{"Filter Selected", "Відфільтрувати виділені"}.
+{"Do Not Log Messages", "Не зберігати повідомлення"}.
+{"Log Messages", "Зберігати повідомлення"}.
+{"Messages logging engine", "Система збереження повідомлень"}.
+{"Default", "За замовчуванням"}.
+{"Set logging preferences", "Вкажіть налагоджування збереження повідомлень"}.
+{"Messages logging engine users", "Користувачі системи збереження повідомлень"}.
+{"Messages logging engine settings", "Налагоджування системи збереження повідомлень"}.
+{"Set run-time settings", "Вкажіть поточні налагоджування"}.
+{"Groupchat messages logging", "Збереження повідомлень типу groupchat"}.
+{"Jids/Domains to ignore", "Ігнорувати наступні jids/домени"}.
+{"Purge messages older than (days)", "Видаляти повідомлення старіші ніж (дні)"}.
+{"Poll users settings (seconds)", "Оновлювати налагоджування користувачів кожні (секунд)"}.
+{"Drop", "Видаляти"}.
+{"Do not drop", "Не видаляти"}.
+{"Drop messages on user removal", "Видаляти повідомлення під час видалення користувача"}.
diff --git a/rebar.config b/rebar.config
index 477343c50c..db58ab699e 100644
--- a/rebar.config
+++ b/rebar.config
@@ -33,8 +33,8 @@
         {eimp, ".*", {git, "https://github.com/processone/eimp", {tag, "1.0.6"}}},
         {if_var_true, stun, {stun, ".*", {git, "https://github.com/processone/stun", {tag, "1.0.23"}}}},
         {if_var_true, sip, {esip, ".*", {git, "https://github.com/processone/esip", {tag, "1.0.24"}}}},
-        {if_var_true, mysql, {p1_mysql, ".*", {git, "https://github.com/processone/p1_mysql",
-                                               {tag, "1.0.6"}}}},
+        {if_var_true, mysql, {p1_mysql, ".*", {git, "https://github.com/paleg/p1_mysql",
+                                               {tag, "multi"}}}},
         {if_var_true, pgsql, {p1_pgsql, ".*", {git, "https://github.com/processone/p1_pgsql",
                                                {tag, "1.1.6"}}}},
         {if_var_true, sqlite, {sqlite3, ".*", {git, "https://github.com/processone/erlang-sqlite3",
diff --git a/src/gen_logdb.erl b/src/gen_logdb.erl
new file mode 100644
index 0000000000..8bad112969
--- /dev/null
+++ b/src/gen_logdb.erl
@@ -0,0 +1,162 @@
+%%%----------------------------------------------------------------------
+%%% File    : gen_logdb.erl
+%%% Author  : Oleg Palij (mailto:o.palij@gmail.com)
+%%% Purpose : Describes generic behaviour for mod_logdb backends.
+%%% Url     : https://paleg.github.io/mod_logdb/
+%%%----------------------------------------------------------------------
+
+-module(gen_logdb).
+-author('o.palij@gmail.com').
+
+-export([behaviour_info/1]).
+
+behaviour_info(callbacks) ->
+   [
+    % called from handle_info(start, _)
+    % it should logon database and return reference to started instance
+    % start(VHost, Opts) -> {ok, SPid} | error
+    %  Options - list of options to connect to db
+    %    Types: Options = list() -> [] |
+    %                              [{user, "logdb"},
+    %                               {pass, "1234"},
+    %                               {db, "logdb"}] | ...
+    %          VHost = list() -> "jabber.example.org"
+    {start, 2},
+
+    % called from cleanup/1
+    % it should logoff database and do cleanup
+    % stop(VHost)
+    %    Types: VHost = list() -> "jabber.example.org"
+    {stop, 1},
+
+    % called from handle_call({addlog, _}, _, _)
+    % it should log messages to database
+    % log_message(VHost, Msg) -> ok | error
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          Msg = record() -> #msg
+    {log_message, 2},
+
+    % called from ejabberdctl rebuild_stats
+    % it should rebuild stats table (if used) for vhost
+    % rebuild_stats(VHost)
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    {rebuild_stats, 1},
+
+    % it should rebuild stats table (if used) for vhost at Date
+    % rebuild_stats_at(VHost, Date)
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          Date = list() -> "2007-02-12"
+    {rebuild_stats_at, 2},
+
+    % called from user_messages_at_parse_query/5
+    % it should delete selected user messages at date
+    % delete_messages_by_user_at(VHost, Msgs, Date) -> ok | error
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          Msgs = list() -> [ #msg1, msg2, ... ]
+    %          Date = list() -> "2007-02-12"
+    {delete_messages_by_user_at, 3},
+
+    % called from user_messages_parse_query/4 | vhost_messages_at_parse_query/4
+    % it should delete all user messages at date
+    % delete_all_messages_by_user_at(User, VHost, Date) -> ok | error
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    %          Date = list() -> "2007-02-12"
+    {delete_all_messages_by_user_at, 3},
+
+    % called from vhost_messages_parse_query/3
+    % it should delete messages for vhost at date and update stats
+    % delete_messages_at(VHost, Date) -> ok | error
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          Date = list() -> "2007-02-12"
+    {delete_messages_at, 2},
+
+    % called from ejabberd_web_admin:vhost_messages_stats/3
+    % it should return sorted list of count of messages by dates for vhost
+    % get_vhost_stats(VHost) -> {ok, [{Date1, Msgs_count1}, {Date2, Msgs_count2}, ... ]} |
+    %                           {error, Reason}
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          DateN = list() -> "2007-02-12"
+    %          Msgs_countN = number() -> 241
+    {get_vhost_stats, 1},
+
+    % called from ejabberd_web_admin:vhost_messages_stats_at/4
+    % it should return sorted list of count of messages by users at date for vhost
+    % get_vhost_stats_at(VHost, Date) -> {ok, [{User1, Msgs_count1}, {User2, Msgs_count2}, ....]} |
+    %                                    {error, Reason}
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          Date = list() -> "2007-02-12"
+    %          UserN = list() -> "admin"
+    %          Msgs_countN = number() -> 241
+    {get_vhost_stats_at, 2},
+
+    % called from ejabberd_web_admin:user_messages_stats/4
+    % it should return sorted list of count of messages by date for user at vhost
+    % get_user_stats(User, VHost) -> {ok, [{Date1, Msgs_count1}, {Date2, Msgs_count2}, ...]} |
+    %                                {error, Reason}
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    %          DateN = list() -> "2007-02-12"
+    %          Msgs_countN = number() -> 241
+    {get_user_stats, 2},
+
+    % called from ejabberd_web_admin:user_messages_stats_at/5
+    % it should return all user messages at date
+    % get_user_messages_at(User, VHost, Date) -> {ok, Msgs} | {error, Reason}
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    %          Date = list() -> "2007-02-12"
+    %          Msgs = list() -> [ #msg1, msg2, ... ]
+    {get_user_messages_at, 3},
+
+    % called from many places
+    % it should return list of dates for vhost
+    % get_dates(VHost) -> [Date1, Date2, ... ]
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    %          DateN = list() -> "2007-02-12"
+    {get_dates, 1},
+
+    % called from start
+    % it should return list with users settings for VHost in db
+    % get_users_settings(VHost) -> [#user_settings1, #user_settings2, ... ] | error
+    %    Types:
+    %          VHost = list() -> "jabber.example.org"
+    {get_users_settings, 1},
+
+    % called from many places
+    % it should return User settings at VHost from db
+    % get_user_settings(User, VHost) -> error | {ok, #user_settings}
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    {get_user_settings, 2},
+
+    % called from web admin
+    % it should set User settings at VHost
+    % set_user_settings(User, VHost, #user_settings) -> ok | error
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    {set_user_settings, 3},
+
+    % called from remove_user (ejabberd hook)
+    % it should remove user messages and settings at VHost
+    % drop_user(User, VHost) -> ok | error
+    %    Types:
+    %          User = list() -> "admin"
+    %          VHost = list() -> "jabber.example.org"
+    {drop_user, 2}
+   ];
+behaviour_info(_) ->
+   undefined.
diff --git a/src/mod_logdb.erl b/src/mod_logdb.erl
new file mode 100644
index 0000000000..d5983820ae
--- /dev/null
+++ b/src/mod_logdb.erl
@@ -0,0 +1,1952 @@
+%%%----------------------------------------------------------------------
+%%% File    : mod_logdb.erl
+%%% Author  : Oleg Palij (mailto:o.palij@gmail.com)
+%%% Purpose : Frontend for log user messages to db
+%%% Url     : https://paleg.github.io/mod_logdb/
+%%%----------------------------------------------------------------------
+
+-module(mod_logdb).
+-author('o.palij@gmail.com').
+
+-behaviour(gen_server).
+-behaviour(gen_mod).
+
+% supervisor
+-export([start_link/2]).
+% gen_mod
+-export([start/2, stop/1,
+         mod_opt_type/1,
+         depends/2, reload/3]).
+% gen_server
+-export([code_change/3,
+         handle_call/3, handle_cast/2, handle_info/2,
+         init/1, terminate/2]).
+% hooks
+-export([send_packet/1, receive_packet/1, offline_message/1, remove_user/2]).
+-export([get_local_identity/5,
+         get_local_features/5,
+         get_local_items/5,
+         adhoc_local_items/4,
+         adhoc_local_commands/4
+        ]).
+% ejabberdctl
+-export([rebuild_stats/1,
+         copy_messages/1, copy_messages_ctl/3, copy_messages_int_tc/1]).
+%
+-export([get_vhost_stats/1, get_vhost_stats_at/2,
+         get_user_stats/2, get_user_messages_at/3,
+         get_dates/1,
+         sort_stats/1,
+         convert_timestamp/1, convert_timestamp_brief/1,
+         get_user_settings/2, set_user_settings/3,
+         user_messages_at_parse_query/4, user_messages_parse_query/3,
+         vhost_messages_parse_query/2, vhost_messages_at_parse_query/4,
+         list_to_bool/1, bool_to_list/1,
+         list_to_string/1, string_to_list/1,
+         get_module_settings/1, set_module_settings/2,
+         purge_old_records/2]).
+% webadmin hooks
+-export([webadmin_menu/3,
+         webadmin_user/4,
+         webadmin_page/3,
+         user_parse_query/5]).
+% webadmin queries
+-export([vhost_messages_stats/3,
+         vhost_messages_stats_at/4,
+         user_messages_stats/4,
+         user_messages_stats_at/5]).
+
+-include("mod_logdb.hrl").
+-include("ejabberd.hrl").
+-include("xmpp.hrl").
+-include("mod_roster.hrl").
+-include("ejabberd_commands.hrl").
+-include("adhoc.hrl").
+-include("ejabberd_web_admin.hrl").
+-include("ejabberd_http.hrl").
+-include("logger.hrl").
+
+-define(PROCNAME, ejabberd_mod_logdb).
+% gen_server call timeout
+-define(CALL_TIMEOUT, 10000).
+
+-record(state, {vhost, dbmod, backendPid, monref, purgeRef, pollRef, dbopts, dbs, dolog_default, ignore_jids, groupchat, purge_older_days, poll_users_settings, drop_messages_on_user_removal}).
+
+ets_settings_table(VHost) -> list_to_atom("ets_logdb_settings_" ++ binary_to_list(VHost)).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_mod/gen_server callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% ejabberd starts module
+start(VHost, Opts) ->
+    ChildSpec =
+        {gen_mod:get_module_proc(VHost, ?PROCNAME),
+         {?MODULE, start_link, [VHost, Opts]},
+         permanent,
+         1000,
+         worker,
+         [?MODULE]},
+    % add child to ejabberd_sup
+    supervisor:start_child(ejabberd_gen_mod_sup, ChildSpec).
+
+depends(_Host, _Opts) ->
+    [].
+
+reload(_Host, _NewOpts, _OldOpts) ->
+    % TODO
+    ok.
+
+% supervisor starts gen_server
+start_link(VHost, Opts) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    {ok, Pid} = gen_server:start_link({local, Proc}, ?MODULE, [VHost, Opts], []),
+    Pid ! start,
+    {ok, Pid}.
+
+init([VHost, Opts]) ->
+    process_flag(trap_exit, true),
+    DBsRaw = gen_mod:get_opt(dbs, Opts, fun(A) -> A end, [{mnesia, []}]),
+    DBs = case lists:keysearch(mnesia, 1, DBsRaw) of
+               false -> lists:append(DBsRaw, [{mnesia,[]}]);
+               {value, _} -> DBsRaw
+          end,
+    VHostDB = gen_mod:get_opt(vhosts, Opts, fun(A) -> A end, [{VHost, mnesia}]),
+    % 10 is default because of using in clustered environment
+    PollUsersSettings = gen_mod:get_opt(poll_users_settings, Opts, fun(A) -> A end, 10),
+
+    {DBName, DBOpts} =
+         case lists:keysearch(VHost, 1, VHostDB) of
+              false ->
+                 ?WARNING_MSG("There is no logging backend defined for '~s', switching to mnesia", [VHost]),
+                 {mnesia, []};
+              {value,{_, DBNameResult}} ->
+                 case lists:keysearch(DBNameResult, 1, DBs) of
+                      false ->
+                        ?WARNING_MSG("There is no such logging backend '~s' defined for '~s', switching to mnesia", [DBNameResult, VHost]),
+                        {mnesia, []};
+                      {value, {_, DBOptsResult}} ->
+                        {DBNameResult, DBOptsResult}
+                 end
+         end,
+
+    ?MYDEBUG("Starting mod_logdb for '~s' with '~s' backend", [VHost, DBName]),
+
+    DBMod = list_to_atom(atom_to_list(?MODULE) ++ "_" ++ atom_to_list(DBName)),
+
+    {ok, #state{vhost=VHost,
+                dbmod=DBMod,
+                dbopts=DBOpts,
+                % dbs used for convert messages from one backend to other
+                dbs=DBs,
+                dolog_default=gen_mod:get_opt(dolog_default, Opts, fun(A) -> A end, true),
+                drop_messages_on_user_removal=gen_mod:get_opt(drop_messages_on_user_removal, Opts, fun(A) -> A end, true),
+                ignore_jids=gen_mod:get_opt(ignore_jids, Opts, fun(A) -> A end, []),
+                groupchat=gen_mod:get_opt(groupchat, Opts, fun(A) -> A end, none),
+                purge_older_days=gen_mod:get_opt(purge_older_days, Opts, fun(A) -> A end, never),
+                poll_users_settings=PollUsersSettings}}.
+
+cleanup(#state{vhost=VHost} = _State) ->
+    ?MYDEBUG("Stopping ~s for ~p", [?MODULE, VHost]),
+
+    %ets:delete(ets_settings_table(VHost)),
+
+    ejabberd_hooks:delete(remove_user, VHost, ?MODULE, remove_user, 90),
+    ejabberd_hooks:delete(user_send_packet, VHost, ?MODULE, send_packet, 90),
+    ejabberd_hooks:delete(user_receive_packet, VHost, ?MODULE, receive_packet, 90),
+    ejabberd_hooks:delete(offline_message_hook, VHost, ?MODULE, offline_message, 40),
+
+    ejabberd_hooks:delete(adhoc_local_commands, VHost, ?MODULE, adhoc_local_commands, 50),
+    ejabberd_hooks:delete(adhoc_local_items, VHost, ?MODULE, adhoc_local_items, 50),
+    ejabberd_hooks:delete(disco_local_identity, VHost, ?MODULE, get_local_identity, 50),
+    ejabberd_hooks:delete(disco_local_features, VHost, ?MODULE, get_local_features, 50),
+    ejabberd_hooks:delete(disco_local_items, VHost, ?MODULE, get_local_items, 50),
+
+    ejabberd_hooks:delete(webadmin_menu_host, VHost, ?MODULE, webadmin_menu, 70),
+    ejabberd_hooks:delete(webadmin_user, VHost, ?MODULE, webadmin_user, 50),
+    ejabberd_hooks:delete(webadmin_page_host, VHost, ?MODULE, webadmin_page, 50),
+    ejabberd_hooks:delete(webadmin_user_parse_query, VHost, ?MODULE, user_parse_query, 50),
+
+    ?MYDEBUG("Removed hooks for ~p", [VHost]),
+
+    ejabberd_commands:unregister_commands(get_commands_spec()),
+    ?MYDEBUG("Unregistered commands for ~p", [VHost]).
+
+stop(VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    %gen_server:call(Proc, {cleanup}),
+    %?MYDEBUG("Cleanup in stop finished!!!!", []),
+    %timer:sleep(10000),
+    ok = supervisor:terminate_child(ejabberd_gen_mod_sup, Proc),
+    ok = supervisor:delete_child(ejabberd_gen_mod_sup, Proc).
+
+get_commands_spec() ->
+    [#ejabberd_commands{name = rebuild_stats, tags = [logdb],
+            desc = "Rebuild mod_logdb stats for given host",
+            module = ?MODULE, function = rebuild_stats,
+            args = [{host, binary}],
+            result = {res, rescode}},
+     #ejabberd_commands{name = copy_messages, tags = [logdb],
+            desc = "Copy logdb messages from given backend to current backend for given host",
+            module = ?MODULE, function = copy_messages_ctl,
+            args = [{host, binary}, {backend, binary}, {date, binary}],
+            result = {res, rescode}}].
+
+mod_opt_type(dbs) ->
+    fun (A) when is_list(A) -> A end;
+mod_opt_type(vhosts) ->
+    fun (A) when is_list(A) -> A end;
+mod_opt_type(poll_users_settings) ->
+    fun (I) when is_integer(I) -> I end;
+mod_opt_type(groupchat) ->
+    fun (all) -> all;
+        (send) -> send;
+        (none) -> none
+    end;
+mod_opt_type(dolog_default) ->
+    fun (B) when is_boolean(B) -> B end;
+mod_opt_type(ignore_jids) ->
+    fun (A) when is_list(A) -> A end;
+mod_opt_type(purge_older_days) ->
+    fun (I) when is_integer(I) -> I end;
+mod_opt_type(_) ->
+    [dbs, vhosts, poll_users_settings, groupchat, dolog_default, ignore_jids, purge_older_days].
+
+handle_call({cleanup}, _From, State) ->
+    cleanup(State),
+    ?MYDEBUG("Cleanup finished!!!!!", []),
+    {reply, ok, State};
+handle_call({get_dates}, _From, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    Reply = DBMod:get_dates(VHost),
+    {reply, Reply, State};
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% ejabberd_web_admin callbacks
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+handle_call({delete_messages_by_user_at, PMsgs, Date}, _From, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    Reply = DBMod:delete_messages_by_user_at(VHost, PMsgs, binary_to_list(Date)),
+    {reply, Reply, State};
+handle_call({delete_all_messages_by_user_at, User, Date}, _From, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    Reply = DBMod:delete_all_messages_by_user_at(binary_to_list(User), VHost, binary_to_list(Date)),
+    {reply, Reply, State};
+handle_call({delete_messages_at, Date}, _From, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    Reply = DBMod:delete_messages_at(VHost, Date),
+    {reply, Reply, State};
+handle_call({get_vhost_stats}, _From, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    Reply = DBMod:get_vhost_stats(VHost),
+    {reply, Reply, State};
+handle_call({get_vhost_stats_at, Date}, _From, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    Reply = DBMod:get_vhost_stats_at(VHost, binary_to_list(Date)),
+    {reply, Reply, State};
+handle_call({get_user_stats, User}, _From, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    Reply = DBMod:get_user_stats(binary_to_list(User), VHost),
+    {reply, Reply, State};
+handle_call({get_user_messages_at, User, Date}, _From, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    Reply = DBMod:get_user_messages_at(binary_to_list(User), VHost, binary_to_list(Date)),
+    {reply, Reply, State};
+handle_call({get_user_settings, User}, _From, #state{dbmod=_DBMod, vhost=VHost}=State) ->
+    Reply = case ets:match_object(ets_settings_table(VHost),
+                                  #user_settings{owner_name=User, _='_'}) of
+                 [Set] -> Set;
+                 _ -> #user_settings{owner_name=User,
+                                     dolog_default=State#state.dolog_default,
+                                     dolog_list=[],
+                                     donotlog_list=[]}
+            end,
+    {reply, Reply, State};
+% TODO: remove User ??
+handle_call({set_user_settings, User, GSet}, _From, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    Set = GSet#user_settings{owner_name=User},
+    Reply =
+       case ets:match_object(ets_settings_table(VHost),
+                             #user_settings{owner_name=User, _='_'}) of
+            [Set] ->
+                ok;
+            _ ->
+                case DBMod:set_user_settings(binary_to_list(User), VHost, Set) of
+                     error ->
+                       error;
+                     ok ->
+                       true = ets:insert(ets_settings_table(VHost), Set),
+                       ok
+                end
+       end,
+    {reply, Reply, State};
+handle_call({get_module_settings}, _From, State) ->
+    {reply, State, State};
+handle_call({set_module_settings, #state{purge_older_days=PurgeDays,
+                                         poll_users_settings=PollSec} = Settings},
+            _From,
+            #state{purgeRef=PurgeRefOld,
+                   pollRef=PollRefOld,
+                   purge_older_days=PurgeDaysOld,
+                   poll_users_settings=PollSecOld} = State) ->
+    PurgeRef = if
+                 PurgeDays == never, PurgeDaysOld /= never  ->
+                    {ok, cancel} = timer:cancel(PurgeRefOld),
+                    disabled;
+                 is_integer(PurgeDays), PurgeDaysOld == never ->
+                    set_purge_timer(PurgeDays);
+                 true ->
+                    PurgeRefOld
+               end,
+
+    PollRef = if
+                PollSec == PollSecOld ->
+                   PollRefOld;
+                PollSec == 0, PollSecOld /= 0 ->
+                   {ok, cancel} = timer:cancel(PollRefOld),
+                   disabled;
+                is_integer(PollSec), PollSecOld == 0 ->
+                   set_poll_timer(PollSec);
+                is_integer(PollSec), PollSecOld /= 0 ->
+                   {ok, cancel} = timer:cancel(PollRefOld),
+                   set_poll_timer(PollSec)
+              end,
+
+    NewState = State#state{dolog_default=Settings#state.dolog_default,
+                           ignore_jids=Settings#state.ignore_jids,
+                           groupchat=Settings#state.groupchat,
+                           drop_messages_on_user_removal=Settings#state.drop_messages_on_user_removal,
+                           purge_older_days=PurgeDays,
+                           poll_users_settings=PollSec,
+                           purgeRef=PurgeRef,
+                           pollRef=PollRef},
+    {reply, ok, NewState};
+handle_call(Msg, _From, State) ->
+    ?INFO_MSG("Got call Msg: ~p, State: ~p", [Msg, State]),
+    {noreply, State}.
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% end ejabberd_web_admin callbacks
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+% ejabberd_hooks call
+handle_cast({addlog, Direction, Owner, Peer, Packet}, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    case filter(Owner, Peer, State) of
+         true ->
+              case catch packet_parse(Owner, Peer, Packet, Direction, State) of
+                   ignore ->
+                     ok;
+                   {'EXIT', Reason} ->
+                     ?ERROR_MSG("Failed to parse: ~p", [Reason]);
+                   Msg ->
+                     DBMod:log_message(VHost, Msg)
+              end;
+         false ->
+              ok
+    end,
+    {noreply, State};
+handle_cast({remove_user, User}, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    case State#state.drop_messages_on_user_removal of
+         true ->
+           DBMod:drop_user(binary_to_list(User), VHost),
+           ?INFO_MSG("Launched ~s@~s removal", [User, VHost]);
+         false ->
+           ?INFO_MSG("Message removing is disabled. Keeping messages for ~s@~s", [User, VHost])
+    end,
+    {noreply, State};
+% ejabberdctl rebuild_stats/3
+handle_cast({rebuild_stats}, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    DBMod:rebuild_stats(VHost),
+    {noreply, State};
+handle_cast({copy_messages, Backend}, State) ->
+    spawn(?MODULE, copy_messages, [[State, Backend, []]]),
+    {noreply, State};
+handle_cast({copy_messages, Backend, Date}, State) ->
+    spawn(?MODULE, copy_messages, [[State, Backend, [binary_to_list(Date)]]]),
+    {noreply, State};
+handle_cast(Msg, State) ->
+    ?INFO_MSG("Got cast Msg:~p, State:~p", [Msg, State]),
+    {noreply, State}.
+
+% return: disabled | timer reference
+set_purge_timer(PurgeDays) ->
+    case PurgeDays of
+         never -> disabled;
+         Days when is_integer(Days) ->
+              {ok, Ref1} = timer:send_interval(timer:hours(24), scheduled_purging),
+              Ref1
+    end.
+
+% return: disabled | timer reference
+set_poll_timer(PollSec) ->
+    if
+      PollSec > 0 ->
+        {ok, Ref2} = timer:send_interval(timer:seconds(PollSec), poll_users_settings),
+        Ref2;
+      % db polling disabled
+      PollSec == 0 ->
+        disabled;
+      true ->
+        {ok, Ref3} = timer:send_interval(timer:seconds(10), poll_users_settings),
+        Ref3
+    end.
+
+% actual starting of logging
+% from timer:send_after (in init)
+handle_info(start, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    case DBMod:start(VHost, State#state.dbopts) of
+         {error,{already_started,_}} ->
+           ?MYDEBUG("backend module already started - trying to stop it", []),
+           DBMod:stop(VHost),
+           {stop, already_started, State};
+         {error, Reason} ->
+           timer:sleep(30000),
+           ?ERROR_MSG("Failed to start: ~p", [Reason]),
+           {stop, db_connection_failed, State};
+         {ok, SPid} ->
+           ?INFO_MSG("~p connection established", [DBMod]),
+
+           MonRef = erlang:monitor(process, SPid),
+
+           ets:new(ets_settings_table(VHost), [named_table,public,set,{keypos, #user_settings.owner_name}]),
+           DoLog = case DBMod:get_users_settings(VHost) of
+                        {ok, Settings} -> [Sett#user_settings{owner_name = iolist_to_binary(Sett#user_settings.owner_name)} || Sett <- Settings];
+                        {error, _Reason} -> []
+                   end,
+           ets:insert(ets_settings_table(VHost), DoLog),
+
+           TrefPurge = set_purge_timer(State#state.purge_older_days),
+           TrefPoll = set_poll_timer(State#state.poll_users_settings),
+
+           ejabberd_hooks:add(remove_user, VHost, ?MODULE, remove_user, 90),
+           ejabberd_hooks:add(user_send_packet, VHost, ?MODULE, send_packet, 90),
+           ejabberd_hooks:add(user_receive_packet, VHost, ?MODULE, receive_packet, 90),
+           ejabberd_hooks:add(offline_message_hook, VHost, ?MODULE, offline_message, 40),
+
+           ejabberd_hooks:add(adhoc_local_commands, VHost, ?MODULE, adhoc_local_commands, 50),
+           ejabberd_hooks:add(disco_local_items, VHost, ?MODULE, get_local_items, 50),
+           ejabberd_hooks:add(disco_local_identity, VHost, ?MODULE, get_local_identity, 50),
+           ejabberd_hooks:add(disco_local_features, VHost, ?MODULE, get_local_features, 50),
+           ejabberd_hooks:add(adhoc_local_items, VHost, ?MODULE, adhoc_local_items, 50),
+
+           ejabberd_hooks:add(webadmin_menu_host, VHost, ?MODULE, webadmin_menu, 70),
+           ejabberd_hooks:add(webadmin_user, VHost, ?MODULE, webadmin_user, 50),
+           ejabberd_hooks:add(webadmin_page_host, VHost, ?MODULE, webadmin_page, 50),
+           ejabberd_hooks:add(webadmin_user_parse_query, VHost, ?MODULE, user_parse_query, 50),
+
+           ?MYDEBUG("Added hooks for ~p", [VHost]),
+
+           ejabberd_commands:register_commands(get_commands_spec()),
+           ?MYDEBUG("Registered commands for ~p", [VHost]),
+
+           NewState=State#state{monref = MonRef, backendPid=SPid, purgeRef=TrefPurge, pollRef=TrefPoll},
+           {noreply, NewState};
+        Rez ->
+           ?ERROR_MSG("Rez=~p", [Rez]),
+           timer:sleep(30000),
+           {stop, db_connection_failed, State}
+    end;
+% from timer:send_interval/2 (in start handle_info)
+handle_info(scheduled_purging, #state{vhost=VHost, purge_older_days=Days} = State) ->
+    ?MYDEBUG("Starting scheduled purging of old records for ~p", [VHost]),
+    spawn(?MODULE, purge_old_records, [VHost, integer_to_list(Days)]),
+    {noreply, State};
+% from timer:send_interval/2 (in start handle_info)
+handle_info(poll_users_settings, #state{dbmod=DBMod, vhost=VHost}=State) ->
+    {ok, DoLog} = DBMod:get_users_settings(VHost),
+    ?MYDEBUG("DoLog=~p", [DoLog]),
+    true = ets:delete_all_objects(ets_settings_table(VHost)),
+    ets:insert(ets_settings_table(VHost), DoLog),
+    {noreply, State};
+handle_info({'DOWN', _MonitorRef, process, _Pid, _Info}, State) ->
+    {stop, db_connection_dropped, State};
+handle_info({fetch_result, _, _}, State) ->
+    ?MYDEBUG("Got timed out mysql fetch result", []),
+    {noreply, State};
+handle_info(Info, State) ->
+    ?INFO_MSG("Got Info:~p, State:~p", [Info, State]),
+    {noreply, State}.
+
+terminate(db_connection_failed, _State) ->
+    ok;
+terminate(db_connection_dropped, State) ->
+    ?MYDEBUG("Got terminate with db_connection_dropped", []),
+    cleanup(State),
+    ok;
+terminate(Reason, #state{monref=undefined} = State) ->
+    ?MYDEBUG("Got terminate with undefined monref.~nReason: ~p", [Reason]),
+    cleanup(State),
+    ok;
+terminate(Reason, #state{dbmod=DBMod, vhost=VHost, monref=MonRef, backendPid=Pid} = State) ->
+    ?INFO_MSG("Reason: ~p", [Reason]),
+    case erlang:is_process_alive(Pid) of
+         true ->
+           erlang:demonitor(MonRef, [flush]),
+           DBMod:stop(VHost);
+         false ->
+           ok
+    end,
+    cleanup(State),
+    ok.
+
+code_change(_OldVsn, State, _Extra) ->
+    {ok, State}.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% ejabberd_hooks callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% TODO: change to/from to list as sql stores it as list
+send_packet({Pkt, #{jid := Owner} = C2SState}) ->
+    VHost = Owner#jid.lserver,
+    Peer = xmpp:get_to(Pkt),
+    %?MYDEBUG("send_packet. Peer=~p, Owner=~p", [Peer, Owner]),
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {addlog, to, Owner, Peer, Pkt}),
+    {Pkt, C2SState}.
+
+receive_packet({Pkt, #{jid := Owner} = C2SState}) ->
+    VHost = Owner#jid.lserver,
+    Peer = xmpp:get_from(Pkt),
+    %?MYDEBUG("receive_packet. Pkt=~p", [Pkt]),
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {addlog, from, Owner, Peer, Pkt}),
+    {Pkt, C2SState}.
+
+offline_message({_Action, #message{from = Peer, to = Owner} = Pkt} = Acc) ->
+    VHost = Owner#jid.lserver,
+    %?MYDEBUG("offline_message. Pkt=~p", [Pkt]),
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {addlog, from, Owner, Peer, Pkt}),
+    Acc.
+
+remove_user(User, Server) ->
+    LUser = jid:nodeprep(User),
+    LServer = jid:nameprep(Server),
+    Proc = gen_mod:get_module_proc(LServer, ?PROCNAME),
+    gen_server:cast(Proc, {remove_user, LUser}).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% ejabberdctl
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+rebuild_stats(VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {rebuild_stats}),
+    ok.
+
+copy_messages_ctl(VHost, Backend, <<"all">>) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {copy_messages, Backend}),
+    ok;
+copy_messages_ctl(VHost, Backend, Date) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:cast(Proc, {copy_messages, Backend, Date}),
+    ok.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% misc operations
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+% handle_cast({addlog, E}, _)
+% raw packet -> #msg
+packet_parse(_Owner, _Peer, #message{type = error}, _Direction, _State) ->
+    ignore;
+packet_parse(_Owner, _Peer, #message{meta = #{sm_copy := true}}, _Direction, _State) ->
+    ignore;
+packet_parse(_Owner, _Peer, #message{meta = #{from_offline := true}}, _Direction, _State) ->
+    ignore;
+packet_parse(Owner, Peer, #message{body = Body, subject = Subject, type = Type}, Direction, State) ->
+    %?MYDEBUG("Owner=~p, Peer=~p, Direction=~p", [Owner, Peer, Direction]),
+    %?MYDEBUG("Body=~p, Subject=~p, Type=~p", [Body, Subject, Type]),
+    SubjectText = xmpp:get_text(Subject),
+    BodyText = xmpp:get_text(Body),
+    if (SubjectText == <<"">>) and (BodyText == <<"">>) ->
+        throw(ignore);
+       true -> ok
+    end,
+
+    case Type of
+         groupchat when State#state.groupchat == send, Direction == to ->
+            ok;
+         groupchat when State#state.groupchat == send, Direction == from ->
+            throw(ignore);
+         groupchat when State#state.groupchat == none ->
+            throw(ignore);
+         _ ->
+            ok
+    end,
+
+    #msg{timestamp     = get_timestamp(),
+         owner_name    = stringprep:tolower(Owner#jid.user),
+         peer_name     = stringprep:tolower(Peer#jid.user),
+         peer_server   = stringprep:tolower(Peer#jid.server),
+         peer_resource = Peer#jid.resource,
+         direction     = Direction,
+         type          = misc:atom_to_binary(Type),
+         subject       = SubjectText,
+         body          = BodyText};
+packet_parse(_, _, _, _, _) ->
+    ignore.
+
+% called from handle_cast({addlog, _}, _) -> true (log messages) | false (do not log messages)
+filter(Owner, Peer, State) ->
+    OwnerBin = << (Owner#jid.luser)/binary, "@", (Owner#jid.lserver)/binary >>,
+    OwnerServ = << "@", (Owner#jid.lserver)/binary >>,
+    PeerBin = << (Peer#jid.luser)/binary, "@", (Peer#jid.lserver)/binary >>,
+    PeerServ = << "@", (Peer#jid.lserver)/binary >>,
+
+    LogTo = case ets:match_object(ets_settings_table(State#state.vhost),
+                                  #user_settings{owner_name=Owner#jid.luser, _='_'}) of
+                 [#user_settings{dolog_default=Default,
+                                 dolog_list=DLL,
+                                 donotlog_list=DNLL}] ->
+
+                      A = lists:member(PeerBin, DLL),
+                      B = lists:member(PeerBin, DNLL),
+                      if
+                        A -> true;
+                        B -> false;
+                        Default == true -> true;
+                        Default == false -> false;
+                        true -> State#state.dolog_default
+                      end;
+                 _ -> State#state.dolog_default
+            end,
+    lists:all(fun(O) -> O end,
+              [not lists:member(OwnerBin, State#state.ignore_jids),
+               not lists:member(PeerBin, State#state.ignore_jids),
+               not lists:member(OwnerServ, State#state.ignore_jids),
+               not lists:member(PeerServ, State#state.ignore_jids),
+               LogTo]).
+
+purge_old_records(VHost, Days) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+
+    Dates = ?MODULE:get_dates(VHost),
+    DateNow = calendar:datetime_to_gregorian_seconds({date(), {0,0,1}}),
+    DateDiff = list_to_integer(Days)*24*60*60,
+    ?MYDEBUG("Purging tables older than ~s days", [Days]),
+    lists:foreach(fun(Date) ->
+                    [Year, Month, Day] = ejabberd_regexp:split(iolist_to_binary(Date), <<"[^0-9]+">>),
+                    DateInSec = calendar:datetime_to_gregorian_seconds({{binary_to_integer(Year), binary_to_integer(Month), binary_to_integer(Day)}, {0,0,1}}),
+                    if
+                     (DateNow - DateInSec) > DateDiff ->
+                        gen_server:call(Proc, {delete_messages_at, Date});
+                     true ->
+                        ?MYDEBUG("Skipping messages at ~p", [Date])
+                    end
+              end, Dates).
+
+% called from get_vhost_stats/2, get_user_stats/3
+sort_stats(Stats) ->
+    % Stats = [{"2003-4-15",1}, {"2006-8-18",1}, ... ]
+    CFun = fun({TableName, Count}) ->
+                 [Year, Month, Day] = ejabberd_regexp:split(iolist_to_binary(TableName), <<"[^0-9]+">>),
+                 { calendar:datetime_to_gregorian_seconds({{binary_to_integer(Year), binary_to_integer(Month), binary_to_integer(Day)}, {0,0,1}}), Count }
+           end,
+    % convert to [{63364377601,1}, {63360662401,1}, ... ]
+    CStats = lists:map(CFun, Stats),
+    % sort by date
+    SortedStats = lists:reverse(lists:keysort(1, CStats)),
+    % convert to [{"2007-12-9",1}, {"2007-10-27",1}, ... ] sorted list
+    [{mod_logdb:convert_timestamp_brief(TableSec), Count} || {TableSec, Count} <- SortedStats].
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% Date/Time operations
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% return float seconds elapsed from "zero hour" as list
+get_timestamp() ->
+    {MegaSec, Sec, MicroSec} = now(),
+    [List] = io_lib:format("~.5f", [MegaSec*1000000 + Sec + MicroSec/1000000]),
+    List.
+
+% convert float seconds elapsed from "zero hour" to local time "%Y-%m-%d %H:%M:%S" string
+convert_timestamp(Seconds) when is_list(Seconds) ->
+    case string:to_float(Seconds++".0") of
+         {F,_} when is_float(F) -> convert_timestamp(F);
+         _ -> erlang:error(badarg, [Seconds])
+    end;
+convert_timestamp(Seconds) when is_float(Seconds) ->
+    GregSec = trunc(Seconds + 719528*86400),
+    UnivDT = calendar:gregorian_seconds_to_datetime(GregSec),
+    {{Year, Month, Day},{Hour, Minute, Sec}} = calendar:universal_time_to_local_time(UnivDT),
+    integer_to_list(Year) ++ "-" ++ integer_to_list(Month) ++ "-" ++ integer_to_list(Day) ++ " " ++ integer_to_list(Hour) ++ ":" ++ integer_to_list(Minute) ++ ":" ++ integer_to_list(Sec).
+
+% convert float seconds elapsed from "zero hour" to local time "%Y-%m-%d" string
+convert_timestamp_brief(Seconds) when is_list(Seconds) ->
+    convert_timestamp_brief(list_to_float(Seconds));
+convert_timestamp_brief(Seconds) when is_float(Seconds) ->
+    GregSec = trunc(Seconds + 719528*86400),
+    UnivDT = calendar:gregorian_seconds_to_datetime(GregSec),
+    {{Year, Month, Day},{_Hour, _Minute, _Sec}} = calendar:universal_time_to_local_time(UnivDT),
+    integer_to_list(Year) ++ "-" ++ integer_to_list(Month) ++ "-" ++ integer_to_list(Day);
+convert_timestamp_brief(Seconds) when is_integer(Seconds) ->
+    {{Year, Month, Day},{_Hour, _Minute, _Sec}} = calendar:gregorian_seconds_to_datetime(Seconds),
+    integer_to_list(Year) ++ "-" ++ integer_to_list(Month) ++ "-" ++ integer_to_list(Day).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% DB operations (get)
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+get_vhost_stats(VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_vhost_stats}, ?CALL_TIMEOUT).
+
+get_vhost_stats_at(VHost, Date) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_vhost_stats_at, Date}, ?CALL_TIMEOUT).
+
+get_user_stats(User, VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_user_stats, User}, ?CALL_TIMEOUT).
+
+get_user_messages_at(User, VHost, Date) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_user_messages_at, User, Date}, ?CALL_TIMEOUT).
+
+get_dates(VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_dates}, ?CALL_TIMEOUT).
+
+get_user_settings(User, VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_user_settings, User}, ?CALL_TIMEOUT).
+
+set_user_settings(User, VHost, Set) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {set_user_settings, User, Set}).
+
+get_module_settings(VHost) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {get_module_settings}).
+
+set_module_settings(VHost, Settings) ->
+    Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+    gen_server:call(Proc, {set_module_settings, Settings}).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% Web admin callbacks (delete)
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+user_messages_at_parse_query(VHost, Date, Msgs, Query) ->
+    case lists:keysearch(<<"delete">>, 1, Query) of
+         {value, _} ->
+             PMsgs = lists:filter(
+                              fun(Msg) ->
+                                   ID = misc:encode_base64(term_to_binary(Msg#msg.timestamp)),
+                                   lists:member({<<"selected">>, ID}, Query)
+                              end, Msgs),
+             Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+             gen_server:call(Proc, {delete_messages_by_user_at, PMsgs, Date}, ?CALL_TIMEOUT);
+         false ->
+             nothing
+    end.
+
+user_messages_parse_query(User, VHost, Query) ->
+    case lists:keysearch(<<"delete">>, 1, Query) of
+         {value, _} ->
+             Dates = get_dates(VHost),
+             PDates = lists:filter(
+                              fun(Date) ->
+                                   ID = misc:encode_base64( << User/binary, (iolist_to_binary(Date))/binary >> ),
+                                   lists:member({<<"selected">>, ID}, Query)
+                              end, Dates),
+             Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+             Rez = lists:foldl(
+                          fun(Date, Acc) ->
+                              lists:append(Acc,
+                                           [gen_server:call(Proc,
+                                                            {delete_all_messages_by_user_at, User, iolist_to_binary(Date)},
+                                                            ?CALL_TIMEOUT)])
+                          end, [], PDates),
+             case lists:member(error, Rez) of
+                  true ->
+                    error;
+                  false ->
+                    nothing
+             end;
+         false ->
+             nothing
+    end.
+
+vhost_messages_parse_query(VHost, Query) ->
+    case lists:keysearch(<<"delete">>, 1, Query) of
+         {value, _} ->
+             Dates = get_dates(VHost),
+             PDates = lists:filter(
+                              fun(Date) ->
+                                   ID = misc:encode_base64( << VHost/binary, (iolist_to_binary(Date))/binary >> ),
+                                   lists:member({<<"selected">>, ID}, Query)
+                              end, Dates),
+             Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+             Rez = lists:foldl(fun(Date, Acc) ->
+                                   lists:append(Acc, [gen_server:call(Proc,
+                                                                      {delete_messages_at, Date},
+                                                                      ?CALL_TIMEOUT)])
+                               end, [], PDates),
+             case lists:member(error, Rez) of
+                  true ->
+                    error;
+                  false ->
+                    nothing
+             end;
+         false ->
+             nothing
+    end.
+
+vhost_messages_at_parse_query(VHost, Date, Stats, Query) ->
+    case lists:keysearch(<<"delete">>, 1, Query) of
+         {value, _} ->
+             PStats = lists:filter(
+                              fun({User, _Count}) ->
+                                   ID = misc:encode_base64( << (iolist_to_binary(User))/binary, VHost/binary >> ),
+                                   lists:member({<<"selected">>, ID}, Query)
+                              end, Stats),
+             Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+             Rez = lists:foldl(fun({User, _Count}, Acc) ->
+                                   lists:append(Acc, [gen_server:call(Proc,
+                                                                      {delete_all_messages_by_user_at,
+                                                                       iolist_to_binary(User), iolist_to_binary(Date)},
+                                                                      ?CALL_TIMEOUT)])
+                               end, [], PStats),
+             case lists:member(error, Rez) of
+                  true ->
+                    error;
+                  false ->
+                    ok
+             end;
+         false ->
+             nothing
+    end.
+
+copy_messages([#state{vhost=VHost}=State, From, DatesIn]) ->
+    {FromDBName, FromDBOpts} =
+         case lists:keysearch(misc:binary_to_atom(From), 1, State#state.dbs) of
+              {value, {FN, FO}} ->
+                 {FN, FO};
+              false ->
+                 ?ERROR_MSG("Failed to find record for ~p in dbs", [From]),
+                 throw(error)
+         end,
+
+    FromDBMod = list_to_atom(atom_to_list(?MODULE) ++ "_" ++ atom_to_list(FromDBName)),
+
+    {ok, _FromPid} = FromDBMod:start(VHost, FromDBOpts),
+
+    Dates = case DatesIn of
+                 [] -> FromDBMod:get_dates(VHost);
+                 _ -> DatesIn
+            end,
+
+    DatesLength = length(Dates),
+
+    catch lists:foldl(fun(Date, Acc) ->
+                        case catch copy_messages_int([FromDBMod, State#state.dbmod, VHost, Date]) of
+                            ok ->
+                                ?INFO_MSG("Copied messages at ~p (~p/~p)", [Date, Acc, DatesLength]);
+                            Value ->
+                                ?ERROR_MSG("Failed to copy messages at ~p (~p/~p): ~p", [Date, Acc, DatesLength, Value]),
+                                throw(error)
+                        end,
+                        Acc + 1
+                      end, 1, Dates),
+    ?INFO_MSG("copy_messages from ~p finished",  [From]),
+    FromDBMod:stop(VHost).
+
+copy_messages_int([FromDBMod, ToDBMod, VHost, Date]) ->
+    ets:new(mod_logdb_temp, [named_table, set, public]),
+    {Time, Value} = timer:tc(?MODULE, copy_messages_int_tc, [[FromDBMod, ToDBMod, VHost, Date]]),
+    ets:delete_all_objects(mod_logdb_temp),
+    ets:delete(mod_logdb_temp),
+    ?INFO_MSG("copy_messages at ~p elapsed ~p sec", [Date, Time/1000000]),
+    Value.
+
+copy_messages_int_tc([FromDBMod, ToDBMod, VHost, Date]) ->
+    ?INFO_MSG("Going to copy messages from ~p for ~p at ~p", [FromDBMod, VHost, Date]),
+
+    ok = FromDBMod:rebuild_stats_at(VHost, Date),
+    catch mod_logdb:rebuild_stats_at(VHost, Date),
+    {ok, FromStats} = FromDBMod:get_vhost_stats_at(VHost, Date),
+    ToStats = case mod_logdb:get_vhost_stats_at(VHost, iolist_to_binary(Date)) of
+                   {ok, Stats} -> Stats;
+                   {error, _} -> []
+              end,
+
+    FromStatsS = lists:keysort(1, FromStats),
+    ToStatsS = lists:keysort(1, ToStats),
+
+    StatsLength = length(FromStats),
+
+    CopyFun = if
+                % destination table is empty
+                ToStats == [] ->
+                    fun({User, _Count}, Acc) ->
+                        {ok, Msgs} = FromDBMod:get_user_messages_at(User, VHost, Date),
+                        MAcc =
+                          lists:foldl(fun(Msg, MFAcc) ->
+                                          MsgBinary = Msg#msg{owner_name=iolist_to_binary(User),
+                                                              peer_name=iolist_to_binary(Msg#msg.peer_name),
+                                                              peer_server=iolist_to_binary(Msg#msg.peer_server),
+                                                              peer_resource=iolist_to_binary(Msg#msg.peer_resource),
+                                                              type=iolist_to_binary(Msg#msg.type),
+                                                              subject=iolist_to_binary(Msg#msg.subject),
+                                                              body=iolist_to_binary(Msg#msg.body)},
+                                          ok = ToDBMod:log_message(VHost, MsgBinary),
+                                          MFAcc + 1
+                                      end, 0, Msgs),
+                        NewAcc = Acc + 1,
+                        ?INFO_MSG("Copied ~p messages for ~p (~p/~p) at ~p", [MAcc, User, NewAcc, StatsLength, Date]),
+                        %timer:sleep(100),
+                        NewAcc
+                    end;
+                % destination table is not empty
+                true ->
+                    fun({User, _Count}, Acc) ->
+                        {ok, ToMsgs} = ToDBMod:get_user_messages_at(User, VHost, Date),
+                        lists:foreach(fun(#msg{timestamp=Tst}) when length(Tst) == 16 ->
+                                            ets:insert(mod_logdb_temp, {Tst});
+                                         % mysql, pgsql removes final zeros after decimal point
+                                         (#msg{timestamp=Tst}) when length(Tst) < 16 ->
+                                            {F, _} = string:to_float(Tst++".0"),
+                                            [T] = io_lib:format("~.5f", [F]),
+                                            ets:insert(mod_logdb_temp, {T})
+                                      end, ToMsgs),
+                        {ok, Msgs} = FromDBMod:get_user_messages_at(User, VHost, Date),
+                        MAcc =
+                          lists:foldl(fun(#msg{timestamp=ToTimestamp} = Msg, MFAcc) ->
+                                          case ets:member(mod_logdb_temp, ToTimestamp) of
+                                               false ->
+                                                  MsgBinary = Msg#msg{owner_name=iolist_to_binary(User),
+                                                                      peer_name=iolist_to_binary(Msg#msg.peer_name),
+                                                                      peer_server=iolist_to_binary(Msg#msg.peer_server),
+                                                                      peer_resource=iolist_to_binary(Msg#msg.peer_resource),
+                                                                      type=iolist_to_binary(Msg#msg.type),
+                                                                      subject=iolist_to_binary(Msg#msg.subject),
+                                                                      body=iolist_to_binary(Msg#msg.body)},
+                                                  ok = ToDBMod:log_message(VHost, MsgBinary),
+                                                  ets:insert(mod_logdb_temp, {ToTimestamp}),
+                                                  MFAcc + 1;
+                                               true ->
+                                                  MFAcc
+                                          end
+                                      end, 0, Msgs),
+                        NewAcc = Acc + 1,
+                        ets:delete_all_objects(mod_logdb_temp),
+                        ?INFO_MSG("Copied ~p messages for ~p (~p/~p) at ~p", [MAcc, User, NewAcc, StatsLength, Date]),
+                        %timer:sleep(100),
+                        NewAcc
+                    end
+              end,
+
+    if
+      FromStats == [] ->
+        ?INFO_MSG("No messages were found at ~p", [Date]);
+      FromStatsS == ToStatsS ->
+        ?INFO_MSG("Stats are equal at ~p", [Date]);
+      FromStatsS /= ToStatsS ->
+        lists:foldl(CopyFun, 0, FromStats),
+        ok = ToDBMod:rebuild_stats_at(VHost, Date)
+        %timer:sleep(1000)
+    end,
+
+    ok.
+
+list_to_bool(Num) when is_binary(Num) ->
+    list_to_bool(binary_to_list(Num));
+list_to_bool(Num) when is_list(Num) ->
+    case lists:member(Num, ["t", "true", "y", "yes", "1"]) of
+         true ->
+           true;
+         false ->
+           case lists:member(Num, ["f", "false", "n", "no", "0"]) of
+                true ->
+                  false;
+                false ->
+                  error
+           end
+    end.
+
+bool_to_list(true) ->
+    "TRUE";
+bool_to_list(false) ->
+    "FALSE".
+
+list_to_string([]) ->
+    "";
+list_to_string(List) when is_list(List) ->
+    Str = lists:flatmap(fun(Elm) when is_binary(Elm) ->
+                              binary_to_list(Elm) ++ "\n";
+                           (Elm) when is_list(Elm) ->
+                              Elm ++ "\n"
+                        end, List),
+    lists:sublist(Str, length(Str)-1).
+
+string_to_list(null) ->
+    [];
+string_to_list([]) ->
+    [];
+string_to_list(String) ->
+    ejabberd_regexp:split(iolist_to_binary(String), <<"\n">>).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% ad-hoc (copy/pasted from mod_configure.erl)
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+-define(ITEMS_RESULT(Allow, LNode, Fallback),
+    case Allow of
+        deny -> Fallback;
+        allow ->
+            case get_local_items(LServer, LNode,
+                                 jid:encode(To), Lang) of
+                {result, Res} -> {result, Res};
+                {error, Error} -> {error, Error}
+            end
+    end).
+
+get_local_items(Acc, From, #jid{lserver = LServer} = To,
+                <<"">>, Lang) ->
+    case gen_mod:is_loaded(LServer, mod_adhoc) of
+        false -> Acc;
+        _ ->
+            Items = case Acc of
+                         {result, Its} -> Its;
+                         empty -> []
+                    end,
+            AllowUser = acl:match_rule(LServer, mod_logdb, From),
+            AllowAdmin = acl:match_rule(LServer, mod_logdb_admin, From),
+            if
+              AllowUser == allow; AllowAdmin == allow ->
+                case get_local_items(LServer, [],
+                                     jid:encode(To), Lang) of
+                     {result, Res} ->
+                        {result, Items ++ Res};
+                     {error, _Error} ->
+                        {result, Items}
+                end;
+              true ->
+                {result, Items}
+            end
+    end;
+get_local_items(Acc, From, #jid{lserver = LServer} = To,
+                Node, Lang) ->
+    case gen_mod:is_loaded(LServer, mod_adhoc) of
+        false -> Acc;
+        _ ->
+            LNode = tokenize(Node),
+            AllowAdmin = acl:match_rule(LServer, mod_logdb_admin, From),
+            Err = xmpp:err_forbidden(<<"Denied by ACL">>, Lang),
+            case LNode of
+                 [<<"mod_logdb">>] ->
+                      ?ITEMS_RESULT(AllowAdmin, LNode, {error, Err});
+                 [<<"mod_logdb_users">>] ->
+                      ?ITEMS_RESULT(AllowAdmin, LNode, {error, Err});
+                 [<<"mod_logdb_users">>, <<$@, _/binary>>] ->
+                      ?ITEMS_RESULT(AllowAdmin, LNode, {error, Err});
+                 [<<"mod_logdb_users">>, _User] ->
+                      ?ITEMS_RESULT(AllowAdmin, LNode, {error, Err});
+                 [<<"mod_logdb_settings">>] ->
+                      ?ITEMS_RESULT(AllowAdmin, LNode, {error, Err});
+                 _ ->
+                      Acc
+            end
+    end.
+
+-define(T(Lang, Text), translate:translate(Lang, Text)).
+
+-define(NODE(Name, Node),
+    #disco_item{jid = jid:make(Server),
+            node = Node,
+            name = ?T(Lang, Name)}).
+
+-define(NS_ADMINX(Sub),
+    <<(?NS_ADMIN)/binary, "#", Sub/binary>>).
+
+tokenize(Node) -> str:tokens(Node, <<"/#">>).
+
+get_local_items(_Host, [], Server, Lang) ->
+    {result,
+     [?NODE(<<"Messages logging engine">>, <<"mod_logdb">>)]
+    };
+get_local_items(_Host, [<<"mod_logdb">>], Server, Lang) ->
+    {result,
+     [?NODE(<<"Messages logging engine users">>, <<"mod_logdb_users">>),
+      ?NODE(<<"Messages logging engine settings">>, <<"mod_logdb_settings">>)]
+    };
+get_local_items(Host, [<<"mod_logdb_users">>], Server, _Lang) ->
+    {result, get_all_vh_users(Host, Server)};
+get_local_items(Host, [<<"mod_logdb_users">>, <<$@, Diap/binary>>], Server, Lang) ->
+    Users = ejabberd_auth:get_vh_registered_users(Host),
+    SUsers = lists:sort([{S, U} || {U, S} <- Users]),
+    try
+        [S1, S2] = ejabberd_regexp:split(Diap, <<"-">>),
+        N1 = binary_to_integer(S1),
+        N2 = binary_to_integer(S2),
+        Sub = lists:sublist(SUsers, N1, N2 - N1 + 1),
+        {result, lists:map(fun({S, U}) ->
+                               ?NODE(<< U/binary, "@", S/binary >>,
+                                     << (iolist_to_binary("mod_logdb_users/"))/binary, U/binary, "@", S/binary >>)
+                           end, Sub)}
+    catch _:_ ->
+        xmpp:err_not_acceptable()
+    end;
+get_local_items(_Host, [<<"mod_logdb_users">>, _User], _Server, _Lang) ->
+    {result, []};
+get_local_items(_Host, [<<"mod_logdb_settings">>], _Server, _Lang) ->
+    {result, []};
+get_local_items(_Host, Item, _Server, _Lang) ->
+    ?MYDEBUG("asked for items in ~p", [Item]),
+    {error, xmpp:err_item_not_found()}.
+
+-define(INFO_RESULT(Allow, Feats, Lang),
+    case Allow of
+      deny -> {error, xmpp:err_forbidden(<<"Denied by ACL">>, Lang)};
+      allow -> {result, Feats}
+    end).
+
+get_local_features(Acc, From,
+                   #jid{lserver = LServer} = _To, Node, Lang) ->
+    case gen_mod:is_loaded(LServer, mod_adhoc) of
+        false ->
+            Acc;
+        _ ->
+            LNode = tokenize(Node),
+            AllowUser = acl:match_rule(LServer, mod_logdb, From),
+            AllowAdmin = acl:match_rule(LServer, mod_logdb_admin, From),
+            case LNode of
+                 [<<"mod_logdb">>] when AllowUser == allow; AllowAdmin == allow ->
+                    ?INFO_RESULT(allow, [?NS_COMMANDS], Lang);
+                 [<<"mod_logdb">>] ->
+                    ?INFO_RESULT(deny, [?NS_COMMANDS], Lang);
+                 [<<"mod_logdb_users">>] ->
+                    ?INFO_RESULT(AllowAdmin, [], Lang);
+                 [<<"mod_logdb_users">>, [$@ | _]] ->
+                    ?INFO_RESULT(AllowAdmin, [], Lang);
+                 [<<"mod_logdb_users">>, _User] ->
+                    ?INFO_RESULT(AllowAdmin, [?NS_COMMANDS], Lang);
+                 [<<"mod_logdb_settings">>] ->
+                    ?INFO_RESULT(AllowAdmin, [?NS_COMMANDS], Lang);
+                 [] ->
+                    Acc;
+                 _ ->
+                    Acc
+            end
+    end.
+
+-define(INFO_IDENTITY(Category, Type, Name, Lang),
+    [#identity{category = Category, type = Type, name = ?T(Lang, Name)}]).
+
+-define(INFO_COMMAND(Name, Lang),
+    ?INFO_IDENTITY(<<"automation">>, <<"command-node">>,
+               Name, Lang)).
+
+get_local_identity(Acc, _From, _To, Node, Lang) ->
+    LNode = tokenize(Node),
+    case LNode of
+         [<<"mod_logdb">>] ->
+            ?INFO_COMMAND(<<"Messages logging engine">>, Lang);
+         [<<"mod_logdb_users">>] ->
+            ?INFO_COMMAND(<<"Messages logging engine users">>, Lang);
+         [<<"mod_logdb_users">>, User] ->
+            ?INFO_COMMAND(User, Lang);
+         [<<"mod_logdb_settings">>] ->
+            ?INFO_COMMAND(<<"Messages logging engine settings">>, Lang);
+         _ ->
+            Acc
+    end.
+
+adhoc_local_items(Acc, From,
+                  #jid{lserver = LServer, server = Server} = To, Lang) ->
+    % TODO: case acl:match_rule(LServer, ???, From) of
+    Items = case Acc of
+                {result, Its} -> Its;
+                empty -> []
+            end,
+    Nodes = recursively_get_local_items(LServer,
+                                        <<"">>, Server, Lang),
+    Nodes1 = lists:filter(
+               fun(#disco_item{node = Nd}) ->
+                        F = get_local_features([], From, To, Nd, Lang),
+                        case F of
+                            {result, [?NS_COMMANDS]} -> true;
+                            _ -> false
+                        end
+               end, Nodes),
+    {result, Items ++ Nodes1}.
+
+recursively_get_local_items(_LServer,
+                            <<"mod_logdb_users">>, _Server, _Lang) ->
+    [];
+recursively_get_local_items(LServer,
+                            Node, Server, Lang) ->
+    LNode = tokenize(Node),
+    Items = case get_local_items(LServer, LNode,
+                                 Server, Lang) of
+                {result, Res} -> Res;
+                {error, _Error} -> []
+            end,
+    Nodes = lists:flatten(
+      lists:map(
+        fun(#disco_item{jid = #jid{server = S}, node = Nd} = Item) ->
+                if (S /= Server) or (Nd == <<"">>) ->
+                    [];
+                true ->
+                    [Item, recursively_get_local_items(
+                            LServer, Nd, Server, Lang)]
+                end
+        end, Items)),
+    Nodes.
+
+-define(COMMANDS_RESULT(Allow, From, To, Request),
+    case Allow of
+        deny ->
+            {error, xmpp:err_forbidden(<<"Denied by ACL">>, Lang)};
+        allow ->
+            adhoc_local_commands(From, To, Request)
+    end).
+
+adhoc_local_commands(Acc, From, #jid{lserver = LServer} = To,
+                     #adhoc_command{node = Node, lang = Lang} = Request) ->
+    LNode = tokenize(Node),
+    AllowUser = acl:match_rule(LServer, mod_logdb, From),
+    AllowAdmin = acl:match_rule(LServer, mod_logdb_admin, From),
+    case LNode of
+         [<<"mod_logdb">>] when AllowUser == allow; AllowAdmin == allow ->
+             ?COMMANDS_RESULT(allow, From, To, Request);
+         [<<"mod_logdb_users">>, <<$@, _/binary>>] when AllowAdmin == allow ->
+             Acc;
+         [<<"mod_logdb_users">>, _User] when AllowAdmin == allow ->
+             ?COMMANDS_RESULT(allow, From, To, Request);
+         [<<"mod_logdb_settings">>] when AllowAdmin == allow ->
+             ?COMMANDS_RESULT(allow, From, To, Request);
+         _ ->
+             Acc
+    end.
+
+adhoc_local_commands(From, #jid{lserver = LServer} = _To,
+                     #adhoc_command{lang = Lang,
+                                    node = Node,
+                                    sid = SessionID,
+                                    action = Action,
+                                    xdata = XData} = Request) ->
+    LNode = tokenize(Node),
+    %% If the "action" attribute is not present, it is
+    %% understood as "execute".  If there was no <actions/>
+    %% element in the first response (which there isn't in our
+    %% case), "execute" and "complete" are equivalent.
+    ActionIsExecute = Action == execute orelse Action == complete,
+    if Action == cancel ->
+            %% User cancels request
+            #adhoc_command{status = canceled, lang = Lang,
+                           node = Node, sid = SessionID};
+       XData == undefined, ActionIsExecute ->
+            %% User requests form
+            case get_form(LServer, LNode, Lang) of
+                {result, Form} ->
+                    xmpp_util:make_adhoc_response(
+                      Request,
+                      #adhoc_command{status = executing,
+                                     xdata = Form});
+                {error, Error} ->
+                    {error, Error}
+            end;
+       XData /= undefined, ActionIsExecute ->
+            %% User returns form.
+            case catch set_form(From, LServer, LNode, Lang, XData) of
+                {result, Res} ->
+                    xmpp_util:make_adhoc_response(
+                      Request,
+                      #adhoc_command{xdata = Res, status = completed});
+                {'EXIT', _} -> {error, xmpp:err_bad_request()};
+                {error, Error} -> {error, Error}
+            end;
+       true ->
+            {error, xmpp:err_bad_request(<<"Unexpected action">>, Lang)}
+    end.
+
+-define(TVFIELD(Type, Var, Val),
+    #xdata_field{type = Type, var = Var, values = [Val]}).
+
+-define(HFIELD(),
+    ?TVFIELD(hidden, <<"FORM_TYPE">>, (?NS_ADMIN))).
+
+get_user_form(LUser, LServer, Lang) ->
+    ?MYDEBUG("get_user_form ~p ~p", [LUser, LServer]),
+    %From = jid:encode(jid:remove_resource(Jid)),
+    #user_settings{dolog_default=DLD,
+                   dolog_list=DLL,
+                   donotlog_list=DNLL} = get_user_settings(LUser, LServer),
+    Fs = [
+          #xdata_field{
+             type = 'list-single',
+             label = ?T(Lang, <<"Default">>),
+             var = <<"dolog_default">>,
+             values = [misc:atom_to_binary(DLD)],
+             options = [#xdata_option{label = ?T(Lang, <<"Log Messages">>),
+                                      value = <<"true">>},
+                        #xdata_option{label = ?T(Lang, <<"Do Not Log Messages">>),
+                                      value = <<"false">>}]},
+          #xdata_field{
+             type = 'text-multi',
+             label = ?T(Lang, <<"Log Messages">>),
+             var = <<"dolog_list">>,
+             values = DLL},
+          #xdata_field{
+             type = 'text-multi',
+             label = ?T(Lang, <<"Do Not Log Messages">>),
+             var = <<"donotlog_list">>,
+             values = DNLL}
+         ],
+    {result, #xdata{
+                title = ?T(Lang, <<"Messages logging engine settings">>),
+                type = form,
+                instructions = [<< (?T(Lang, <<"Set logging preferences">>))/binary,
+                                               (iolist_to_binary(": "))/binary,
+                                               LUser/binary, "@", LServer/binary >>],
+                fields = [?HFIELD()|
+                          Fs]}}.
+
+get_settings_form(Host, Lang) ->
+    ?MYDEBUG("get_settings_form ~p ~p", [Host, Lang]),
+    #state{dbmod=_DBMod,
+           dbs=_DBs,
+           dolog_default=DLD,
+           ignore_jids=IgnoreJids,
+           groupchat=GroupChat,
+           purge_older_days=PurgeDaysT,
+           drop_messages_on_user_removal=MRemoval,
+           poll_users_settings=PollTime} = mod_logdb:get_module_settings(Host),
+
+    PurgeDays =
+       case PurgeDaysT of
+            never -> <<"never">>;
+            Num when is_integer(Num) -> integer_to_binary(Num);
+            _ -> <<"unknown">>
+       end,
+    Fs = [
+          #xdata_field{
+             type = 'list-single',
+             label = ?T(Lang, <<"Default">>),
+             var = <<"dolog_default">>,
+             values = [misc:atom_to_binary(DLD)],
+             options = [#xdata_option{label = ?T(Lang, <<"Log Messages">>),
+                                      value = <<"true">>},
+                        #xdata_option{label = ?T(Lang, <<"Do Not Log Messages">>),
+                                      value = <<"false">>}]},
+          #xdata_field{
+             type = 'list-single',
+             label = ?T(Lang, <<"Drop messages on user removal">>),
+             var = <<"drop_messages_on_user_removal">>,
+             values = [misc:atom_to_binary(MRemoval)],
+             options = [#xdata_option{label = ?T(Lang, <<"Drop">>),
+                                      value = <<"true">>},
+                        #xdata_option{label = ?T(Lang, <<"Do not drop">>),
+                                      value = <<"false">>}]},
+          #xdata_field{
+             type = 'list-single',
+             label = ?T(Lang, <<"Groupchat messages logging">>),
+             var = <<"groupchat">>,
+             values = [misc:atom_to_binary(GroupChat)],
+             options = [#xdata_option{label = ?T(Lang, <<"all">>),
+                                      value = <<"all">>},
+                        #xdata_option{label = ?T(Lang, <<"none">>),
+                                      value = <<"none">>},
+                        #xdata_option{label = ?T(Lang, <<"send">>),
+                                      value = <<"send">>}]},
+          #xdata_field{
+             type = 'text-multi',
+             label = ?T(Lang, <<"Jids/Domains to ignore">>),
+             var = <<"ignore_list">>,
+             values = IgnoreJids},
+          #xdata_field{
+             type = 'text-single',
+             label = ?T(Lang, <<"Purge messages older than (days)">>),
+             var = <<"purge_older_days">>,
+             values = [iolist_to_binary(PurgeDays)]},
+          #xdata_field{
+             type = 'text-single',
+             label = ?T(Lang, <<"Poll users settings (seconds)">>),
+             var = <<"poll_users_settings">>,
+             values = [integer_to_binary(PollTime)]}
+         ],
+    {result, #xdata{
+                title = ?T(Lang, <<"Messages logging engine settings (run-time)">>),
+                instructions = [?T(Lang, <<"Set run-time settings">>)],
+                type = form,
+                fields = [?HFIELD()|
+                          Fs]}}.
+
+get_form(_Host, [<<"mod_logdb_users">>, User], Lang) ->
+    #jid{luser=LUser, lserver=LServer} = jid:decode(User),
+    get_user_form(LUser, LServer, Lang);
+get_form(Host, [<<"mod_logdb_settings">>], Lang) ->
+    get_settings_form(Host, Lang);
+get_form(_Host, Command, _Lang) ->
+    ?MYDEBUG("asked for form ~p", [Command]),
+    {error, xmpp:err_service_unavailable()}.
+
+check_log_list([]) ->
+    ok;
+check_log_list([<<>>]) ->
+    ok;
+check_log_list([Head | Tail]) ->
+    case binary:match(Head, <<$@>>) of
+         nomatch -> throw(error);
+         {_, _} -> ok
+    end,
+    % this check for Head to be valid jid
+    case catch jid:decode(Head) of
+         {'EXIT', _Reason} -> throw(error);
+         _ -> check_log_list(Tail)
+    end.
+
+check_ignore_list([]) ->
+    ok;
+check_ignore_list([<<>>]) ->
+    ok;
+check_ignore_list([<<>> | Tail]) ->
+    check_ignore_list(Tail);
+check_ignore_list([Head | Tail]) ->
+    case binary:match(Head, <<$@>>) of
+         {_, _} -> ok;
+         nomatch -> throw(error)
+    end,
+    Jid2Test = case Head of
+                    << $@, _Rest/binary >> ->  << "a", Head/binary >>;
+                    Jid -> Jid
+               end,
+    % this check for Head to be valid jid
+    case catch jid:decode(Jid2Test) of
+         {'EXIT', _Reason} -> throw(error);
+         _ -> check_ignore_list(Tail)
+    end.
+
+get_value(Field, XData) -> hd(get_values(Field, XData)).
+
+get_values(Field, XData) ->
+    xmpp_util:get_xdata_values(Field, XData).
+
+parse_users_settings(XData) ->
+    DLD = case get_value(<<"dolog_default">>, XData) of
+               ValueDLD when ValueDLD == <<"true">>;
+                             ValueDLD == <<"false">> ->
+                  list_to_bool(ValueDLD);
+              _ -> throw(bad_request)
+          end,
+
+    ListDLL = get_values(<<"dolog_list">>, XData),
+    DLL = case catch check_log_list(ListDLL) of
+                  ok -> ListDLL;
+                  error -> throw(bad_request)
+             end,
+
+    ListDNLL = get_values(<<"donotlog_list">>, XData),
+    DNLL = case catch check_log_list(ListDNLL) of
+                  ok -> ListDNLL;
+                  error -> throw(bad_request)
+             end,
+
+    #user_settings{dolog_default=DLD,
+                   dolog_list=DLL,
+                   donotlog_list=DNLL}.
+
+parse_module_settings(XData) ->
+    DLD = case get_value(<<"dolog_default">>, XData) of
+               ValueDLD when ValueDLD == <<"true">>;
+                             ValueDLD == <<"false">> ->
+                   list_to_bool(ValueDLD);
+               _ -> throw(bad_request)
+          end,
+    MRemoval = case get_value(<<"drop_messages_on_user_removal">>, XData) of
+                    ValueMRemoval when ValueMRemoval == <<"true">>;
+                                       ValueMRemoval == <<"false">> ->
+                        list_to_bool(ValueMRemoval);
+                    _ -> throw(bad_request)
+               end,
+    GroupChat = case get_value(<<"groupchat">>, XData) of
+                     ValueGroupChat when ValueGroupChat == <<"none">>;
+                                         ValueGroupChat == <<"all">>;
+                                         ValueGroupChat == <<"send">> ->
+                         misc:binary_to_atom(ValueGroupChat);
+                     _ -> throw(bad_request)
+                end,
+    ListIgnore = get_values(<<"ignore_list">>, XData),
+    Ignore = case catch check_ignore_list(ListIgnore) of
+                  ok -> ListIgnore;
+                  error -> throw(bad_request)
+             end,
+    Purge = case get_value(<<"purge_older_days">>, XData) of
+                 <<"never">> -> never;
+                 ValuePurge ->
+                    case catch binary_to_integer(ValuePurge) of
+                         IntValuePurge when is_integer(IntValuePurge) -> IntValuePurge;
+                         _ -> throw(bad_request)
+                    end
+            end,
+    Poll = case catch binary_to_integer(get_value(<<"poll_users_settings">>, XData)) of
+                IntValuePoll when is_integer(IntValuePoll) -> IntValuePoll;
+                _ -> throw(bad_request)
+           end,
+    #state{dolog_default=DLD,
+           groupchat=GroupChat,
+           ignore_jids=Ignore,
+           purge_older_days=Purge,
+           drop_messages_on_user_removal=MRemoval,
+           poll_users_settings=Poll}.
+
+set_form(_From, _Host, [<<"mod_logdb_users">>, User], Lang, XData) ->
+    #jid{luser=LUser, lserver=LServer} = jid:decode(User),
+    Txt = "Parse user settings failed",
+    case catch parse_users_settings(XData) of
+         bad_request ->
+            ?ERROR_MSG("Failed to set user form: bad_request", []),
+            {error, xmpp:err_bad_request(Txt, Lang)};
+         {'EXIT', Reason} ->
+            ?ERROR_MSG("Failed to set user form ~p", [Reason]),
+            {error, xmpp:err_bad_request(Txt, Lang)};
+         UserSettings ->
+            case mod_logdb:set_user_settings(LUser, LServer, UserSettings) of
+                 ok ->
+                    {result, undefined};
+                 error ->
+                    {error, xmpp:err_internal_server_error()}
+            end
+    end;
+set_form(_From, Host, [<<"mod_logdb_settings">>], Lang, XData) ->
+    Txt = "Parse module settings failed",
+    case catch parse_module_settings(XData) of
+         bad_request ->
+            ?ERROR_MSG("Failed to set settings form: bad_request", []),
+            {error, xmpp:err_bad_request(Txt, Lang)};
+         {'EXIT', Reason} ->
+            ?ERROR_MSG("Failed to set settings form ~p", [Reason]),
+            {error, xmpp:err_bad_request(Txt, Lang)};
+         Settings ->
+            case mod_logdb:set_module_settings(Host, Settings) of
+                 ok ->
+                    {result, undefined};
+                 error ->
+                    {error, xmpp:err_internal_server_error()}
+            end
+    end;
+set_form(From, _Host, Node, _Lang, XData) ->
+    User = jid:encode(jid:remove_resource(From)),
+    ?MYDEBUG("set form for ~p at ~p XData=~p", [User, Node, XData]),
+    {error, xmpp:err_service_unavailable()}.
+
+get_all_vh_users(Host, Server) ->
+    case catch ejabberd_auth:get_vh_registered_users(Host) of
+        {'EXIT', _Reason} ->
+            [];
+        Users ->
+            SUsers = lists:sort([{S, U} || {U, S} <- Users]),
+            case length(SUsers) of
+                N when N =< 100 ->
+                    lists:map(fun({S, U}) ->
+                                  #disco_item{jid = jid:make(Server),
+                                              node = <<"mod_logdb_users/", U/binary, $@, S/binary>>,
+                                              name = << U/binary, "@", S/binary >>}
+                              end, SUsers);
+                N ->
+                    NParts = trunc(math:sqrt(N * 6.17999999999999993783e-1)) + 1,
+                    M = trunc(N / NParts) + 1,
+                    lists:map(fun(K) ->
+                                      L = K + M - 1,
+                                      Node = <<"@",
+                                               (integer_to_binary(K))/binary,
+                                               "-",
+                                               (integer_to_binary(L))/binary
+                                             >>,
+                                      {FS, FU} = lists:nth(K, SUsers),
+                                      {LS, LU} =
+                                          if L < N -> lists:nth(L, SUsers);
+                                             true -> lists:last(SUsers)
+                                          end,
+                                      Name =
+                                          <<FU/binary, "@", FS/binary,
+                                           " -- ",
+                                           LU/binary, "@", LS/binary>>,
+                                      #disco_item{jid = jid:make(Host),
+                                                  node = <<"mod_logdb_users/", Node/binary>>,
+                                                  name = Name}
+                              end, lists:seq(1, N, M))
+            end
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% webadmin hooks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+webadmin_menu(Acc, _Host, Lang) ->
+    [{<<"messages">>, ?T(<<"Users Messages">>)} | Acc].
+
+webadmin_user(Acc, User, Server, Lang) ->
+    Sett = get_user_settings(User, Server),
+    Log =
+      case Sett#user_settings.dolog_default of
+           false ->
+              ?INPUTT(<<"submit">>, <<"dolog">>, <<"Log Messages">>);
+           true ->
+              ?INPUTT(<<"submit">>, <<"donotlog">>, <<"Do Not Log Messages">>);
+           _ -> []
+      end,
+    Acc ++ [?XE(<<"h3">>, [?ACT(<<"messages/">>, <<"Messages">>), ?C(<<" ">>), Log])].
+
+webadmin_page(_, Host,
+              #request{path = [<<"messages">>],
+                       q = Query,
+                       lang = Lang}) ->
+    Res = vhost_messages_stats(Host, Query, Lang),
+    {stop, Res};
+webadmin_page(_, Host,
+              #request{path = [<<"messages">>, Date],
+                       q = Query,
+                       lang = Lang}) ->
+    Res = vhost_messages_stats_at(Host, Query, Lang, Date),
+    {stop, Res};
+webadmin_page(_, Host,
+              #request{path = [<<"user">>, U, <<"messages">>],
+                       q = Query,
+                       lang = Lang}) ->
+    Res = user_messages_stats(U, Host, Query, Lang),
+    {stop, Res};
+webadmin_page(_, Host,
+              #request{path = [<<"user">>, U, <<"messages">>, Date],
+                       q = Query,
+                       lang = Lang}) ->
+    Res = mod_logdb:user_messages_stats_at(U, Host, Query, Lang, Date),
+    {stop, Res};
+webadmin_page(Acc, _Host, _R) -> Acc.
+
+user_parse_query(_, <<"dolog">>, User, Server, _Query) ->
+    Sett = get_user_settings(User, Server),
+    % TODO: check returned value
+    set_user_settings(User, Server, Sett#user_settings{dolog_default=true}),
+    {stop, ok};
+user_parse_query(_, <<"donotlog">>, User, Server, _Query) ->
+    Sett = get_user_settings(User, Server),
+    % TODO: check returned value
+    set_user_settings(User, Server, Sett#user_settings{dolog_default=false}),
+    {stop, ok};
+user_parse_query(Acc, _Action, _User, _Server, _Query) ->
+    Acc.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% webadmin funcs
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+vhost_messages_stats(Server, Query, Lang) ->
+    Res = case catch vhost_messages_parse_query(Server, Query) of
+                     {'EXIT', Reason} ->
+                         ?ERROR_MSG("~p", [Reason]),
+                         error;
+                     VResult -> VResult
+          end,
+    {Time, Value} = timer:tc(mod_logdb, get_vhost_stats, [Server]),
+    ?INFO_MSG("get_vhost_stats(~p) elapsed ~p sec", [Server, Time/1000000]),
+    %case get_vhost_stats(Server) of
+    case Value of
+         {'EXIT', CReason} ->
+              ?ERROR_MSG("Failed to get_vhost_stats: ~p", [CReason]),
+              [?XC(<<"h1">>, ?T(<<"Error occupied while fetching list">>))];
+         {error, GReason} ->
+              ?ERROR_MSG("Failed to get_vhost_stats: ~p", [GReason]),
+              [?XC(<<"h1">>, ?T(<<"Error occupied while fetching list">>))];
+         {ok, []} ->
+              [?XC(<<"h1">>, list_to_binary(io_lib:format(?T(<<"No logged messages for ~s">>), [Server])))];
+         {ok, Dates} ->
+              Fun = fun({Date, Count}) ->
+                         DateBin = iolist_to_binary(Date),
+                         ID = misc:encode_base64( << Server/binary, DateBin/binary >> ),
+                         ?XE(<<"tr">>,
+                          [?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
+                            [?INPUT(<<"checkbox">>, <<"selected">>, ID)]),
+                           ?XE(<<"td">>, [?AC(DateBin, DateBin)]),
+                           ?XC(<<"td">>, integer_to_binary(Count))
+                          ])
+                    end,
+
+              [?XC(<<"h1">>, list_to_binary(io_lib:format(?T(<<"Logged messages for ~s">>), [Server])))] ++
+               case Res of
+                    ok -> [?CT(<<"Submitted">>), ?P];
+                    error -> [?CT(<<"Bad format">>), ?P];
+                    nothing -> []
+               end ++
+               [?XAE(<<"form">>, [{<<"action">>, <<"">>}, {<<"method">>, <<"post">>}],
+                [?XE(<<"table">>,
+                 [?XE(<<"thead">>,
+                  [?XE(<<"tr">>,
+                   [?X(<<"td">>),
+                    ?XCT(<<"td">>, <<"Date">>),
+                    ?XCT(<<"td">>, <<"Count">>)
+                   ])]),
+                  ?XE(<<"tbody">>,
+                      lists:map(Fun, Dates)
+                     )]),
+                  ?BR,
+                  ?INPUTT(<<"submit">>, <<"delete">>, <<"Delete Selected">>)
+                ])]
+   end.
+
+vhost_messages_stats_at(Server, Query, Lang, Date) ->
+   {Time, Value} = timer:tc(mod_logdb, get_vhost_stats_at, [Server, Date]),
+   ?INFO_MSG("get_vhost_stats_at(~p,~p) elapsed ~p sec", [Server, Date, Time/1000000]),
+   %case get_vhost_stats_at(Server, Date) of
+   case Value of
+        {'EXIT', CReason} ->
+             ?ERROR_MSG("Failed to get_vhost_stats_at: ~p", [CReason]),
+             [?XC(<<"h1">>, ?T(<<"Error occupied while fetching list">>))];
+        {error, GReason} ->
+             ?ERROR_MSG("Failed to get_vhost_stats_at: ~p", [GReason]),
+             [?XC(<<"h1">>, ?T(<<"Error occupied while fetching list">>))];
+        {ok, []} ->
+             [?XC(<<"h1">>, list_to_binary(io_lib:format(?T(<<"No logged messages for ~s at ~s">>), [Server, Date])))];
+        {ok, Stats} ->
+             Res = case catch vhost_messages_at_parse_query(Server, Date, Stats, Query) of
+                        {'EXIT', Reason} ->
+                            ?ERROR_MSG("~p", [Reason]),
+                            error;
+                        VResult -> VResult
+                   end,
+             Fun = fun({User, Count}) ->
+                         UserBin = iolist_to_binary(User),
+                         ID = misc:encode_base64( << UserBin/binary, Server/binary >> ),
+                         ?XE(<<"tr">>,
+                          [?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
+                            [?INPUT(<<"checkbox">>, <<"selected">>, ID)]),
+                           ?XE(<<"td">>, [?AC(<< <<"../user/">>/binary, UserBin/binary, <<"/messages/">>/binary, Date/binary >>, UserBin)]),
+                           ?XC(<<"td">>, integer_to_binary(Count))
+                          ])
+                   end,
+             [?XC(<<"h1">>, list_to_binary(io_lib:format(?T(<<"Logged messages for ~s at ~s">>), [Server, Date])))] ++
+              case Res of
+                    ok -> [?CT(<<"Submitted">>), ?P];
+                    error -> [?CT(<<"Bad format">>), ?P];
+                    nothing -> []
+              end ++
+              [?XAE(<<"form">>, [{<<"action">>, <<"">>}, {<<"method">>, <<"post">>}],
+                [?XE(<<"table">>,
+                 [?XE(<<"thead">>,
+                  [?XE(<<"tr">>,
+                   [?X(<<"td">>),
+                    ?XCT(<<"td">>, <<"User">>),
+                    ?XCT(<<"td">>, <<"Count">>)
+                   ])]),
+                  ?XE(<<"tbody">>,
+                      lists:map(Fun, Stats)
+                     )]),
+                  ?BR,
+                  ?INPUTT(<<"submit">>, <<"delete">>, <<"Delete Selected">>)
+                ])]
+   end.
+
+user_messages_stats(User, Server, Query, Lang) ->
+    Jid = jid:encode({User, Server, ""}),
+
+    Res = case catch user_messages_parse_query(User, Server, Query) of
+               {'EXIT', Reason} ->
+                    ?ERROR_MSG("~p", [Reason]),
+                    error;
+               VResult -> VResult
+          end,
+
+   {Time, Value} = timer:tc(mod_logdb, get_user_stats, [User, Server]),
+   ?INFO_MSG("get_user_stats(~p,~p) elapsed ~p sec", [User, Server, Time/1000000]),
+
+   case Value of
+        {'EXIT', CReason} ->
+            ?ERROR_MSG("Failed to get_user_stats: ~p", [CReason]),
+            [?XC(<<"h1">>, ?T(<<"Error occupied while fetching days">>))];
+        {error, GReason} ->
+            ?ERROR_MSG("Failed to get_user_stats: ~p", [GReason]),
+            [?XC(<<"h1">>, ?T(<<"Error occupied while fetching days">>))];
+        {ok, []} ->
+            [?XC(<<"h1">>, list_to_binary(io_lib:format(?T(<<"No logged messages for ~s">>), [Jid])))];
+        {ok, Dates} ->
+            Fun = fun({Date, Count}) ->
+                      DateBin = iolist_to_binary(Date),
+                      ID = misc:encode_base64( << User/binary, DateBin/binary >> ),
+                      ?XE(<<"tr">>,
+                       [?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
+                         [?INPUT(<<"checkbox">>, <<"selected">>, ID)]),
+                        ?XE(<<"td">>, [?AC(DateBin, DateBin)]),
+                        ?XC(<<"td">>, iolist_to_binary(integer_to_list(Count)))
+                       ])
+                  end,
+            [?XC(<<"h1">>, list_to_binary(io_lib:format(?T("Logged messages for ~s"), [Jid])))] ++
+             case Res of
+                   ok -> [?CT(<<"Submitted">>), ?P];
+                   error -> [?CT(<<"Bad format">>), ?P];
+                   nothing -> []
+             end ++
+             [?XAE(<<"form">>, [{<<"action">>, <<"">>}, {<<"method">>, <<"post">>}],
+              [?XE(<<"table">>,
+               [?XE(<<"thead">>,
+                [?XE(<<"tr">>,
+                 [?X(<<"td">>),
+                  ?XCT(<<"td">>, <<"Date">>),
+                  ?XCT(<<"td">>, <<"Count">>)
+                 ])]),
+                ?XE(<<"tbody">>,
+                    lists:map(Fun, Dates)
+                   )]),
+                ?BR,
+                ?INPUTT(<<"submit">>, <<"delete">>, <<"Delete Selected">>)
+              ])]
+    end.
+
+search_user_nick(User, List) ->
+    case lists:keysearch(User, 1, List) of
+         {value,{User, []}} ->
+           nothing;
+         {value,{User, Nick}} ->
+           Nick;
+         false ->
+           nothing
+    end.
+
+user_messages_stats_at(User, Server, Query, Lang, Date) ->
+   Jid = jid:encode({User, Server, ""}),
+
+   {Time, Value} = timer:tc(mod_logdb, get_user_messages_at, [User, Server, Date]),
+   ?INFO_MSG("get_user_messages_at(~p,~p,~p) elapsed ~p sec", [User, Server, Date, Time/1000000]),
+   case Value of
+        {'EXIT', CReason} ->
+           ?ERROR_MSG("Failed to get_user_messages_at: ~p", [CReason]),
+           [?XC(<<"h1">>, ?T(<<"Error occupied while fetching messages">>))];
+        {error, GReason} ->
+           ?ERROR_MSG("Failed to get_user_messages_at: ~p", [GReason]),
+           [?XC(<<"h1">>, ?T(<<"Error occupied while fetching messages">>))];
+        {ok, []} ->
+           [?XC(<<"h1">>, list_to_binary(io_lib:format(?T(<<"No logged messages for ~s at ~s">>), [Jid, Date])))];
+        {ok, User_messages} ->
+           Res =  case catch user_messages_at_parse_query(Server,
+                                                          Date,
+                                                          User_messages,
+                                                          Query) of
+                       {'EXIT', Reason} ->
+                            ?ERROR_MSG("~p", [Reason]),
+                            error;
+                       VResult -> VResult
+                  end,
+
+           UR = ejabberd_hooks:run_fold(roster_get, Server, [], [{User, Server}]),
+           UserRoster =
+                 lists:map(fun(Item) ->
+                              {jid:encode(Item#roster.jid), Item#roster.name}
+                          end, UR),
+
+           UniqUsers = lists:foldl(fun(#msg{peer_name=PName, peer_server=PServer}, List) ->
+                                 ToAdd = PName++"@"++PServer,
+                                 case lists:member(ToAdd, List) of
+                                      true -> List;
+                                      false -> lists:append([ToAdd], List)
+                                 end
+                               end, [], User_messages),
+
+           % Users to filter (sublist of UniqUsers)
+           CheckedUsers = case lists:keysearch(<<"filter">>, 1, Query) of
+                           {value, _} ->
+                              lists:filter(fun(UFUser) ->
+                                                ID = misc:encode_base64(term_to_binary(UFUser)),
+                                                lists:member({<<"selected">>, ID}, Query)
+                                           end, UniqUsers);
+                           false -> []
+                         end,
+
+           % UniqUsers in html (noone selected -> everyone selected)
+           Users = lists:map(fun(UHUser) ->
+                                ID = misc:encode_base64(term_to_binary(UHUser)),
+                                Input = case lists:member(UHUser, CheckedUsers) of
+                                         true -> [?INPUTC(<<"checkbox">>, <<"selected">>, ID)];
+                                         false when CheckedUsers == [] -> [?INPUTC(<<"checkbox">>, <<"selected">>, ID)];
+                                         false -> [?INPUT(<<"checkbox">>, <<"selected">>, ID)]
+                                        end,
+                                Nick =
+                                   case search_user_nick(UHUser, UserRoster) of
+                                        nothing -> <<"">>;
+                                        N -> iolist_to_binary( " ("++ N ++")" )
+                                   end,
+                                ?XE(<<"tr">>,
+                                 [?XE(<<"td">>, Input),
+                                  ?XC(<<"td">>, iolist_to_binary(UHUser++Nick))])
+                             end, lists:sort(UniqUsers)),
+           % Messages to show (based on Users)
+           User_messages_filtered = case CheckedUsers of
+                                         [] -> User_messages;
+                                         _  -> lists:filter(fun(#msg{peer_name=PName, peer_server=PServer}) ->
+                                                  lists:member(PName++"@"++PServer, CheckedUsers)
+                                               end, User_messages)
+                                    end,
+
+           Msgs_Fun = fun(#msg{timestamp=Timestamp,
+                               subject=Subject,
+                               direction=Direction,
+                               peer_name=PName, peer_server=PServer, peer_resource=PRes,
+                               type=Type,
+                               body=Body}) ->
+                      Text = case Subject of
+                                  "" -> iolist_to_binary(Body);
+                                  _ -> iolist_to_binary([binary_to_list(?T(<<"Subject">>)) ++ ": " ++ Subject ++ "\n" ++ Body])
+                             end,
+                      Resource = case PRes of
+                                      [] -> [];
+                                      undefined -> [];
+                                      R -> "/" ++ R
+                                 end,
+                      UserNick =
+                         case search_user_nick(PName++"@"++PServer, UserRoster) of
+                              nothing when PServer == Server ->
+                                   PName;
+                              nothing when Type == "groupchat", Direction == from ->
+                                   PName++"@"++PServer++Resource;
+                              nothing ->
+                                   PName++"@"++PServer;
+                              N -> N
+                         end,
+                      ID = misc:encode_base64(term_to_binary(Timestamp)),
+                      ?XE(<<"tr">>,
+                       [?XE(<<"td">>, [?INPUT(<<"checkbox">>, <<"selected">>, ID)]),
+                        ?XC(<<"td">>, iolist_to_binary(convert_timestamp(Timestamp))),
+                        ?XC(<<"td">>, iolist_to_binary(atom_to_list(Direction)++": "++UserNick)),
+                        ?XE(<<"td">>, [?XC(<<"pre">>, Text)])])
+                 end,
+           % Filtered user messages in html
+           Msgs = lists:map(Msgs_Fun, lists:sort(User_messages_filtered)),
+
+           [?XC(<<"h1">>, list_to_binary(io_lib:format(?T(<<"Logged messages for ~s at ~s">>), [Jid, Date])))] ++
+            case Res of
+                 ok -> [?CT(<<"Submitted">>), ?P];
+                 error -> [?CT(<<"Bad format">>), ?P];
+                 nothing -> []
+            end ++
+            [?XAE(<<"form">>, [{<<"action">>, <<"">>}, {<<"method">>, <<"post">>}],
+             [?XE(<<"table">>,
+                  [?XE(<<"thead">>,
+                       [?X(<<"td">>),
+                        ?XCT(<<"td">>, <<"User">>)
+                       ]
+                      ),
+                   ?XE(<<"tbody">>,
+                        Users
+                      )]),
+              ?INPUTT(<<"submit">>, <<"filter">>, <<"Filter Selected">>)
+             ] ++
+             [?XE(<<"table">>,
+                  [?XE(<<"thead">>,
+                       [?XE(<<"tr">>,
+                        [?X(<<"td">>),
+                         ?XCT(<<"td">>, <<"Date, Time">>),
+                         ?XCT(<<"td">>, <<"Direction: Jid">>),
+                         ?XCT(<<"td">>, <<"Body">>)
+                        ])]),
+                   ?XE(<<"tbody">>,
+                        Msgs
+                      )]),
+              ?INPUTT(<<"submit">>, <<"delete">>, <<"Delete Selected">>),
+              ?BR
+             ]
+            )]
+    end.
diff --git a/src/mod_logdb.hrl b/src/mod_logdb.hrl
new file mode 100644
index 0000000000..49791f4e69
--- /dev/null
+++ b/src/mod_logdb.hrl
@@ -0,0 +1,33 @@
+%%%----------------------------------------------------------------------
+%%% File    : mod_logdb.hrl
+%%% Author  : Oleg Palij (mailto:o.palij@gmail.com)
+%%% Purpose :
+%%% Url     : https://paleg.github.io/mod_logdb/
+%%%----------------------------------------------------------------------
+
+-define(logdb_debug, true).
+
+-ifdef(logdb_debug).
+-define(MYDEBUG(Format, Args), io:format("D(~p:~p:~p) : "++Format++"~n",
+                                       [calendar:local_time(),?MODULE,?LINE]++Args)).
+-else.
+-define(MYDEBUG(_F,_A),[]).
+-endif.
+
+-record(msg,   {timestamp,
+                owner_name,
+                peer_name, peer_server, peer_resource,
+                direction,
+                type, subject,
+                body}).
+
+-record(user_settings, {owner_name,
+                        dolog_default,
+                        dolog_list=[],
+                        donotlog_list=[]}).
+
+-define(INPUTC(Type, Name, Value),
+        ?XA(<<"input">>, [{<<"type">>,    Type},
+                          {<<"name">>,    Name},
+                          {<<"value">>,   Value},
+                          {<<"checked">>, <<"true">>}])).
diff --git a/src/mod_logdb_mnesia.erl b/src/mod_logdb_mnesia.erl
new file mode 100644
index 0000000000..ea167d889d
--- /dev/null
+++ b/src/mod_logdb_mnesia.erl
@@ -0,0 +1,555 @@
+%%%----------------------------------------------------------------------
+%%% File    : mod_logdb_mnesia.erl
+%%% Author  : Oleg Palij (mailto:o.palij@gmail.com)
+%%% Purpose : mnesia backend for mod_logdb
+%%% Url     : https://paleg.github.io/mod_logdb/
+%%%----------------------------------------------------------------------
+
+-module(mod_logdb_mnesia).
+-author('o.palij@gmail.com').
+
+-include("mod_logdb.hrl").
+-include("ejabberd.hrl").
+-include("jlib.hrl").
+-include("logger.hrl").
+
+-behaviour(gen_logdb).
+-behaviour(gen_server).
+
+% gen_server
+-export([code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2]).
+% gen_mod
+-export([start/2, stop/1]).
+% gen_logdb
+-export([log_message/2,
+         rebuild_stats/1,
+         rebuild_stats_at/2,
+         delete_messages_by_user_at/3, delete_all_messages_by_user_at/3, delete_messages_at/2,
+         get_vhost_stats/1, get_vhost_stats_at/2, get_user_stats/2, get_user_messages_at/3,
+         get_dates/1,
+         get_users_settings/1, get_user_settings/2, set_user_settings/3,
+         drop_user/2]).
+
+-define(PROCNAME, mod_logdb_mnesia).
+-define(CALL_TIMEOUT, 10000).
+
+-record(state, {vhost}).
+
+-record(stats, {user, at, count}).
+
+prefix() ->
+   "logdb_".
+
+suffix(VHost) ->
+   "_" ++ binary_to_list(VHost).
+
+stats_table(VHost) ->
+   list_to_atom(prefix() ++ "stats" ++ suffix(VHost)).
+
+table_name(VHost, Date) ->
+   list_to_atom(prefix() ++ "messages_" ++ Date ++ suffix(VHost)).
+
+settings_table(VHost) ->
+   list_to_atom(prefix() ++ "settings" ++ suffix(VHost)).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_mod callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+start(VHost, Opts) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:start({local, Proc}, ?MODULE, [VHost, Opts], []).
+
+stop(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {stop}, ?CALL_TIMEOUT).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_server callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+init([VHost, _Opts]) ->
+   case mnesia:system_info(is_running) of
+        yes ->
+          ok = create_stats_table(VHost),
+          ok = create_settings_table(VHost),
+          {ok, #state{vhost=VHost}};
+        no ->
+          ?ERROR_MSG("Mnesia not running", []),
+          {stop, db_connection_failed};
+        Status ->
+          ?ERROR_MSG("Mnesia status: ~p", [Status]),
+          {stop, db_connection_failed}
+   end.
+
+handle_call({log_message, Msg}, _From, #state{vhost=VHost}=State) ->
+    {reply, log_message_int(VHost, Msg), State};
+handle_call({rebuild_stats}, _From, #state{vhost=VHost}=State) ->
+    {atomic, ok} = delete_nonexistent_stats(VHost),
+    Reply =
+      lists:foreach(fun(Date) ->
+                        rebuild_stats_at_int(VHost, Date)
+                    end, get_dates_int(VHost)),
+    {reply, Reply, State};
+handle_call({rebuild_stats_at, Date}, _From, #state{vhost=VHost}=State) ->
+    Reply = rebuild_stats_at_int(VHost, Date),
+    {reply, Reply, State};
+handle_call({delete_messages_by_user_at, Msgs, Date}, _From, #state{vhost=VHost}=State) ->
+    Table = table_name(VHost, Date),
+    Fun = fun() ->
+             lists:foreach(
+                fun(Msg) ->
+                    mnesia:write_lock_table(stats_table(VHost)),
+                    mnesia:write_lock_table(Table),
+                    mnesia:delete_object(Table, Msg, write)
+               end, Msgs)
+          end,
+    DRez = case mnesia:transaction(Fun) of
+                {aborted, Reason} ->
+                   ?ERROR_MSG("Failed to delete_messages_by_user_at at ~p for ~p: ~p", [Date, VHost, Reason]),
+                   error;
+                _ ->
+                   ok
+           end,
+    Reply =
+      case rebuild_stats_at_int(VHost, Date) of
+           error ->
+             error;
+           ok ->
+             DRez
+      end,
+    {reply, Reply, State};
+handle_call({delete_all_messages_by_user_at, User, Date}, _From, #state{vhost=VHost}=State) ->
+    {reply, delete_all_messages_by_user_at_int(User, VHost, Date), State};
+handle_call({delete_messages_at, Date}, _From, #state{vhost=VHost}=State) ->
+    Reply =
+      case mnesia:delete_table(table_name(VHost, Date)) of
+           {atomic, ok} ->
+              delete_stats_by_vhost_at_int(VHost, Date);
+           {aborted, Reason} ->
+              ?ERROR_MSG("Failed to delete_messages_at for ~p at ~p", [VHost, Date, Reason]),
+              error
+      end,
+    {reply, Reply, State};
+handle_call({get_vhost_stats}, _From, #state{vhost=VHost}=State) ->
+    Fun = fun(#stats{at=Date, count=Count}, Stats) ->
+              case lists:keysearch(Date, 1, Stats) of
+                   false ->
+                      lists:append(Stats, [{Date, Count}]);
+                   {value, {_, TempCount}} ->
+                      lists:keyreplace(Date, 1, Stats, {Date, TempCount+Count})
+              end
+          end,
+    Reply =
+      case mnesia:transaction(fun() ->
+                                   mnesia:foldl(Fun, [], stats_table(VHost))
+                                end) of
+             {atomic, Result} -> {ok, mod_logdb:sort_stats(Result)};
+             {aborted, Reason} -> {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_vhost_stats_at, Date}, _From, #state{vhost=VHost}=State) ->
+    Fun = fun() ->
+             Pat = #stats{user='$1', at=Date, count='$2'},
+             mnesia:select(stats_table(VHost), [{Pat, [], [['$1', '$2']]}])
+          end,
+    Reply =
+      case mnesia:transaction(Fun) of
+           {atomic, Result} ->
+                     {ok, lists:reverse(lists:keysort(2, [{User, Count} || [User, Count] <- Result]))};
+           {aborted, Reason} ->
+                     {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_user_stats, User}, _From, #state{vhost=VHost}=State) ->
+    {reply, get_user_stats_int(User, VHost), State};
+handle_call({get_user_messages_at, User, Date}, _From, #state{vhost=VHost}=State) ->
+    Reply =
+      case mnesia:transaction(fun() ->
+                                Pat = #msg{owner_name=User, _='_'},
+                                mnesia:select(table_name(VHost, Date),
+                                              [{Pat, [], ['$_']}])
+                        end) of
+           {atomic, Result} -> {ok, Result};
+           {aborted, Reason} ->
+                    {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_dates}, _From, #state{vhost=VHost}=State) ->
+    {reply, get_dates_int(VHost), State};
+handle_call({get_users_settings}, _From, #state{vhost=VHost}=State) ->
+    Reply = mnesia:dirty_match_object(settings_table(VHost), #user_settings{_='_'}),
+    {reply, {ok, Reply}, State};
+handle_call({get_user_settings, User}, _From, #state{vhost=VHost}=State) ->
+   Reply =
+    case mnesia:dirty_match_object(settings_table(VHost), #user_settings{owner_name=User, _='_'}) of
+         [] -> [];
+         [Setting] ->
+            Setting
+    end,
+   {reply, Reply, State};
+handle_call({set_user_settings, _User, Set}, _From, #state{vhost=VHost}=State) ->
+    ?MYDEBUG("~p~n~p", [settings_table(VHost), Set]),
+    Reply = mnesia:dirty_write(settings_table(VHost), Set),
+    ?MYDEBUG("~p", [Reply]),
+    {reply, Reply, State};
+handle_call({drop_user, User}, _From, #state{vhost=VHost}=State) ->
+    {ok, Dates} = get_user_stats_int(User, VHost),
+    MDResult = lists:map(fun({Date, _}) ->
+                   delete_all_messages_by_user_at_int(User, VHost, Date)
+               end, Dates),
+    SDResult = delete_user_settings_int(User, VHost),
+    Reply =
+      case lists:all(fun(Result) when Result == ok ->
+                          true;
+                        (Result) when Result == error ->
+                          false
+                     end, lists:append(MDResult, [SDResult])) of
+           true ->
+             ok;
+           false ->
+             error
+      end,
+    {reply, Reply, State};
+handle_call({stop}, _From, State) ->
+   {stop, normal, ok, State};
+handle_call(Msg, _From, State) ->
+    ?INFO_MSG("Got call Msg: ~p, State: ~p", [Msg, State]),
+    {noreply, State}.
+
+handle_cast(Msg, State) ->
+    ?INFO_MSG("Got cast Msg:~p, State:~p", [Msg, State]),
+    {noreply, State}.
+
+handle_info(Info, State) ->
+    ?INFO_MSG("Got Info:~p, State:~p", [Info, State]),
+    {noreply, State}.
+
+terminate(_Reason, _State) ->
+    ok.
+
+code_change(_OldVsn, State, _Extra) ->
+    {ok, State}.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_logdb callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+log_message(VHost, Msg) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {log_message, Msg}, ?CALL_TIMEOUT).
+rebuild_stats(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {rebuild_stats}, ?CALL_TIMEOUT).
+rebuild_stats_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {rebuild_stats_at, Date}, ?CALL_TIMEOUT).
+delete_messages_by_user_at(VHost, Msgs, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_messages_by_user_at, Msgs, Date}, ?CALL_TIMEOUT).
+delete_all_messages_by_user_at(User, VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_all_messages_by_user_at, User, Date}, ?CALL_TIMEOUT).
+delete_messages_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_messages_at, Date}, ?CALL_TIMEOUT).
+get_vhost_stats(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_vhost_stats}, ?CALL_TIMEOUT).
+get_vhost_stats_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_vhost_stats_at, Date}, ?CALL_TIMEOUT).
+get_user_stats(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_stats, User}, ?CALL_TIMEOUT).
+get_user_messages_at(User, VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_messages_at, User, Date}, ?CALL_TIMEOUT).
+get_dates(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_dates}, ?CALL_TIMEOUT).
+get_user_settings(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_settings, User}, ?CALL_TIMEOUT).
+get_users_settings(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_users_settings}, ?CALL_TIMEOUT).
+set_user_settings(User, VHost, Set) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {set_user_settings, User, Set}, ?CALL_TIMEOUT).
+drop_user(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {drop_user, User}, ?CALL_TIMEOUT).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+log_message_int(VHost, #msg{timestamp=Timestamp}=MsgBin) ->
+    Date = mod_logdb:convert_timestamp_brief(Timestamp),
+
+    Msg = #msg{timestamp     = MsgBin#msg.timestamp,
+               owner_name    = binary_to_list(MsgBin#msg.owner_name),
+               peer_name     = binary_to_list(MsgBin#msg.peer_name),
+               peer_server   = binary_to_list(MsgBin#msg.peer_server),
+               peer_resource = binary_to_list(MsgBin#msg.peer_resource),
+               direction     = MsgBin#msg.direction,
+               type          = binary_to_list(MsgBin#msg.type),
+               subject       = binary_to_list(MsgBin#msg.subject),
+               body          = binary_to_list(MsgBin#msg.body)},
+
+    ATable = table_name(VHost, Date),
+    Fun = fun() ->
+              mnesia:write_lock_table(ATable),
+              mnesia:write(ATable, Msg, write)
+          end,
+    % log message, increment stats for both users
+    case mnesia:transaction(Fun) of
+         % if table does not exists - create it and try to log message again
+         {aborted,{no_exists, _Table}} ->
+             case create_msg_table(VHost, Date) of
+                  {aborted, CReason} ->
+                     ?ERROR_MSG("Failed to log message: ~p", [CReason]),
+                     error;
+                  {atomic, ok} ->
+                     ?MYDEBUG("Created msg table for ~s at ~s", [VHost, Date]),
+                     log_message_int(VHost, MsgBin)
+             end;
+         {aborted, TReason} ->
+             ?ERROR_MSG("Failed to log message: ~p", [TReason]),
+             error;
+         {atomic, _} ->
+             ?MYDEBUG("Logged ok for ~s, peer: ~s", [ [Msg#msg.owner_name, <<"@">>, VHost],
+                                                      [Msg#msg.peer_name, <<"@">>, Msg#msg.peer_server] ]),
+             increment_user_stats(Msg#msg.owner_name, VHost, Date)
+    end.
+
+increment_user_stats(Owner, VHost, Date) ->
+    Fun = fun() ->
+            Pat = #stats{user=Owner, at=Date, count='$1'},
+            mnesia:write_lock_table(stats_table(VHost)),
+            case mnesia:select(stats_table(VHost), [{Pat, [], ['$_']}]) of
+                 [] ->
+                    mnesia:write(stats_table(VHost),
+                                 #stats{user=Owner,
+                                        at=Date,
+                                        count=1},
+                                 write);
+                 [Stats] ->
+                    mnesia:delete_object(stats_table(VHost),
+                                         #stats{user=Owner,
+                                                at=Date,
+                                                count=Stats#stats.count},
+                                         write),
+                    New = Stats#stats{count = Stats#stats.count+1},
+                    if
+                      New#stats.count > 0 -> mnesia:write(stats_table(VHost),
+                                                          New,
+                                                          write);
+                      true -> ok
+                    end
+            end
+          end,
+    case mnesia:transaction(Fun) of
+         {aborted, Reason} ->
+             ?ERROR_MSG("Failed to update stats for ~s@~s: ~p", [Owner, VHost, Reason]),
+             error;
+         {atomic, _} ->
+             ?MYDEBUG("Updated stats for ~s@~s", [Owner, VHost]),
+             ok
+    end.
+
+get_dates_int(VHost) ->
+    Tables = mnesia:system_info(tables),
+    lists:foldl(fun(ATable, Dates) ->
+                    Table = term_to_binary(ATable),
+                    case ejabberd_regexp:run( Table, << VHost/binary, <<"$">>/binary >> ) of
+                         match ->
+                            case re:run(Table, "[0-9]+-[0-9]+-[0-9]+") of
+                                 {match, [{S, E}]} ->
+                                     lists:append(Dates, [lists:sublist(binary_to_list(Table), S+1, E)]);
+                                 nomatch ->
+                                     Dates
+                            end;
+                         nomatch ->
+                            Dates
+                    end
+                end, [], Tables).
+
+rebuild_stats_at_int(VHost, Date) ->
+    Table = table_name(VHost, Date),
+    STable = stats_table(VHost),
+    CFun = fun(Msg, Stats) ->
+               Owner = Msg#msg.owner_name,
+               case lists:keysearch(Owner, 1, Stats) of
+                    {value, {_, Count}} ->
+                       lists:keyreplace(Owner, 1, Stats, {Owner, Count + 1});
+                    false ->
+                       lists:append(Stats, [{Owner, 1}])
+               end
+           end,
+    DFun = fun(#stats{at=SDate} = Stat, _Acc)
+                when SDate == Date ->
+                 mnesia:delete_object(stats_table(VHost), Stat, write);
+              (_Stat, _Acc) -> ok
+           end,
+    % TODO: Maybe unregister hooks ?
+    case mnesia:transaction(fun() ->
+                               mnesia:write_lock_table(Table),
+                               mnesia:write_lock_table(STable),
+                               % Delete all stats for VHost at Date
+                               mnesia:foldl(DFun, [], STable),
+                               % Calc stats for VHost at Date
+                               case mnesia:foldl(CFun, [], Table) of
+                                    [] -> empty;
+                                    AStats ->
+                                      % Write new calc'ed stats
+                                      lists:foreach(fun({Owner, Count}) ->
+                                                        WStat = #stats{user=Owner, at=Date, count=Count},
+                                                        mnesia:write(stats_table(VHost), WStat, write)
+                                                    end, AStats),
+                                      ok
+                               end
+                            end) of
+         {aborted, Reason} ->
+              ?ERROR_MSG("Failed to rebuild_stats_at for ~p at ~p: ~p", [VHost, Date, Reason]),
+              error;
+         {atomic, ok} ->
+              ok;
+         {atomic, empty} ->
+              {atomic,ok} = mnesia:delete_table(Table),
+              ?MYDEBUG("Dropped table at ~p", [Date]),
+              ok
+    end.
+
+delete_nonexistent_stats(VHost) ->
+    Dates = get_dates_int(VHost),
+    mnesia:transaction(fun() ->
+                          mnesia:foldl(fun(#stats{at=Date} = Stat, _Acc) ->
+                                          case lists:member(Date, Dates) of
+                                               false -> mnesia:delete_object(Stat);
+                                               true -> ok
+                                          end
+                                       end, ok, stats_table(VHost))
+                       end).
+
+delete_stats_by_vhost_at_int(VHost, Date) ->
+    StatsDelete = fun(#stats{at=SDate} = Stat, _Acc)
+                      when SDate == Date ->
+                        mnesia:delete_object(stats_table(VHost), Stat, write),
+                        ok;
+                     (_Msg, _Acc) -> ok
+                  end,
+    case mnesia:transaction(fun() ->
+                             mnesia:write_lock_table(stats_table(VHost)),
+                             mnesia:foldl(StatsDelete, ok, stats_table(VHost))
+                       end) of
+         {aborted, Reason} ->
+            ?ERROR_MSG("Failed to update stats at ~p for ~p: ~p", [Date, VHost, Reason]),
+            rebuild_stats_at_int(VHost, Date);
+         _ ->
+            ?INFO_MSG("Updated stats at ~p for ~p", [Date, VHost]),
+            ok
+    end.
+
+get_user_stats_int(User, VHost) ->
+    case mnesia:transaction(fun() ->
+                               Pat = #stats{user=User, at='$1', count='$2'},
+                               mnesia:select(stats_table(VHost), [{Pat, [], [['$1', '$2']]}])
+                            end) of
+         {atomic, Result} ->
+                  {ok, mod_logdb:sort_stats([{Date, Count} || [Date, Count] <- Result])};
+         {aborted, Reason} ->
+                  {error, Reason}
+    end.
+
+delete_all_messages_by_user_at_int(User, VHost, Date) ->
+    Table = table_name(VHost, Date),
+    MsgDelete = fun(#msg{owner_name=Owner} = Msg, _Acc)
+                     when Owner == User ->
+                       mnesia:delete_object(Table, Msg, write),
+                       ok;
+                   (_Msg, _Acc) -> ok
+                end,
+    DRez = case mnesia:transaction(fun() ->
+                                     mnesia:foldl(MsgDelete, ok, Table)
+                                   end) of
+                {aborted, Reason} ->
+                   ?ERROR_MSG("Failed to delete_all_messages_by_user_at for ~p@~p at ~p: ~p", [User, VHost, Date, Reason]),
+                   error;
+                _ ->
+                   ok
+    end,
+    case rebuild_stats_at_int(VHost, Date) of
+         error ->
+           error;
+         ok ->
+           DRez
+    end.
+
+delete_user_settings_int(User, VHost) ->
+    STable = settings_table(VHost),
+    case mnesia:dirty_match_object(STable, #user_settings{owner_name=User, _='_'}) of
+         [] ->
+            ok;
+         [UserSettings] ->
+            mnesia:dirty_delete_object(STable, UserSettings)
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% tables internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+create_stats_table(VHost) ->
+    SName = stats_table(VHost),
+    case mnesia:create_table(SName,
+                             [{disc_only_copies, [node()]},
+                              {type, bag},
+                              {attributes, record_info(fields, stats)},
+                              {record_name, stats}
+                             ]) of
+         {atomic, ok} ->
+             ?MYDEBUG("Created stats table for ~p", [VHost]),
+             lists:foreach(fun(Date) ->
+                    rebuild_stats_at_int(VHost, Date)
+             end, get_dates_int(VHost)),
+             ok;
+         {aborted, {already_exists, _}} ->
+             ?MYDEBUG("Stats table for ~p already exists", [VHost]),
+             ok;
+         {aborted, Reason} ->
+             ?ERROR_MSG("Failed to create stats table: ~p", [Reason]),
+             error
+    end.
+
+create_settings_table(VHost) ->
+    SName = settings_table(VHost),
+    case mnesia:create_table(SName,
+                             [{disc_copies, [node()]},
+                              {type, set},
+                              {attributes, record_info(fields, user_settings)},
+                              {record_name, user_settings}
+                             ]) of
+         {atomic, ok} ->
+             ?MYDEBUG("Created settings table for ~p", [VHost]),
+             ok;
+         {aborted, {already_exists, _}} ->
+             ?MYDEBUG("Settings table for ~p already exists", [VHost]),
+             ok;
+         {aborted, Reason} ->
+             ?ERROR_MSG("Failed to create settings table: ~p", [Reason]),
+             error
+    end.
+
+create_msg_table(VHost, Date) ->
+    mnesia:create_table(
+              table_name(VHost, Date),
+              [{disc_only_copies, [node()]},
+               {type, bag},
+               {attributes, record_info(fields, msg)},
+               {record_name, msg}]).
diff --git a/src/mod_logdb_mysql.erl b/src/mod_logdb_mysql.erl
new file mode 100644
index 0000000000..09036211ff
--- /dev/null
+++ b/src/mod_logdb_mysql.erl
@@ -0,0 +1,1052 @@
+%%%----------------------------------------------------------------------
+%%% File    : mod_logdb_mysql.erl
+%%% Author  : Oleg Palij (mailto:o.palij@gmail.com)
+%%% Purpose : MySQL backend for mod_logdb
+%%% Url     : https://paleg.github.io/mod_logdb/
+%%%----------------------------------------------------------------------
+
+-module(mod_logdb_mysql).
+-author('o.palij@gmail.com').
+
+-include("mod_logdb.hrl").
+-include("ejabberd.hrl").
+-include("jlib.hrl").
+-include("logger.hrl").
+
+-behaviour(gen_logdb).
+-behaviour(gen_server).
+
+% gen_server
+-export([code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2]).
+% gen_mod
+-export([start/2, stop/1]).
+% gen_logdb
+-export([log_message/2,
+         rebuild_stats/1,
+         rebuild_stats_at/2,
+         delete_messages_by_user_at/3, delete_all_messages_by_user_at/3, delete_messages_at/2,
+         get_vhost_stats/1, get_vhost_stats_at/2, get_user_stats/2, get_user_messages_at/3,
+         get_dates/1,
+         get_users_settings/1, get_user_settings/2, set_user_settings/3,
+         drop_user/2]).
+
+% gen_server call timeout
+-define(CALL_TIMEOUT, 30000).
+-define(MYSQL_TIMEOUT, 60000).
+-define(INDEX_SIZE, integer_to_list(170)).
+-define(PROCNAME, mod_logdb_mysql).
+
+-import(mod_logdb, [list_to_bool/1, bool_to_list/1,
+                    list_to_string/1, string_to_list/1,
+                    convert_timestamp_brief/1]).
+
+-record(state, {dbref, vhost, server, port, db, user, password}).
+
+% replace "." with "_"
+escape_vhost(VHost) -> lists:map(fun(46) -> 95;
+                                    (A) -> A
+                                 end, binary_to_list(VHost)).
+prefix() ->
+   "`logdb_".
+
+suffix(VHost) ->
+   "_" ++ escape_vhost(VHost) ++ "`".
+
+messages_table(VHost, Date) ->
+   prefix() ++ "messages_" ++ Date ++ suffix(VHost).
+
+stats_table(VHost) ->
+   prefix() ++ "stats" ++ suffix(VHost).
+
+temp_table(VHost) ->
+   prefix() ++ "temp" ++ suffix(VHost).
+
+settings_table(VHost) ->
+   prefix() ++ "settings" ++ suffix(VHost).
+
+users_table(VHost) ->
+   prefix() ++ "users" ++ suffix(VHost).
+servers_table(VHost) ->
+   prefix() ++ "servers" ++ suffix(VHost).
+resources_table(VHost) ->
+   prefix() ++ "resources" ++ suffix(VHost).
+
+ets_users_table(VHost) -> list_to_atom("logdb_users_" ++ binary_to_list(VHost)).
+ets_servers_table(VHost) -> list_to_atom("logdb_servers_" ++ binary_to_list(VHost)).
+ets_resources_table(VHost) -> list_to_atom("logdb_resources_" ++ binary_to_list(VHost)).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_mod callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+start(VHost, Opts) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:start({local, Proc}, ?MODULE, [VHost, Opts], []).
+
+stop(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {stop}, ?CALL_TIMEOUT).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_server callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+init([VHost, Opts]) ->
+   crypto:start(),
+
+   Server = gen_mod:get_opt(server, Opts, fun(A) -> A end, <<"localhost">>),
+   Port = gen_mod:get_opt(port, Opts, fun(A) -> A end, 3306),
+   DB = gen_mod:get_opt(db, Opts, fun(A) -> A end, <<"logdb">>),
+   User = gen_mod:get_opt(user, Opts, fun(A) -> A end, <<"root">>),
+   Password = gen_mod:get_opt(password, Opts, fun(A) -> A end, <<"">>),
+
+   St = #state{vhost=VHost,
+               server=Server, port=Port, db=DB,
+               user=User, password=Password},
+
+   case open_mysql_connection(St) of
+       {ok, DBRef} ->
+           State = St#state{dbref=DBRef},
+           ok = create_stats_table(State),
+           ok = create_settings_table(State),
+           ok = create_users_table(State),
+           % clear ets cache every ...
+           timer:send_interval(timer:hours(12), clear_ets_tables),
+           ok = create_servers_table(State),
+           ok = create_resources_table(State),
+           erlang:monitor(process, DBRef),
+           {ok, State};
+       {error, Reason} ->
+           ?ERROR_MSG("MySQL connection failed: ~p~n", [Reason]),
+           {stop, db_connection_failed}
+   end.
+
+open_mysql_connection(#state{server=Server, port=Port, db=DB,
+                             user=DBUser, password=Password} = _State) ->
+   LogFun = fun(debug, _Format, _Argument) ->
+                 %?MYDEBUG(Format, Argument);
+                 ok;
+               (error, Format, Argument) ->
+                 ?ERROR_MSG(Format, Argument);
+               (Level, Format, Argument) ->
+                 ?MYDEBUG("MySQL (~p)~n", [Level]),
+                 ?MYDEBUG(Format, Argument)
+            end,
+   ?INFO_MSG("Opening mysql connection ~s@~s:~p/~s", [DBUser, Server, Port, DB]),
+   p1_mysql_conn:start(binary_to_list(Server), Port,
+                       binary_to_list(DBUser), binary_to_list(Password),
+                       binary_to_list(DB), LogFun).
+
+close_mysql_connection(DBRef) ->
+   ?MYDEBUG("Closing ~p mysql connection", [DBRef]),
+   catch p1_mysql_conn:stop(DBRef).
+
+handle_call({log_message, Msg}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Date = convert_timestamp_brief(Msg#msg.timestamp),
+
+    Table = messages_table(VHost, Date),
+    Owner_id = get_user_id(DBRef, VHost, binary_to_list(Msg#msg.owner_name)),
+    Peer_name_id = get_user_id(DBRef, VHost, binary_to_list(Msg#msg.peer_name)),
+    Peer_server_id = get_server_id(DBRef, VHost, binary_to_list(Msg#msg.peer_server)),
+    Peer_resource_id = get_resource_id(DBRef, VHost, binary_to_list(Msg#msg.peer_resource)),
+
+    Query = ["INSERT INTO ",Table," ",
+               "(owner_id,",
+                "peer_name_id,",
+                "peer_server_id,",
+                "peer_resource_id,",
+                "direction,",
+                "type,",
+                "subject,",
+                "body,",
+                "timestamp) ",
+               "VALUES ",
+               "('", Owner_id, "',",
+                 "'", Peer_name_id, "',",
+                 "'", Peer_server_id, "',",
+                 "'", Peer_resource_id, "',",
+                 "'", atom_to_list(Msg#msg.direction), "',",
+                 "'", binary_to_list(Msg#msg.type), "',",
+                 "'", binary_to_list( ejabberd_sql:escape(Msg#msg.subject) ), "',",
+                 "'", binary_to_list( ejabberd_sql:escape(Msg#msg.body) ), "',",
+                 "'", Msg#msg.timestamp, "');"],
+
+    Reply =
+       case sql_query_internal_silent(DBRef, Query) of
+            {updated, _} ->
+               ?MYDEBUG("Logged ok for ~s, peer: ~s", [ [Msg#msg.owner_name, <<"@">>, VHost],
+                                                        [Msg#msg.peer_name, <<"@">>, Msg#msg.peer_server] ]),
+               increment_user_stats(DBRef, Msg#msg.owner_name, Owner_id, VHost, Peer_name_id, Peer_server_id, Date);
+            {error, Reason} ->
+               case ejabberd_regexp:run(iolist_to_binary(Reason), <<"#42S02">>) of
+                    % Table doesn't exist
+                    match ->
+                       case create_msg_table(DBRef, VHost, Date) of
+                            error ->
+                               error;
+                            ok ->
+                               {updated, _} = sql_query_internal(DBRef, Query),
+                               increment_user_stats(DBRef, binary_to_list(Msg#msg.owner_name), Owner_id, VHost, Peer_name_id, Peer_server_id, Date)
+                       end;
+                    _ ->
+                       ?ERROR_MSG("Failed to log message: ~p", [Reason]),
+                       error
+               end
+       end,
+    {reply, Reply, State};
+handle_call({rebuild_stats_at, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Reply = rebuild_stats_at_int(DBRef, VHost, Date),
+    {reply, Reply, State};
+handle_call({delete_messages_by_user_at, [], _Date}, _From, State) ->
+    {reply, error, State};
+handle_call({delete_messages_by_user_at, Msgs, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Temp = lists:flatmap(fun(#msg{timestamp=Timestamp} = _Msg) ->
+                             ["\"",Timestamp,"\"",","]
+                         end, Msgs),
+
+    Temp1 = lists:append([lists:sublist(Temp, length(Temp)-1), ");"]),
+
+    Query = ["DELETE FROM ",messages_table(VHost, Date)," ",
+                             "WHERE timestamp IN (", Temp1],
+
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {updated, Aff} ->
+              ?MYDEBUG("Aff=~p", [Aff]),
+              rebuild_stats_at_int(DBRef, VHost, Date);
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({delete_all_messages_by_user_at, User, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    ok = delete_all_messages_by_user_at_int(DBRef, User, VHost, Date),
+    ok = delete_stats_by_user_at_int(DBRef, User, VHost, Date),
+    {reply, ok, State};
+handle_call({delete_messages_at, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Reply =
+      case sql_query_internal(DBRef, ["DROP TABLE ",messages_table(VHost, Date),";"]) of
+           {updated, _} ->
+              Query = ["DELETE FROM ",stats_table(VHost)," "
+                          "WHERE at=\"",Date,"\";"],
+              case sql_query_internal(DBRef, Query) of
+                   {updated, _} ->
+                      ok;
+                   {error, _} ->
+                      error
+              end;
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({get_vhost_stats}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    SName = stats_table(VHost),
+    Query = ["SELECT at, sum(count) ",
+                "FROM ",SName," ",
+                "GROUP BY at ",
+                "ORDER BY DATE(at) DESC;"
+            ],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              {ok, [ {Date, list_to_integer(Count)} || [Date, Count] <- Result ]};
+           {error, Reason} ->
+              % TODO: Duplicate error message ?
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_vhost_stats_at, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    SName = stats_table(VHost),
+    Query = ["SELECT username, sum(count) AS allcount ",
+                "FROM ",SName," ",
+                "JOIN ",users_table(VHost)," ON owner_id=user_id "
+                "WHERE at=\"",Date,"\" "
+                "GROUP BY username ",
+                "ORDER BY allcount DESC;"
+            ],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              {ok, lists:reverse(
+                     lists:keysort(2,
+                                   [ {User, list_to_integer(Count)} || [User, Count] <- Result]))};
+           {error, Reason} ->
+              % TODO:
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_user_stats, User}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    {reply, get_user_stats_int(DBRef, User, VHost), State};
+handle_call({get_user_messages_at, User, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    TName = messages_table(VHost, Date),
+    UName = users_table(VHost),
+    SName = servers_table(VHost),
+    RName = resources_table(VHost),
+    Query = ["SELECT users.username,",
+                    "servers.server,",
+                    "resources.resource,",
+                    "messages.direction,"
+                    "messages.type,"
+                    "messages.subject,"
+                    "messages.body,"
+                    "messages.timestamp "
+               "FROM ",TName," AS messages "
+                "JOIN ",UName," AS users ON peer_name_id=user_id ",
+                "JOIN ",SName," AS servers ON peer_server_id=server_id ",
+                "JOIN ",RName," AS resources ON peer_resource_id=resource_id ",
+               "WHERE owner_id=\"",get_user_id(DBRef, VHost, User),"\" ",
+               "ORDER BY timestamp ASC;"],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              Fun = fun([Peer_name, Peer_server, Peer_resource,
+                         Direction,
+                         Type,
+                         Subject, Body,
+                         Timestamp]) ->
+                          #msg{peer_name=Peer_name, peer_server=Peer_server, peer_resource=Peer_resource,
+                               direction=list_to_atom(Direction),
+                               type=Type,
+                               subject=Subject, body=Body,
+                               timestamp=Timestamp}
+                    end,
+              {ok, lists:map(Fun, Result)};
+           {error, Reason} ->
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_dates}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    SName = stats_table(VHost),
+    Query = ["SELECT at ",
+                "FROM ",SName," ",
+                "GROUP BY at ",
+                "ORDER BY DATE(at) DESC;"
+            ],
+    Reply =
+       case sql_query_internal(DBRef, Query) of
+            {data, Result} ->
+               [ Date || [Date] <- Result ];
+            {error, Reason} ->
+               {error, Reason}
+       end,
+    {reply, Reply, State};
+handle_call({get_users_settings}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Query = ["SELECT username,dolog_default,dolog_list,donotlog_list ",
+                "FROM ",settings_table(VHost)," ",
+             "JOIN ",users_table(VHost)," ON user_id=owner_id;"],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              {ok, lists:map(fun([Owner, DoLogDef, DoLogL, DoNotLogL]) ->
+                                 #user_settings{owner_name=Owner,
+                                                dolog_default=list_to_bool(DoLogDef),
+                                                dolog_list=string_to_list(DoLogL),
+                                                donotlog_list=string_to_list(DoNotLogL)
+                                               }
+                             end, Result)};
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({get_user_settings, User}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Query = ["SELECT dolog_default,dolog_list,donotlog_list FROM ",settings_table(VHost)," ",
+                 "WHERE owner_id=\"",get_user_id(DBRef, VHost, User),"\";"],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, []} ->
+              {ok, []};
+           {data, [[Owner, DoLogDef, DoLogL, DoNotLogL]]} ->
+              {ok, #user_settings{owner_name=Owner,
+                                  dolog_default=list_to_bool(DoLogDef),
+                                  dolog_list=string_to_list(DoLogL),
+                                  donotlog_list=string_to_list(DoNotLogL)}};
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({set_user_settings, User, #user_settings{dolog_default=DoLogDef,
+                                                     dolog_list=DoLogL,
+                                                     donotlog_list=DoNotLogL}},
+            _From, #state{dbref=DBRef, vhost=VHost} = State) ->
+    User_id = get_user_id(DBRef, VHost, User),
+
+    Query = ["UPDATE ",settings_table(VHost)," ",
+                "SET dolog_default=",bool_to_list(DoLogDef),", ",
+                    "dolog_list='",list_to_string(DoLogL),"', ",
+                    "donotlog_list='",list_to_string(DoNotLogL),"' ",
+                "WHERE owner_id=\"",User_id,"\";"],
+
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {updated, 0} ->
+              IQuery = ["INSERT INTO ",settings_table(VHost)," ",
+                            "(owner_id, dolog_default, dolog_list, donotlog_list) ",
+                            "VALUES ",
+                            "('",User_id,"', ",bool_to_list(DoLogDef),",'",list_to_string(DoLogL),"','",list_to_string(DoNotLogL),"');"],
+              case sql_query_internal_silent(DBRef, IQuery) of
+                   {updated, _} ->
+                       ?MYDEBUG("New settings for ~s@~s", [User, VHost]),
+                       ok;
+                   {error, Reason} ->
+                       case ejabberd_regexp:run(iolist_to_binary(Reason), <<"#23000">>) of
+                            % Already exists
+                            match ->
+                                ok;
+                             _ ->
+                                ?ERROR_MSG("Failed setup user ~p@~p: ~p", [User, VHost, Reason]),
+                                error
+                       end
+              end;
+           {updated, 1} ->
+              ?MYDEBUG("Updated settings for ~s@~s", [User, VHost]),
+              ok;
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({stop}, _From, #state{vhost=VHost}=State) ->
+   ets:delete(ets_users_table(VHost)),
+   ets:delete(ets_servers_table(VHost)),
+   ?MYDEBUG("Stoping mysql backend for ~p", [VHost]),
+   {stop, normal, ok, State};
+handle_call(Msg, _From, State) ->
+    ?INFO_MSG("Got call Msg: ~p, State: ~p", [Msg, State]),
+    {noreply, State}.
+
+handle_cast({rebuild_stats}, State) ->
+    rebuild_all_stats_int(State),
+    {noreply, State};
+handle_cast({drop_user, User}, #state{vhost=VHost} = State) ->
+    Fun = fun() ->
+            {ok, DBRef} = open_mysql_connection(State),
+            {ok, Dates} = get_user_stats_int(DBRef, User, VHost),
+            MDResult = lists:map(fun({Date, _}) ->
+                           delete_all_messages_by_user_at_int(DBRef, User, VHost, Date)
+                       end, Dates),
+            StDResult = delete_all_stats_by_user_int(DBRef, User, VHost),
+            SDResult = delete_user_settings_int(DBRef, User, VHost),
+            case lists:all(fun(Result) when Result == ok ->
+                                true;
+                              (Result) when Result == error ->
+                               false
+                           end, lists:append([MDResult, [StDResult], [SDResult]])) of
+                 true ->
+                   ?INFO_MSG("Removed ~s@~s", [User, VHost]);
+                 false ->
+                   ?ERROR_MSG("Failed to remove ~s@~s", [User, VHost])
+            end,
+            close_mysql_connection(DBRef)
+          end,
+    spawn(Fun),
+    {noreply, State};
+handle_cast(Msg, State) ->
+    ?INFO_MSG("Got cast Msg:~p, State:~p", [Msg, State]),
+    {noreply, State}.
+
+handle_info(clear_ets_tables, State) ->
+    ets:delete_all_objects(ets_users_table(State#state.vhost)),
+    ets:delete_all_objects(ets_resources_table(State#state.vhost)),
+    {noreply, State};
+handle_info({'DOWN', _MonitorRef, process, _Pid, _Info}, State) ->
+    {stop, connection_dropped, State};
+handle_info(Info, State) ->
+    ?INFO_MSG("Got Info:~p, State:~p", [Info, State]),
+    {noreply, State}.
+
+terminate(_Reason, #state{dbref=DBRef}=_State) ->
+    close_mysql_connection(DBRef),
+    ok.
+
+code_change(_OldVsn, State, _Extra) ->
+    {ok, State}.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_logdb callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+log_message(VHost, Msg) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {log_message, Msg}, ?CALL_TIMEOUT).
+rebuild_stats(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:cast(Proc, {rebuild_stats}).
+rebuild_stats_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {rebuild_stats_at, Date}, ?CALL_TIMEOUT).
+delete_messages_by_user_at(VHost, Msgs, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_messages_by_user_at, Msgs, Date}, ?CALL_TIMEOUT).
+delete_all_messages_by_user_at(User, VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_all_messages_by_user_at, User, Date}, ?CALL_TIMEOUT).
+delete_messages_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_messages_at, Date}, ?CALL_TIMEOUT).
+get_vhost_stats(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_vhost_stats}, ?CALL_TIMEOUT).
+get_vhost_stats_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_vhost_stats_at, Date}, ?CALL_TIMEOUT).
+get_user_stats(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_stats, User}, ?CALL_TIMEOUT).
+get_user_messages_at(User, VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_messages_at, User, Date}, ?CALL_TIMEOUT).
+get_dates(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_dates}, ?CALL_TIMEOUT).
+get_users_settings(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_users_settings}, ?CALL_TIMEOUT).
+get_user_settings(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_settings, User}, ?CALL_TIMEOUT).
+set_user_settings(User, VHost, Set) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {set_user_settings, User, Set}, ?CALL_TIMEOUT).
+drop_user(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:cast(Proc, {drop_user, User}).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+increment_user_stats(DBRef, User_name, User_id, VHost, PNameID, PServerID, Date) ->
+    SName = stats_table(VHost),
+    UQuery = ["UPDATE ",SName," ",
+                  "SET count=count+1 ",
+                  "WHERE owner_id=\"",User_id,"\" AND peer_name_id=\"",PNameID,"\" AND peer_server_id=\"",PServerID,"\" AND at=\"",Date,"\";"],
+
+    case sql_query_internal(DBRef, UQuery) of
+         {updated, 0} ->
+               IQuery = ["INSERT INTO ",SName," ",
+                             "(owner_id, peer_name_id, peer_server_id, at, count) ",
+                             "VALUES ",
+                             "('",User_id,"', '",PNameID,"', '",PServerID,"', '",Date,"', '1');"],
+               case sql_query_internal(DBRef, IQuery) of
+                    {updated, _} ->
+                         ?MYDEBUG("New stats for ~s@~s at ~s", [User_name, VHost, Date]),
+                         ok;
+                    {error, _} ->
+                         error
+               end;
+         {updated, _} ->
+               ?MYDEBUG("Updated stats for ~s@~s at ~s", [User_name, VHost, Date]),
+               ok;
+         {error, _} ->
+               error
+    end.
+
+get_dates_int(DBRef, VHost) ->
+    case sql_query_internal(DBRef, ["SHOW TABLES"]) of
+         {data, Tables} ->
+            Reg = "^" ++ lists:sublist(prefix(),2,length(prefix())) ++ ".*" ++ escape_vhost(VHost),
+            lists:foldl(fun([Table], Dates) ->
+                           case re:run(Table, Reg) of
+                                {match, _} ->
+                                   case re:run(Table, "[0-9]+-[0-9]+-[0-9]+") of
+                                        {match, [{S, E}]} ->
+                                            lists:append(Dates, [lists:sublist(Table, S+1, E)]);
+                                        nomatch ->
+                                            Dates
+                                   end;
+                                _ ->
+                                   Dates
+                           end
+                        end, [], Tables);
+         {error, _} ->
+            []
+     end.
+
+rebuild_all_stats_int(#state{vhost=VHost}=State) ->
+    Fun = fun() ->
+             {ok, DBRef} = open_mysql_connection(State),
+             ok = delete_nonexistent_stats(DBRef, VHost),
+             case lists:filter(fun(Date) ->
+                                 case catch rebuild_stats_at_int(DBRef, VHost, Date) of
+                                      ok -> false;
+                                      error -> true;
+                                      {'EXIT', _} -> true
+                                 end
+                             end, get_dates_int(DBRef, VHost)) of
+                  [] -> ok;
+                  FTables ->
+                     ?ERROR_MSG("Failed to rebuild stats for ~p dates", [FTables]),
+                     error
+             end,
+             close_mysql_connection(DBRef)
+          end,
+    spawn(Fun).
+
+rebuild_stats_at_int(DBRef, VHost, Date) ->
+    TempTable =  temp_table(VHost),
+    Fun = fun() ->
+           Table = messages_table(VHost, Date),
+           STable = stats_table(VHost),
+
+           DQuery = [ "DELETE FROM ",STable," ",
+                          "WHERE at='",Date,"';"],
+
+           ok = create_temp_table(DBRef, TempTable),
+           {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",Table," WRITE, ",TempTable," WRITE;"]),
+           SQuery = ["INSERT INTO ",TempTable," ",
+                     "(owner_id,peer_name_id,peer_server_id,at,count) ",
+                         "SELECT owner_id,peer_name_id,peer_server_id,\"",Date,"\",count(*) ",
+                            "FROM ",Table," GROUP BY owner_id,peer_name_id,peer_server_id;"],
+           case sql_query_internal(DBRef, SQuery) of
+                  {updated, 0} ->
+                      Count = sql_query_internal(DBRef, ["SELECT count(*) FROM ",Table,";"]),
+                      case Count of
+                        {data, [["0"]]} ->
+                           {updated, _} = sql_query_internal(DBRef, ["DROP TABLE ",Table,";"]),
+                           {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",STable," WRITE;"]),
+                           {updated, _} = sql_query_internal(DBRef, DQuery),
+                           ok;
+                        _ ->
+                           ?ERROR_MSG("Failed to calculate stats for ~s table! Count was ~p.", [Date, Count]),
+                           error
+                      end;
+                  {updated, _} ->
+                      {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",STable," WRITE, ",TempTable," WRITE;"]),
+                      {updated, _} = sql_query_internal(DBRef, DQuery),
+                      SQuery1 = ["INSERT INTO ",STable," ",
+                                  "(owner_id,peer_name_id,peer_server_id,at,count) ",
+                                     "SELECT owner_id,peer_name_id,peer_server_id,at,count ",
+                                        "FROM ",TempTable,";"],
+                      case sql_query_internal(DBRef, SQuery1) of
+                           {updated, _} -> ok;
+                           {error, _} -> error
+                      end;
+                  {error, _} -> error
+           end
+       end,
+
+    case catch apply(Fun, []) of
+         ok ->
+           ?INFO_MSG("Rebuilded stats for ~p at ~p", [VHost, Date]),
+           ok;
+         error ->
+           error;
+         {'EXIT', Reason} ->
+           ?ERROR_MSG("Failed to rebuild stats for ~s table: ~p.", [Date, Reason]),
+           error
+    end,
+    sql_query_internal(DBRef, ["UNLOCK TABLES;"]),
+    sql_query_internal(DBRef, ["DROP TABLE ",TempTable,";"]),
+    ok.
+
+
+delete_nonexistent_stats(DBRef, VHost) ->
+    Dates = get_dates_int(DBRef, VHost),
+    STable = stats_table(VHost),
+
+    Temp = lists:flatmap(fun(Date) ->
+                             ["\"",Date,"\"",","]
+                         end, Dates),
+
+    case Temp of
+         [] ->
+           ok;
+         _ ->
+           % replace last "," with ");"
+           Temp1 = lists:append([lists:sublist(Temp, length(Temp)-1), ");"]),
+           Query = ["DELETE FROM ",STable," ",
+                       "WHERE at NOT IN (", Temp1],
+           case sql_query_internal(DBRef, Query) of
+                {updated, _} ->
+                    ok;
+                {error, _} ->
+                    error
+           end
+    end.
+
+get_user_stats_int(DBRef, User, VHost) ->
+    SName = stats_table(VHost),
+    Query = ["SELECT at, sum(count) as allcount ",
+                "FROM ",SName," ",
+                "WHERE owner_id=\"",get_user_id(DBRef, VHost, User),"\" ",
+                "GROUP BY at "
+                "ORDER BY DATE(at) DESC;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {data, Result} ->
+            {ok, [ {Date, list_to_integer(Count)} || [Date, Count] <- Result]};
+         {error, Result} ->
+            {error, Result}
+    end.
+
+delete_all_messages_by_user_at_int(DBRef, User, VHost, Date) ->
+    DQuery = ["DELETE FROM ",messages_table(VHost, Date)," ",
+                 "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost)," WHERE username=\"",User,"\");"],
+    case sql_query_internal(DBRef, DQuery) of
+         {updated, _} ->
+            ?INFO_MSG("Dropped messages for ~s@~s at ~s", [User, VHost, Date]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+delete_all_stats_by_user_int(DBRef, User, VHost) ->
+    SQuery = ["DELETE FROM ",stats_table(VHost)," ",
+                "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost)," WHERE username=\"",User,"\");"],
+    case sql_query_internal(DBRef, SQuery) of
+         {updated, _} ->
+             ?INFO_MSG("Dropped all stats for ~s@~s", [User, VHost]),
+             ok;
+         {error, _} -> error
+    end.
+
+delete_stats_by_user_at_int(DBRef, User, VHost, Date) ->
+    SQuery = ["DELETE FROM ",stats_table(VHost)," ",
+                "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost)," WHERE username=\"",User,"\") ",
+                  "AND at=\"",Date,"\";"],
+   case sql_query_internal(DBRef, SQuery) of
+         {updated, _} ->
+             ?INFO_MSG("Dropped stats for ~s@~s at ~s", [User, VHost, Date]),
+             ok;
+         {error, _} -> error
+    end.
+
+delete_user_settings_int(DBRef, User, VHost) ->
+    Query = ["DELETE FROM ",settings_table(VHost)," ",
+                 "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost)," WHERE username=\"",User,"\");"],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?INFO_MSG("Dropped ~s@~s settings", [User, VHost]),
+            ok;
+         {error, Reason} ->
+            ?ERROR_MSG("Failed to drop ~s@~s settings: ~p", [User, VHost, Reason]),
+            error
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% tables internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+create_temp_table(DBRef, Name) ->
+    Query = ["CREATE TABLE ",Name," (",
+                "owner_id MEDIUMINT UNSIGNED, ",
+                "peer_name_id MEDIUMINT UNSIGNED, ",
+                "peer_server_id MEDIUMINT UNSIGNED, ",
+                "at VARCHAR(11), ",
+                "count INT(11) ",
+             ") ENGINE=MyISAM CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} -> ok;
+         {error, _Reason} -> error
+    end.
+
+create_stats_table(#state{dbref=DBRef, vhost=VHost}=State) ->
+    SName = stats_table(VHost),
+    Query = ["CREATE TABLE ",SName," (",
+                "owner_id MEDIUMINT UNSIGNED, ",
+                "peer_name_id MEDIUMINT UNSIGNED, ",
+                "peer_server_id MEDIUMINT UNSIGNED, ",
+                "at varchar(20), ",
+                "count int(11), ",
+                "INDEX(owner_id, peer_name_id, peer_server_id), ",
+                "INDEX(at)"
+             ") ENGINE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal_silent(DBRef, Query) of
+         {updated, _} ->
+            ?INFO_MSG("Created stats table for ~p", [VHost]),
+            rebuild_all_stats_int(State),
+            ok;
+         {error, Reason} ->
+            case ejabberd_regexp:run(iolist_to_binary(Reason), <<"#42S01">>) of
+                 match ->
+                   ?MYDEBUG("Stats table for ~p already exists", [VHost]),
+                   CheckQuery = ["SHOW COLUMNS FROM ",SName," LIKE 'peer_%_id';"],
+                   case sql_query_internal(DBRef, CheckQuery) of
+                        {data, Elems} when length(Elems) == 2 ->
+                          ?MYDEBUG("Stats table structure is ok", []),
+                          ok;
+                        _ ->
+                          ?INFO_MSG("It seems like stats table structure is invalid. I will drop it and recreate", []),
+                          case sql_query_internal(DBRef, ["DROP TABLE ",SName,";"]) of
+                               {updated, _} ->
+                                  ?INFO_MSG("Successfully dropped ~p", [SName]);
+                               _ ->
+                                  ?ERROR_MSG("Failed to drop ~p. You should drop it and restart module", [SName])
+                          end,
+                          error
+                   end;
+                 _ ->
+                   ?ERROR_MSG("Failed to create stats table for ~p: ~p", [VHost, Reason]),
+                   error
+            end
+    end.
+
+create_settings_table(#state{dbref=DBRef, vhost=VHost}) ->
+    SName = settings_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",SName," (",
+                "owner_id MEDIUMINT UNSIGNED PRIMARY KEY, ",
+                "dolog_default TINYINT(1) NOT NULL DEFAULT 1, ",
+                "dolog_list TEXT, ",
+                "donotlog_list TEXT ",
+             ") ENGINE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created settings table for ~p", [VHost]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+create_users_table(#state{dbref=DBRef, vhost=VHost}) ->
+    SName = users_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",SName," (",
+                "username TEXT NOT NULL, ",
+                "user_id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE, ",
+                "UNIQUE INDEX(username(",?INDEX_SIZE,")) ",
+             ") ENGINE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created users table for ~p", [VHost]),
+            ets:new(ets_users_table(VHost), [named_table, set, public]),
+            %update_users_from_db(DBRef, VHost),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+create_servers_table(#state{dbref=DBRef, vhost=VHost}) ->
+    SName = servers_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",SName," (",
+                "server TEXT NOT NULL, ",
+                "server_id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE, ",
+                "UNIQUE INDEX(server(",?INDEX_SIZE,")) ",
+             ") ENGINE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created servers table for ~p", [VHost]),
+            ets:new(ets_servers_table(VHost), [named_table, set, public]),
+            update_servers_from_db(DBRef, VHost),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+create_resources_table(#state{dbref=DBRef, vhost=VHost}) ->
+    RName = resources_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",RName," (",
+                "resource TEXT NOT NULL, ",
+                "resource_id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE, ",
+                "UNIQUE INDEX(resource(",?INDEX_SIZE,")) ",
+             ") ENGINE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created resources table for ~p", [VHost]),
+            ets:new(ets_resources_table(VHost), [named_table, set, public]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+create_msg_table(DBRef, VHost, Date) ->
+    TName = messages_table(VHost, Date),
+    Query = ["CREATE TABLE ",TName," (",
+                "owner_id MEDIUMINT UNSIGNED, ",
+                "peer_name_id MEDIUMINT UNSIGNED, ",
+                "peer_server_id MEDIUMINT UNSIGNED, ",
+                "peer_resource_id MEDIUMINT(8) UNSIGNED, ",
+                "direction ENUM('to', 'from'), ",
+                "type ENUM('chat','error','groupchat','headline','normal') NOT NULL, ",
+                "subject TEXT, ",
+                "body TEXT, ",
+                "timestamp DOUBLE, ",
+                "INDEX search_i (owner_id, peer_name_id, peer_server_id, peer_resource_id), ",
+                "FULLTEXT (body) "
+             ") ENGINE=MyISAM CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _MySQLRes} ->
+            ?MYDEBUG("Created msg table for ~p at ~p", [VHost, Date]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% internal ets cache (users, servers, resources)
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+update_servers_from_db(DBRef, VHost) ->
+   ?INFO_MSG("Reading servers from db for ~p", [VHost]),
+   SQuery = ["SELECT server, server_id FROM ",servers_table(VHost),";"],
+   {data, Result} = sql_query_internal(DBRef, SQuery),
+   true = ets:delete_all_objects(ets_servers_table(VHost)),
+   true = ets:insert(ets_servers_table(VHost), [ {Server, Server_id} || [Server, Server_id] <- Result]).
+
+%update_users_from_db(DBRef, VHost) ->
+%   ?INFO_MSG("Reading users from db for ~p", [VHost]),
+%   SQuery = ["SELECT username, user_id FROM ",users_table(VHost),";"],
+%   {data, Result} = sql_query_internal(DBRef, SQuery),
+%   true = ets:delete_all_objects(ets_users_table(VHost)),
+%   true = ets:insert(ets_users_table(VHost), [ {Username, User_id} || [Username, User_id] <- Result]).
+
+%get_user_name(DBRef, VHost, User_id) ->
+%  case ets:match(ets_users_table(VHost), {'$1', User_id}) of
+%       [[User]] -> User;
+%       % this can be in clustered environment
+%       [] ->
+%         %update_users_from_db(DBRef, VHost),
+%         SQuery = ["SELECT username FROM ",users_table(VHost)," ",
+%                             "WHERE user_id=\"",User_id,"\";"],
+%         {data, [[Name]]} = sql_query_internal(DBRef, SQuery),
+%         % cache {user, id} pair
+%         ets:insert(ets_users_table(VHost), {Name, User_id}),
+%         Name
+%  end.
+
+%get_server_name(DBRef, VHost, Server_id) ->
+%  case ets:match(ets_servers_table(VHost), {'$1', Server_id}) of
+%       [[Server]] -> Server;
+       % this can be in clustered environment
+%       [] ->
+%         update_servers_from_db(DBRef, VHost),
+%         [[Server1]] = ets:match(ets_servers_table(VHost), {'$1', Server_id}),
+%         Server1
+%  end.
+
+get_user_id_from_db(DBRef, VHost, User) ->
+  SQuery = ["SELECT user_id FROM ",users_table(VHost)," ",
+               "WHERE username=\"",User,"\";"],
+  case sql_query_internal(DBRef, SQuery) of
+       % no such user in db
+       {data, []} ->
+          {ok, []};
+       {data, [[DBId]]} ->
+          % cache {user, id} pair
+          ets:insert(ets_users_table(VHost), {User, DBId}),
+          {ok, DBId}
+  end.
+get_user_id(DBRef, VHost, User) ->
+  % Look at ets
+  case ets:match(ets_users_table(VHost), {User, '$1'}) of
+       [] ->
+         % Look at db
+         case get_user_id_from_db(DBRef, VHost, User) of
+              % no such user in db
+              {ok, []} ->
+                 IQuery = ["INSERT INTO ",users_table(VHost)," ",
+                              "SET username=\"",User,"\";"],
+                 case sql_query_internal_silent(DBRef, IQuery) of
+                      {updated, _} ->
+                          {ok, NewId} = get_user_id_from_db(DBRef, VHost, User),
+                          NewId;
+                      {error, Reason} ->
+                          % this can be in clustered environment
+                          match = ejabberd_regexp:run(iolist_to_binary(Reason), <<"#23000">>),
+                          ?ERROR_MSG("Duplicate key name for ~p", [User]),
+                          {ok, ClID} = get_user_id_from_db(DBRef, VHost, User),
+                          ClID
+                 end;
+              {ok, DBId} ->
+                 DBId
+         end;
+       [[EtsId]] -> EtsId
+  end.
+
+get_server_id(DBRef, VHost, Server) ->
+  case ets:match(ets_servers_table(VHost), {Server, '$1'}) of
+       [] ->
+        IQuery = ["INSERT INTO ",servers_table(VHost)," ",
+                     "SET server=\"",Server,"\";"],
+        case sql_query_internal_silent(DBRef, IQuery) of
+             {updated, _} ->
+                SQuery = ["SELECT server_id FROM ",servers_table(VHost)," ",
+                             "WHERE server=\"",Server,"\";"],
+                {data, [[Id]]} = sql_query_internal(DBRef, SQuery),
+                ets:insert(ets_servers_table(VHost), {Server, Id}),
+                Id;
+             {error, Reason} ->
+                % this can be in clustered environment
+                match = ejabberd_regexp:run(iolist_to_binary(Reason), <<"#23000">>),
+                ?ERROR_MSG("Duplicate key name for ~p", [Server]),
+                update_servers_from_db(DBRef, VHost),
+                [[Id1]] = ets:match(ets_servers_table(VHost), {Server, '$1'}),
+                Id1
+        end;
+       [[Id]] -> Id
+  end.
+
+get_resource_id_from_db(DBRef, VHost, Resource) ->
+  SQuery = ["SELECT resource_id FROM ",resources_table(VHost)," ",
+               "WHERE resource=\"",binary_to_list(ejabberd_sql:escape(iolist_to_binary(Resource))),"\";"],
+  case sql_query_internal(DBRef, SQuery) of
+       % no such resource in db
+       {data, []} ->
+          {ok, []};
+       {data, [[DBId]]} ->
+          % cache {resource, id} pair
+          ets:insert(ets_resources_table(VHost), {Resource, DBId}),
+          {ok, DBId}
+  end.
+get_resource_id(DBRef, VHost, Resource) ->
+  % Look at ets
+  case ets:match(ets_resources_table(VHost), {Resource, '$1'}) of
+       [] ->
+         % Look at db
+         case get_resource_id_from_db(DBRef, VHost, Resource) of
+              % no such resource in db
+              {ok, []} ->
+                 IQuery = ["INSERT INTO ",resources_table(VHost)," ",
+                              "SET resource=\"",binary_to_list(ejabberd_sql:escape(iolist_to_binary(Resource))),"\";"],
+                 case sql_query_internal_silent(DBRef, IQuery) of
+                      {updated, _} ->
+                          {ok, NewId} = get_resource_id_from_db(DBRef, VHost, Resource),
+                          NewId;
+                      {error, Reason} ->
+                          % this can be in clustered environment
+                          match = ejabberd_regexp:run(iolist_to_binary(Reason), <<"#23000">>),
+                          ?ERROR_MSG("Duplicate key name for ~s", [Resource]),
+                          {ok, ClID} = get_resource_id_from_db(DBRef, VHost, Resource),
+                          ClID
+                 end;
+              {ok, DBId} ->
+                 DBId
+         end;
+       [[EtsId]] -> EtsId
+  end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% SQL internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+sql_query_internal(DBRef, Query) ->
+    case sql_query_internal_silent(DBRef, Query) of
+         {error, Reason} ->
+            ?ERROR_MSG("~p while ~p", [Reason, lists:append(Query)]),
+            {error, Reason};
+         Rez -> Rez
+    end.
+
+sql_query_internal_silent(DBRef, Query) ->
+    ?MYDEBUG("DOING: \"~s\"", [lists:append(Query)]),
+    get_result(p1_mysql_conn:fetch(DBRef, Query, self(), ?MYSQL_TIMEOUT)).
+
+get_result({updated, MySQLRes}) ->
+    {updated, p1_mysql:get_result_affected_rows(MySQLRes)};
+get_result({data, MySQLRes}) ->
+    {data, p1_mysql:get_result_rows(MySQLRes)};
+get_result({error, "query timed out"}) ->
+    {error, "query timed out"};
+get_result({error, MySQLRes}) ->
+    Reason = p1_mysql:get_result_reason(MySQLRes),
+    {error, Reason}.
diff --git a/src/mod_logdb_mysql5.erl b/src/mod_logdb_mysql5.erl
new file mode 100644
index 0000000000..b6025a3d2e
--- /dev/null
+++ b/src/mod_logdb_mysql5.erl
@@ -0,0 +1,981 @@
+%%%----------------------------------------------------------------------
+%%% File    : mod_logdb_mysql5.erl
+%%% Author  : Oleg Palij (mailto:o.palij@gmail.com)
+%%% Purpose : MySQL 5 backend for mod_logdb
+%%% Url     : https://paleg.github.io/mod_logdb/
+%%%----------------------------------------------------------------------
+
+-module(mod_logdb_mysql5).
+-author('o.palij@gmail.com').
+
+-include("mod_logdb.hrl").
+-include("ejabberd.hrl").
+-include("jlib.hrl").
+-include("logger.hrl").
+
+-behaviour(gen_logdb).
+-behaviour(gen_server).
+
+% gen_server
+-export([code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2]).
+% gen_mod
+-export([start/2, stop/1]).
+% gen_logdb
+-export([log_message/2,
+         rebuild_stats/1,
+         rebuild_stats_at/2,
+         delete_messages_by_user_at/3, delete_all_messages_by_user_at/3, delete_messages_at/2,
+         get_vhost_stats/1, get_vhost_stats_at/2, get_user_stats/2, get_user_messages_at/3,
+         get_dates/1,
+         get_users_settings/1, get_user_settings/2, set_user_settings/3,
+         drop_user/2]).
+
+% gen_server call timeout
+-define(CALL_TIMEOUT, 30000).
+-define(MYSQL_TIMEOUT, 60000).
+-define(INDEX_SIZE, integer_to_list(170)).
+-define(PROCNAME, mod_logdb_mysql5).
+
+-import(mod_logdb, [list_to_bool/1, bool_to_list/1,
+                    list_to_string/1, string_to_list/1,
+                    convert_timestamp_brief/1]).
+
+-record(state, {dbref, vhost, server, port, db, user, password}).
+
+% replace "." with "_"
+escape_vhost(VHost) -> lists:map(fun(46) -> 95;
+                                    (A) -> A
+                                 end, binary_to_list(VHost)).
+prefix() ->
+   "`logdb_".
+
+suffix(VHost) ->
+   "_" ++ escape_vhost(VHost) ++ "`".
+
+messages_table(VHost, Date) ->
+   prefix() ++ "messages_" ++ Date ++ suffix(VHost).
+
+% TODO: this needs to be redone to unify view name in stored procedure and in delete_messages_at/2
+view_table(VHost, Date) ->
+   Table = messages_table(VHost, Date),
+   TablewoQ = lists:sublist(Table, 2, length(Table) - 2),
+   lists:append(["`v_", TablewoQ, "`"]).
+
+stats_table(VHost) ->
+   prefix() ++ "stats" ++ suffix(VHost).
+
+temp_table(VHost) ->
+   prefix() ++ "temp" ++ suffix(VHost).
+
+settings_table(VHost) ->
+   prefix() ++ "settings" ++ suffix(VHost).
+
+users_table(VHost) ->
+   prefix() ++ "users" ++ suffix(VHost).
+servers_table(VHost) ->
+   prefix() ++ "servers" ++ suffix(VHost).
+resources_table(VHost) ->
+   prefix() ++ "resources" ++ suffix(VHost).
+
+logmessage_name(VHost) ->
+   prefix() ++ "logmessage" ++ suffix(VHost).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_mod callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+start(VHost, Opts) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:start({local, Proc}, ?MODULE, [VHost, Opts], []).
+
+stop(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {stop}, ?CALL_TIMEOUT).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_server callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+init([VHost, Opts]) ->
+   crypto:start(),
+
+   Server = gen_mod:get_opt(server, Opts, fun(A) -> A end, <<"localhost">>),
+   Port = gen_mod:get_opt(port, Opts, fun(A) -> A end, 3306),
+   DB = gen_mod:get_opt(db, Opts, fun(A) -> A end, <<"logdb">>),
+   User = gen_mod:get_opt(user, Opts, fun(A) -> A end, <<"root">>),
+   Password = gen_mod:get_opt(password, Opts, fun(A) -> A end, <<"">>),
+
+   St = #state{vhost=VHost,
+               server=Server, port=Port, db=DB,
+               user=User, password=Password},
+
+   case open_mysql_connection(St) of
+       {ok, DBRef} ->
+           State = St#state{dbref=DBRef},
+           ok = create_internals(State),
+           ok = create_stats_table(State),
+           ok = create_settings_table(State),
+           ok = create_users_table(State),
+           ok = create_servers_table(State),
+           ok = create_resources_table(State),
+           erlang:monitor(process, DBRef),
+           {ok, State};
+       {error, Reason} ->
+           ?ERROR_MSG("MySQL connection failed: ~p~n", [Reason]),
+           {stop, db_connection_failed}
+   end.
+
+open_mysql_connection(#state{server=Server, port=Port, db=DB,
+                             user=DBUser, password=Password} = _State) ->
+   LogFun = fun(debug, _Format, _Argument) ->
+                 %?MYDEBUG(Format, Argument);
+                 ok;
+               (error, Format, Argument) ->
+                 ?ERROR_MSG(Format, Argument);
+               (Level, Format, Argument) ->
+                 ?MYDEBUG("MySQL (~p)~n", [Level]),
+                 ?MYDEBUG(Format, Argument)
+            end,
+   ?INFO_MSG("Opening mysql connection ~s@~s:~p/~s", [DBUser, Server, Port, DB]),
+   p1_mysql_conn:start(binary_to_list(Server), Port,
+                       binary_to_list(DBUser), binary_to_list(Password),
+                       binary_to_list(DB), LogFun).
+
+close_mysql_connection(DBRef) ->
+   ?MYDEBUG("Closing ~p mysql connection", [DBRef]),
+   catch p1_mysql_conn:stop(DBRef).
+
+handle_call({rebuild_stats_at, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Reply = rebuild_stats_at_int(DBRef, VHost, Date),
+    {reply, Reply, State};
+handle_call({delete_messages_by_user_at, [], _Date}, _From, State) ->
+    {reply, error, State};
+handle_call({delete_messages_by_user_at, Msgs, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Temp = lists:flatmap(fun(#msg{timestamp=Timestamp} = _Msg) ->
+                             ["\"",Timestamp,"\"",","]
+                         end, Msgs),
+
+    Temp1 = lists:append([lists:sublist(Temp, length(Temp)-1), ");"]),
+
+    Query = ["DELETE FROM ",messages_table(VHost, Date)," ",
+                             "WHERE timestamp IN (", Temp1],
+
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {updated, Aff} ->
+              ?MYDEBUG("Aff=~p", [Aff]),
+              rebuild_stats_at_int(DBRef, VHost, Date);
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({delete_all_messages_by_user_at, User, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    ok = delete_all_messages_by_user_at_int(DBRef, User, VHost, Date),
+    ok = delete_stats_by_user_at_int(DBRef, User, VHost, Date),
+    {reply, ok, State};
+handle_call({delete_messages_at, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Fun = fun() ->
+              {updated, _} = sql_query_internal(DBRef, ["DROP TABLE ",messages_table(VHost, Date),";"]),
+              TQuery = ["DELETE FROM ",stats_table(VHost)," "
+                           "WHERE at=\"",Date,"\";"],
+              {updated, _} = sql_query_internal(DBRef, TQuery),
+              VQuery = ["DROP VIEW IF EXISTS ",view_table(VHost,Date),";"],
+              {updated, _} = sql_query_internal(DBRef, VQuery),
+              ok
+          end,
+    Reply =
+      case catch apply(Fun, []) of
+           ok ->
+              ok;
+           {'EXIT', _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({get_vhost_stats}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    SName = stats_table(VHost),
+    Query = ["SELECT at, sum(count) ",
+                "FROM ",SName," ",
+                "GROUP BY at ",
+                "ORDER BY DATE(at) DESC;"
+            ],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              {ok, [ {Date, list_to_integer(Count)} || [Date, Count] <- Result ]};
+           {error, Reason} ->
+              % TODO: Duplicate error message ?
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_vhost_stats_at, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    SName = stats_table(VHost),
+    Query = ["SELECT username, sum(count) as allcount ",
+                "FROM ",SName," ",
+                "JOIN ",users_table(VHost)," ON owner_id=user_id "
+                "WHERE at=\"",Date,"\" ",
+                "GROUP BY username ",
+                "ORDER BY allcount DESC;"
+            ],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              {ok, [ {User, list_to_integer(Count)} || [User, Count] <- Result ]};
+           {error, Reason} ->
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_user_stats, User}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    {reply, get_user_stats_int(DBRef, User, VHost), State};
+handle_call({get_user_messages_at, User, Date}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Query = ["SELECT peer_name,",
+                    "peer_server,",
+                    "peer_resource,",
+                    "direction,"
+                    "type,"
+                    "subject,"
+                    "body,"
+                    "timestamp "
+               "FROM ",view_table(VHost, Date)," "
+               "WHERE owner_name=\"",User,"\";"],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              Fun = fun([Peer_name, Peer_server, Peer_resource,
+                         Direction,
+                         Type,
+                         Subject, Body,
+                         Timestamp]) ->
+                          #msg{peer_name=Peer_name, peer_server=Peer_server, peer_resource=Peer_resource,
+                               direction=list_to_atom(Direction),
+                               type=Type,
+                               subject=Subject, body=Body,
+                               timestamp=Timestamp}
+                    end,
+              {ok, lists:map(Fun, Result)};
+           {error, Reason} ->
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_dates}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    SName = stats_table(VHost),
+    Query = ["SELECT at ",
+                "FROM ",SName," ",
+                "GROUP BY at ",
+                "ORDER BY DATE(at) DESC;"
+            ],
+    Reply =
+       case sql_query_internal(DBRef, Query) of
+            {data, Result} ->
+               [ Date || [Date] <- Result ];
+            {error, Reason} ->
+               {error, Reason}
+       end,
+    {reply, Reply, State};
+handle_call({get_users_settings}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Query = ["SELECT username,dolog_default,dolog_list,donotlog_list ",
+                "FROM ",settings_table(VHost)," ",
+             "JOIN ",users_table(VHost)," ON user_id=owner_id;"],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Result} ->
+              {ok, lists:map(fun([Owner, DoLogDef, DoLogL, DoNotLogL]) ->
+                                 #user_settings{owner_name=Owner,
+                                                dolog_default=list_to_bool(DoLogDef),
+                                                dolog_list=string_to_list(DoLogL),
+                                                donotlog_list=string_to_list(DoNotLogL)
+                                               }
+                             end, Result)};
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({get_user_settings, User}, _From, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Query = ["SELECT dolog_default,dolog_list,donotlog_list FROM ",settings_table(VHost)," ",
+                 "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost)," WHERE username=\"",User,"\");"],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, []} ->
+              {ok, []};
+           {data, [[Owner, DoLogDef, DoLogL, DoNotLogL]]} ->
+              {ok, #user_settings{owner_name=Owner,
+                                  dolog_default=list_to_bool(DoLogDef),
+                                  dolog_list=string_to_list(DoLogL),
+                                  donotlog_list=string_to_list(DoNotLogL)}};
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({set_user_settings, User, #user_settings{dolog_default=DoLogDef,
+                                                     dolog_list=DoLogL,
+                                                     donotlog_list=DoNotLogL}},
+            _From, #state{dbref=DBRef, vhost=VHost} = State) ->
+    User_id = get_user_id(DBRef, VHost, User),
+    Query = ["UPDATE ",settings_table(VHost)," ",
+                "SET dolog_default=",bool_to_list(DoLogDef),", ",
+                    "dolog_list='",list_to_string(DoLogL),"', ",
+                    "donotlog_list='",list_to_string(DoNotLogL),"' ",
+                "WHERE owner_id=",User_id,";"],
+
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {updated, 0} ->
+              IQuery = ["INSERT INTO ",settings_table(VHost)," ",
+                            "(owner_id, dolog_default, dolog_list, donotlog_list) ",
+                            "VALUES ",
+                            "(",User_id,",",bool_to_list(DoLogDef),",'",list_to_string(DoLogL),"','",list_to_string(DoNotLogL),"');"],
+              case sql_query_internal_silent(DBRef, IQuery) of
+                   {updated, _} ->
+                       ?MYDEBUG("New settings for ~s@~s", [User, VHost]),
+                       ok;
+                   {error, Reason} ->
+                       case ejabberd_regexp:run(iolist_to_binary(Reason), <<"#23000">>) of
+                            % Already exists
+                            match ->
+                                ok;
+                             _ ->
+                                ?ERROR_MSG("Failed setup user ~p@~p: ~p", [User, VHost, Reason]),
+                                error
+                       end
+              end;
+           {updated, 1} ->
+              ?MYDEBUG("Updated settings for ~s@~s", [User, VHost]),
+              ok;
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({stop}, _From, #state{vhost=VHost}=State) ->
+   ?MYDEBUG("Stoping mysql5 backend for ~p", [VHost]),
+   {stop, normal, ok, State};
+handle_call(Msg, _From, State) ->
+    ?INFO_MSG("Got call Msg: ~p, State: ~p", [Msg, State]),
+    {noreply, State}.
+
+handle_cast({log_message, Msg}, #state{dbref=DBRef, vhost=VHost}=State) ->
+    Fun = fun() ->
+            Date = convert_timestamp_brief(Msg#msg.timestamp),
+            TableName = messages_table(VHost, Date),
+
+            Query = [ "CALL ",logmessage_name(VHost)," "
+                         "('", TableName, "',",
+                         "'", Date, "',",
+                         "'", binary_to_list(Msg#msg.owner_name), "',",
+                         "'", binary_to_list(Msg#msg.peer_name), "',",
+                         "'", binary_to_list(Msg#msg.peer_server), "',",
+                         "'", binary_to_list( ejabberd_sql:escape(Msg#msg.peer_resource) ), "',",
+                         "'", atom_to_list(Msg#msg.direction), "',",
+                         "'", binary_to_list(Msg#msg.type), "',",
+                         "'", binary_to_list( ejabberd_sql:escape(Msg#msg.subject) ), "',",
+                         "'", binary_to_list( ejabberd_sql:escape(Msg#msg.body) ), "',",
+                         "'", Msg#msg.timestamp, "');"],
+
+            case sql_query_internal(DBRef, Query) of
+                 {updated, _} ->
+                    ?MYDEBUG("Logged ok for ~s, peer: ~s", [ [Msg#msg.owner_name, <<"@">>, VHost],
+                                                             [Msg#msg.peer_name, <<"@">>, Msg#msg.peer_server] ]),
+                    ok;
+                 {error, _Reason} ->
+                    error
+            end
+          end,
+    spawn(Fun),
+    {noreply, State};
+handle_cast({rebuild_stats}, State) ->
+    rebuild_all_stats_int(State),
+    {noreply, State};
+handle_cast({drop_user, User}, #state{vhost=VHost} = State) ->
+    Fun = fun() ->
+            {ok, DBRef} = open_mysql_connection(State),
+            {ok, Dates} = get_user_stats_int(DBRef, User, VHost),
+            MDResult = lists:map(fun({Date, _}) ->
+                           delete_all_messages_by_user_at_int(DBRef, User, VHost, Date)
+                       end, Dates),
+            StDResult = delete_all_stats_by_user_int(DBRef, User, VHost),
+            SDResult = delete_user_settings_int(DBRef, User, VHost),
+            case lists:all(fun(Result) when Result == ok ->
+                                true;
+                              (Result) when Result == error ->
+                               false
+                           end, lists:append([MDResult, [StDResult], [SDResult]])) of
+                 true ->
+                   ?INFO_MSG("Removed ~s@~s", [User, VHost]);
+                 false ->
+                   ?ERROR_MSG("Failed to remove ~s@~s", [User, VHost])
+            end,
+            close_mysql_connection(DBRef)
+          end,
+    spawn(Fun),
+    {noreply, State};
+handle_cast(Msg, State) ->
+    ?INFO_MSG("Got cast Msg:~p, State:~p", [Msg, State]),
+    {noreply, State}.
+
+handle_info({'DOWN', _MonitorRef, process, _Pid, _Info}, State) ->
+    {stop, connection_dropped, State};
+handle_info(Info, State) ->
+    ?INFO_MSG("Got Info:~p, State:~p", [Info, State]),
+    {noreply, State}.
+
+terminate(_Reason, #state{dbref=DBRef}=_State) ->
+    close_mysql_connection(DBRef),
+    ok.
+
+code_change(_OldVsn, State, _Extra) ->
+    {ok, State}.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_logdb callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+log_message(VHost, Msg) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:cast(Proc, {log_message, Msg}).
+rebuild_stats(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:cast(Proc, {rebuild_stats}).
+rebuild_stats_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {rebuild_stats_at, Date}, ?CALL_TIMEOUT).
+delete_messages_by_user_at(VHost, Msgs, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_messages_by_user_at, Msgs, Date}, ?CALL_TIMEOUT).
+delete_all_messages_by_user_at(User, VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_all_messages_by_user_at, User, Date}, ?CALL_TIMEOUT).
+delete_messages_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_messages_at, Date}, ?CALL_TIMEOUT).
+get_vhost_stats(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_vhost_stats}, ?CALL_TIMEOUT).
+get_vhost_stats_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_vhost_stats_at, Date}, ?CALL_TIMEOUT).
+get_user_stats(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_stats, User}, ?CALL_TIMEOUT).
+get_user_messages_at(User, VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_messages_at, User, Date}, ?CALL_TIMEOUT).
+get_dates(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_dates}, ?CALL_TIMEOUT).
+get_users_settings(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_users_settings}, ?CALL_TIMEOUT).
+get_user_settings(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_settings, User}, ?CALL_TIMEOUT).
+set_user_settings(User, VHost, Set) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {set_user_settings, User, Set}, ?CALL_TIMEOUT).
+drop_user(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:cast(Proc, {drop_user, User}).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+get_dates_int(DBRef, VHost) ->
+    case sql_query_internal(DBRef, ["SHOW TABLES"]) of
+         {data, Tables} ->
+            Reg = "^" ++ lists:sublist(prefix(),2,length(prefix())) ++ ".*" ++ escape_vhost(VHost),
+            lists:foldl(fun([Table], Dates) ->
+                           case re:run(Table, Reg) of
+                                {match, _} ->
+                                   case re:run(Table, "[0-9]+-[0-9]+-[0-9]+") of
+                                        {match, [{S, E}]} ->
+                                            lists:append(Dates, [lists:sublist(Table, S+1, E)]);
+                                        nomatch ->
+                                            Dates
+                                   end;
+                                _ ->
+                                   Dates
+                           end
+                        end, [], Tables);
+         {error, _} ->
+            []
+    end.
+
+rebuild_all_stats_int(#state{vhost=VHost}=State) ->
+    Fun = fun() ->
+             {ok, DBRef} = open_mysql_connection(State),
+             ok = delete_nonexistent_stats(DBRef, VHost),
+             case lists:filter(fun(Date) ->
+                                 case catch rebuild_stats_at_int(DBRef, VHost, Date) of
+                                      ok -> false;
+                                      error -> true;
+                                      {'EXIT', _} -> true
+                                 end
+                             end, get_dates_int(DBRef, VHost)) of
+                  [] -> ok;
+                  FTables ->
+                     ?ERROR_MSG("Failed to rebuild stats for ~p dates", [FTables]),
+                     error
+             end,
+             close_mysql_connection(DBRef)
+          end,
+    spawn(Fun).
+
+rebuild_stats_at_int(DBRef, VHost, Date) ->
+    TempTable = temp_table(VHost),
+    Fun = fun() ->
+           Table = messages_table(VHost, Date),
+           STable = stats_table(VHost),
+
+           DQuery = [ "DELETE FROM ",STable," ",
+                          "WHERE at='",Date,"';"],
+
+           ok = create_temp_table(DBRef, TempTable),
+           {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",Table," WRITE, ",TempTable," WRITE;"]),
+           SQuery = ["INSERT INTO ",TempTable," ",
+                      "(owner_id,peer_name_id,peer_server_id,at,count) ",
+                         "SELECT owner_id,peer_name_id,peer_server_id,\"",Date,"\",count(*) ",
+                            "FROM ",Table," WHERE ext is NULL GROUP BY owner_id,peer_name_id,peer_server_id;"],
+           case sql_query_internal(DBRef, SQuery) of
+                  {updated, 0} ->
+                      Count = sql_query_internal(DBRef, ["SELECT count(*) FROM ",Table,";"]),
+                      case Count of
+                        {data, [["0"]]} ->
+                           {updated, _} = sql_query_internal(DBRef, ["DROP TABLE ",Table,";"]),
+                           sql_query_internal(DBRef, ["UNLOCK TABLES;"]),
+                           {updated, _} = sql_query_internal(DBRef, ["DROP VIEW IF EXISTS ",view_table(VHost,Date),";"]),
+                           {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",STable," WRITE, ",TempTable," WRITE;"]),
+                           {updated, _} = sql_query_internal(DBRef, DQuery),
+                           ok;
+                        _ ->
+                           ?ERROR_MSG("Failed to calculate stats for ~s table! Count was ~p.", [Date, Count]),
+                           error
+                      end;
+                  {updated, _} ->
+                      {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",STable," WRITE, ",TempTable," WRITE;"]),
+                      {updated, _} = sql_query_internal(DBRef, DQuery),
+                      SQuery1 = ["INSERT INTO ",STable," ",
+                                  "(owner_id,peer_name_id,peer_server_id,at,count) ",
+                                     "SELECT owner_id,peer_name_id,peer_server_id,at,count ",
+                                        "FROM ",TempTable,";"],
+                      case sql_query_internal(DBRef, SQuery1) of
+                           {updated, _} -> ok;
+                           {error, _} -> error
+                      end;
+                  {error, _} -> error
+           end
+       end,
+
+    case catch apply(Fun, []) of
+         ok ->
+           ?INFO_MSG("Rebuilded stats for ~p at ~p", [VHost, Date]),
+           ok;
+         error ->
+           error;
+         {'EXIT', Reason} ->
+           ?ERROR_MSG("Failed to rebuild stats for ~s table: ~p.", [Date, Reason]),
+           error
+    end,
+    sql_query_internal(DBRef, ["UNLOCK TABLES;"]),
+    sql_query_internal(DBRef, ["DROP TABLE ",TempTable,";"]),
+    ok.
+
+delete_nonexistent_stats(DBRef, VHost) ->
+    Dates = get_dates_int(DBRef, VHost),
+    STable = stats_table(VHost),
+
+    Temp = lists:flatmap(fun(Date) ->
+                             ["\"",Date,"\"",","]
+                         end, Dates),
+    case Temp of
+         [] ->
+           ok;
+         _ ->
+           % replace last "," with ");"
+           Temp1 = lists:append([lists:sublist(Temp, length(Temp)-1), ");"]),
+           Query = ["DELETE FROM ",STable," ",
+                       "WHERE at NOT IN (", Temp1],
+           case sql_query_internal(DBRef, Query) of
+                {updated, _} ->
+                    ok;
+                {error, _} ->
+                    error
+           end
+    end.
+
+get_user_stats_int(DBRef, User, VHost) ->
+    SName = stats_table(VHost),
+    UName = users_table(VHost),
+    Query = ["SELECT stats.at, sum(stats.count) ",
+                "FROM ",UName," AS users ",
+                   "JOIN ",SName," AS stats ON owner_id=user_id "
+                "WHERE users.username=\"",User,"\" ",
+                "GROUP BY stats.at "
+                "ORDER BY DATE(stats.at) DESC;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {data, Result} ->
+            {ok, [ {Date, list_to_integer(Count)} || [Date, Count] <- Result ]};
+         {error, Result} ->
+            {error, Result}
+    end.
+
+delete_all_messages_by_user_at_int(DBRef, User, VHost, Date) ->
+    DQuery = ["DELETE FROM ",messages_table(VHost, Date)," ",
+                 "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost)," WHERE username=\"",User,"\");"],
+    case sql_query_internal(DBRef, DQuery) of
+         {updated, _} ->
+            ?INFO_MSG("Dropped messages for ~s@~s at ~s", [User, VHost, Date]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+delete_all_stats_by_user_int(DBRef, User, VHost) ->
+    SQuery = ["DELETE FROM ",stats_table(VHost)," ",
+                "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost)," WHERE username=\"",User,"\");"],
+    case sql_query_internal(DBRef, SQuery) of
+         {updated, _} ->
+             ?INFO_MSG("Dropped all stats for ~s@~s", [User, VHost]),
+             ok;
+         {error, _} -> error
+    end.
+
+delete_stats_by_user_at_int(DBRef, User, VHost, Date) ->
+    SQuery = ["DELETE FROM ",stats_table(VHost)," ",
+                "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost)," WHERE username=\"",User,"\") ",
+                  "AND at=\"",Date,"\";"],
+    case sql_query_internal(DBRef, SQuery) of
+         {updated, _} ->
+             ?INFO_MSG("Dropped stats for ~s@~s at ~s", [User, VHost, Date]),
+             ok;
+         {error, _} -> error
+    end.
+
+delete_user_settings_int(DBRef, User, VHost) ->
+    Query = ["DELETE FROM ",settings_table(VHost)," ",
+                 "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost)," WHERE username=\"",User,"\");"],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?INFO_MSG("Dropped ~s@~s settings", [User, VHost]),
+            ok;
+         {error, Reason} ->
+            ?ERROR_MSG("Failed to drop ~s@~s settings: ~p", [User, VHost, Reason]),
+            error
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% tables internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+create_temp_table(DBRef, Name) ->
+    Query = ["CREATE TABLE ",Name," (",
+                "owner_id MEDIUMINT UNSIGNED, ",
+                "peer_name_id MEDIUMINT UNSIGNED, ",
+                "peer_server_id MEDIUMINT UNSIGNED, ",
+                "at VARCHAR(11), ",
+                "count INT(11) ",
+             ") ENGINE=MyISAM CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} -> ok;
+         {error, _Reason} -> error
+    end.
+
+create_stats_table(#state{dbref=DBRef, vhost=VHost}=State) ->
+    SName = stats_table(VHost),
+    Query = ["CREATE TABLE ",SName," (",
+                "owner_id MEDIUMINT UNSIGNED, ",
+                "peer_name_id MEDIUMINT UNSIGNED, ",
+                "peer_server_id MEDIUMINT UNSIGNED, ",
+                "at VARCHAR(11), ",
+                "count INT(11), ",
+                "ext INTEGER DEFAULT NULL, "
+                "INDEX ext_i (ext), "
+                "INDEX(owner_id,peer_name_id,peer_server_id), ",
+                "INDEX(at) ",
+             ") ENGINE=MyISAM CHARACTER SET utf8;"
+            ],
+    case sql_query_internal_silent(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created stats table for ~p", [VHost]),
+            rebuild_all_stats_int(State),
+            ok;
+         {error, Reason} ->
+            case ejabberd_regexp:run(iolist_to_binary(Reason), <<"#42S01">>) of
+                 match ->
+                   ?MYDEBUG("Stats table for ~p already exists", [VHost]),
+                   CheckQuery = ["SHOW COLUMNS FROM ",SName," LIKE 'peer_%_id';"],
+                   case sql_query_internal(DBRef, CheckQuery) of
+                        {data, Elems} when length(Elems) == 2 ->
+                          ?MYDEBUG("Stats table structure is ok", []),
+                          ok;
+                        _ ->
+                          ?INFO_MSG("It seems like stats table structure is invalid. I will drop it and recreate", []),
+                          case sql_query_internal(DBRef, ["DROP TABLE ",SName,";"]) of
+                               {updated, _} ->
+                                  ?INFO_MSG("Successfully dropped ~p", [SName]);
+                               _ ->
+                                  ?ERROR_MSG("Failed to drop ~p. You should drop it and restart module", [SName])
+                          end,
+                          error
+                   end;
+                 _ ->
+                   ?ERROR_MSG("Failed to create stats table for ~p: ~p", [VHost, Reason]),
+                   error
+            end
+    end.
+
+create_settings_table(#state{dbref=DBRef, vhost=VHost}) ->
+    SName = settings_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",SName," (",
+                "owner_id MEDIUMINT UNSIGNED PRIMARY KEY, ",
+                "dolog_default TINYINT(1) NOT NULL DEFAULT 1, ",
+                "dolog_list TEXT, ",
+                "donotlog_list TEXT ",
+             ") ENGINE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created settings table for ~p", [VHost]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+create_users_table(#state{dbref=DBRef, vhost=VHost}) ->
+    SName = users_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",SName," (",
+                "username TEXT NOT NULL, ",
+                "user_id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE, ",
+                "UNIQUE INDEX(username(",?INDEX_SIZE,")) ",
+             ") ENGINE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created users table for ~p", [VHost]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+create_servers_table(#state{dbref=DBRef, vhost=VHost}) ->
+    SName = servers_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",SName," (",
+                "server TEXT NOT NULL, ",
+                "server_id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE, ",
+                "UNIQUE INDEX(server(",?INDEX_SIZE,")) ",
+             ") ENGINE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created servers table for ~p", [VHost]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+create_resources_table(#state{dbref=DBRef, vhost=VHost}) ->
+    RName = resources_table(VHost),
+    Query = ["CREATE TABLE IF NOT EXISTS ",RName," (",
+                "resource TEXT NOT NULL, ",
+                "resource_id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE, ",
+                "UNIQUE INDEX(resource(",?INDEX_SIZE,")) ",
+             ") ENGINE=InnoDB CHARACTER SET utf8;"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created resources table for ~p", [VHost]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+create_internals(#state{dbref=DBRef, vhost=VHost}) ->
+    sql_query_internal(DBRef, ["DROP PROCEDURE IF EXISTS ",logmessage_name(VHost),";"]),
+    case sql_query_internal(DBRef, [get_logmessage(VHost)]) of
+         {updated, _} ->
+            ?MYDEBUG("Created logmessage for ~p", [VHost]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% SQL internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+sql_query_internal(DBRef, Query) ->
+    case sql_query_internal_silent(DBRef, Query) of
+         {error, Reason} ->
+            ?ERROR_MSG("~p while ~p", [Reason, lists:append(Query)]),
+            {error, Reason};
+         Rez -> Rez
+    end.
+
+sql_query_internal_silent(DBRef, Query) ->
+    ?MYDEBUG("DOING: \"~s\"", [lists:append(Query)]),
+    get_result(p1_mysql_conn:fetch(DBRef, Query, self(), ?MYSQL_TIMEOUT)).
+
+get_result({updated, MySQLRes}) ->
+    {updated, p1_mysql:get_result_affected_rows(MySQLRes)};
+get_result({data, MySQLRes}) ->
+    {data, p1_mysql:get_result_rows(MySQLRes)};
+get_result({error, "query timed out"}) ->
+    {error, "query timed out"};
+get_result({error, MySQLRes}) ->
+    Reason = p1_mysql:get_result_reason(MySQLRes),
+    {error, Reason}.
+
+get_user_id(DBRef, VHost, User) ->
+  SQuery = ["SELECT user_id FROM ",users_table(VHost)," ",
+               "WHERE username=\"",User,"\";"],
+  case sql_query_internal(DBRef, SQuery) of
+       {data, []} ->
+          IQuery = ["INSERT INTO ",users_table(VHost)," ",
+                       "SET username=\"",User,"\";"],
+          case sql_query_internal_silent(DBRef, IQuery) of
+               {updated, _} ->
+                   {data, [[DBIdNew]]} = sql_query_internal(DBRef, SQuery),
+                   DBIdNew;
+               {error, Reason} ->
+                   % this can be in clustered environment
+                   match = ejabberd_regexp:run(iolist_to_binary(Reason), <<"#23000">>),
+                   ?ERROR_MSG("Duplicate key name for ~p", [User]),
+                   {data, [[ClID]]} = sql_query_internal(DBRef, SQuery),
+                   ClID
+          end;
+       {data, [[DBId]]} ->
+          DBId
+  end.
+
+get_logmessage(VHost) ->
+    UName = users_table(VHost),
+    SName = servers_table(VHost),
+    RName = resources_table(VHost),
+    StName = stats_table(VHost),
+    io_lib:format("
+CREATE PROCEDURE ~s(tablename TEXT, atdate TEXT, owner TEXT, peer_name TEXT, peer_server TEXT, peer_resource TEXT, mdirection VARCHAR(4), mtype VARCHAR(10), msubject TEXT, mbody TEXT, mtimestamp DOUBLE)
+BEGIN
+   DECLARE ownerID MEDIUMINT UNSIGNED;
+   DECLARE peer_nameID MEDIUMINT UNSIGNED;
+   DECLARE peer_serverID MEDIUMINT UNSIGNED;
+   DECLARE peer_resourceID MEDIUMINT UNSIGNED;
+   DECLARE Vmtype VARCHAR(10);
+   DECLARE Vmtimestamp DOUBLE;
+   DECLARE Vmdirection VARCHAR(4);
+   DECLARE Vmbody TEXT;
+   DECLARE Vmsubject TEXT;
+   DECLARE iq TEXT;
+   DECLARE cq TEXT;
+   DECLARE viewname TEXT;
+   DECLARE notable INT;
+   DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02' SET @notable = 1;
+
+   SET @notable = 0;
+   SET @ownerID = NULL;
+   SET @peer_nameID = NULL;
+   SET @peer_serverID = NULL;
+   SET @peer_resourceID = NULL;
+
+   SET @Vmtype = mtype;
+   SET @Vmtimestamp = mtimestamp;
+   SET @Vmdirection = mdirection;
+   SET @Vmbody = mbody;
+   SET @Vmsubject = msubject;
+
+   SELECT user_id INTO @ownerID FROM ~s WHERE username=owner;
+   IF @ownerID IS NULL THEN
+      INSERT INTO ~s SET username=owner;
+      SET @ownerID = LAST_INSERT_ID();
+   END IF;
+
+   SELECT user_id INTO @peer_nameID FROM ~s WHERE username=peer_name;
+   IF @peer_nameID IS NULL THEN
+      INSERT INTO ~s SET username=peer_name;
+      SET @peer_nameID = LAST_INSERT_ID();
+   END IF;
+
+   SELECT server_id INTO @peer_serverID FROM ~s WHERE server=peer_server;
+   IF @peer_serverID IS NULL THEN
+      INSERT INTO ~s SET server=peer_server;
+      SET @peer_serverID = LAST_INSERT_ID();
+   END IF;
+
+   SELECT resource_id INTO @peer_resourceID FROM ~s WHERE resource=peer_resource;
+   IF @peer_resourceID IS NULL THEN
+      INSERT INTO ~s SET resource=peer_resource;
+      SET @peer_resourceID = LAST_INSERT_ID();
+   END IF;
+
+   SET @iq = CONCAT(\"INSERT INTO \",tablename,\" (owner_id, peer_name_id, peer_server_id, peer_resource_id, direction, type, subject, body, timestamp) VALUES (@ownerID,@peer_nameID,@peer_serverID,@peer_resourceID,@Vmdirection,@Vmtype,@Vmsubject,@Vmbody,@Vmtimestamp);\");
+   PREPARE insertmsg FROM @iq;
+
+   IF @notable = 1 THEN
+      SET @cq = CONCAT(\"CREATE TABLE \",tablename,\" (
+                          owner_id MEDIUMINT UNSIGNED NOT NULL,
+                          peer_name_id MEDIUMINT UNSIGNED NOT NULL,
+                          peer_server_id MEDIUMINT UNSIGNED NOT NULL,
+                          peer_resource_id MEDIUMINT(8) UNSIGNED NOT NULL,
+                          direction ENUM('to', 'from') NOT NULL,
+                          type ENUM('chat','error','groupchat','headline','normal') NOT NULL,
+                          subject TEXT,
+                          body TEXT,
+                          timestamp DOUBLE NOT NULL,
+                          ext INTEGER DEFAULT NULL,
+                          INDEX search_i (owner_id, peer_name_id, peer_server_id, peer_resource_id),
+                          INDEX ext_i (ext),
+                          FULLTEXT (body)
+                       ) ENGINE=MyISAM
+                         PACK_KEYS=1
+                         CHARACTER SET utf8;\");
+      PREPARE createtable FROM @cq;
+      EXECUTE createtable;
+      DEALLOCATE PREPARE createtable;
+
+      SET @viewname = CONCAT(\"`v_\", TRIM(BOTH '`' FROM tablename), \"`\");
+      SET @cq = CONCAT(\"CREATE OR REPLACE VIEW \",@viewname,\" AS
+                         SELECT owner.username AS owner_name,
+                                peer.username AS peer_name,
+                                servers.server AS peer_server,
+                                resources.resource AS peer_resource,
+                                messages.direction,
+                                messages.type,
+                                messages.subject,
+                                messages.body,
+                                messages.timestamp
+                         FROM
+                                ~s owner,
+                                ~s peer,
+                                ~s servers,
+                                ~s resources,
+                              \", tablename,\" messages
+                         WHERE
+                                owner.user_id=messages.owner_id and
+                                peer.user_id=messages.peer_name_id and
+                                servers.server_id=messages.peer_server_id and
+                                resources.resource_id=messages.peer_resource_id
+                         ORDER BY messages.timestamp;\");
+      PREPARE createview FROM @cq;
+      EXECUTE createview;
+      DEALLOCATE PREPARE createview;
+
+      SET @notable = 0;
+      PREPARE insertmsg FROM @iq;
+      EXECUTE insertmsg;
+   ELSEIF @notable = 0 THEN
+      EXECUTE insertmsg;
+   END IF;
+
+   DEALLOCATE PREPARE insertmsg;
+
+   IF @notable = 0 THEN
+      UPDATE ~s SET count=count+1 WHERE owner_id=@ownerID AND peer_name_id=@peer_nameID AND peer_server_id=@peer_serverID AND at=atdate;
+      IF ROW_COUNT() = 0 THEN
+         INSERT INTO ~s (owner_id, peer_name_id, peer_server_id, at, count) VALUES (@ownerID, @peer_nameID, @peer_serverID, atdate, 1);
+      END IF;
+   END IF;
+END;", [logmessage_name(VHost),UName,UName,UName,UName,SName,SName,RName,RName,UName,UName,SName,RName,StName,StName]).
diff --git a/src/mod_logdb_pgsql.erl b/src/mod_logdb_pgsql.erl
new file mode 100644
index 0000000000..61a71fffb0
--- /dev/null
+++ b/src/mod_logdb_pgsql.erl
@@ -0,0 +1,1106 @@
+% {ok, DBRef} = pgsql:connect([{host, "127.0.0.1"}, {database, "logdb"}, {user, "logdb"}, {password, "logdb"}, {port, 5432}, {as_binary, true}]).
+% Schema = "test".
+% pgsql:squery(DBRef, "CREATE TABLE test.\"logdb_stats_test\" (owner_id INTEGER, peer_name_id INTEGER, peer_server_id INTEGER, at VARCHAR(20), count integer);" ).
+%%%----------------------------------------------------------------------
+%%% File    : mod_logdb_pgsql.erl
+%%% Author  : Oleg Palij (mailto:o.palij@gmail.com)
+%%% Purpose : Posgresql backend for mod_logdb
+%%% Url     : https://paleg.github.io/mod_logdb/
+%%%----------------------------------------------------------------------
+
+-module(mod_logdb_pgsql).
+-author('o.palij@gmail.com').
+
+-include("mod_logdb.hrl").
+-include("ejabberd.hrl").
+-include("jlib.hrl").
+-include("logger.hrl").
+
+-behaviour(gen_logdb).
+-behaviour(gen_server).
+
+% gen_server
+-export([code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2]).
+% gen_mod
+-export([start/2, stop/1]).
+% gen_logdb
+-export([log_message/2,
+         rebuild_stats/1,
+         rebuild_stats_at/2,
+         delete_messages_by_user_at/3, delete_all_messages_by_user_at/3, delete_messages_at/2,
+         get_vhost_stats/1, get_vhost_stats_at/2, get_user_stats/2, get_user_messages_at/3,
+         get_dates/1,
+         get_users_settings/1, get_user_settings/2, set_user_settings/3,
+         drop_user/2]).
+
+-export([view_table/3]).
+
+% gen_server call timeout
+-define(CALL_TIMEOUT, 30000).
+-define(PGSQL_TIMEOUT, 60000).
+-define(PROCNAME, mod_logdb_pgsql).
+
+-import(mod_logdb, [list_to_bool/1, bool_to_list/1,
+                    list_to_string/1, string_to_list/1,
+                    convert_timestamp_brief/1]).
+
+-record(state, {dbref, vhost, server, port, db, user, password, schema}).
+
+% replace "." with "_"
+escape_vhost(VHost) -> lists:map(fun(46) -> 95;
+                                    (A) -> A
+                                 end, binary_to_list(VHost)).
+
+prefix(Schema) ->
+   Schema ++ ".\"" ++ "logdb_".
+
+suffix(VHost) ->
+   "_" ++ escape_vhost(VHost) ++ "\"".
+
+messages_table(VHost, Schema, Date) ->
+   prefix(Schema) ++ "messages_" ++ Date ++ suffix(VHost).
+
+view_table(VHost, Schema, Date) ->
+   Table = messages_table(VHost, Schema, Date),
+   TablewoS = lists:sublist(Table, length(Schema) + 3, length(Table) - length(Schema) - 3),
+   lists:append([Schema, ".\"v_", TablewoS, "\""]).
+
+stats_table(VHost, Schema) ->
+   prefix(Schema) ++ "stats" ++ suffix(VHost).
+
+temp_table(VHost, Schema) ->
+   prefix(Schema) ++ "temp" ++ suffix(VHost).
+
+settings_table(VHost, Schema) ->
+   prefix(Schema) ++ "settings" ++ suffix(VHost).
+
+users_table(VHost, Schema) ->
+   prefix(Schema) ++ "users" ++ suffix(VHost).
+servers_table(VHost, Schema) ->
+   prefix(Schema) ++ "servers" ++ suffix(VHost).
+resources_table(VHost, Schema) ->
+   prefix(Schema) ++ "resources" ++ suffix(VHost).
+
+logmessage_name(VHost, Schema) ->
+   prefix(Schema) ++ "logmessage" ++ suffix(VHost).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_mod callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+start(VHost, Opts) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:start({local, Proc}, ?MODULE, [VHost, Opts], []).
+
+stop(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {stop}, ?CALL_TIMEOUT).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_server callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+init([VHost, Opts]) ->
+   Server = gen_mod:get_opt(server, Opts, fun(A) -> A end, <<"localhost">>),
+   DB = gen_mod:get_opt(db, Opts, fun(A) -> A end, <<"ejabberd_logdb">>),
+   User = gen_mod:get_opt(user, Opts, fun(A) -> A end, <<"root">>),
+   Port = gen_mod:get_opt(port, Opts, fun(A) -> A end, 5432),
+   Password = gen_mod:get_opt(password, Opts, fun(A) -> A end, <<"">>),
+   Schema = binary_to_list(gen_mod:get_opt(schema, Opts, fun(A) -> A end, <<"public">>)),
+
+   ?MYDEBUG("Starting pgsql backend for ~s", [VHost]),
+
+   St = #state{vhost=VHost,
+               server=Server, port=Port, db=DB,
+               user=User, password=Password,
+               schema=Schema},
+
+   case open_pgsql_connection(St) of
+       {ok, DBRef} ->
+           State = St#state{dbref=DBRef},
+           ok = create_internals(State),
+           ok = create_stats_table(State),
+           ok = create_settings_table(State),
+           ok = create_users_table(State),
+           ok = create_servers_table(State),
+           ok = create_resources_table(State),
+           erlang:monitor(process, DBRef),
+           {ok, State};
+       % this does not work
+       {error, Reason} ->
+           ?ERROR_MSG("PgSQL connection failed: ~p~n", [Reason]),
+           {stop, db_connection_failed};
+       % and this too, becouse pgsql_conn do exit() which can not be catched
+       {'EXIT', Rez} ->
+           ?ERROR_MSG("Rez: ~p~n", [Rez]),
+           {stop, db_connection_failed}
+   end.
+
+open_pgsql_connection(#state{server=Server, port=Port, db=DB, schema=Schema,
+                             user=User, password=Password} = _State) ->
+   ?INFO_MSG("Opening pgsql connection ~s@~s:~p/~s", [User, Server, Port, DB]),
+   {ok, DBRef} = pgsql:connect(Server, DB, User, Password, Port),
+   {updated, _} = sql_query_internal(DBRef, ["SET SEARCH_PATH TO ",Schema,";"]),
+   {ok, DBRef}.
+
+close_pgsql_connection(DBRef) ->
+   ?MYDEBUG("Closing ~p pgsql connection", [DBRef]),
+   pgsql:terminate(DBRef).
+
+handle_call({log_message, Msg}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    Date = convert_timestamp_brief(Msg#msg.timestamp),
+    TableName = messages_table(VHost, Schema, Date),
+    ViewName = view_table(VHost, Schema, Date),
+
+    Query = [ "SELECT ", logmessage_name(VHost, Schema)," "
+                 "('", TableName, "',",
+                  "'", ViewName, "',",
+                  "'", Date, "',",
+                  "'", binary_to_list(Msg#msg.owner_name), "',",
+                  "'", binary_to_list(Msg#msg.peer_name), "',",
+                  "'", binary_to_list(Msg#msg.peer_server), "',",
+                  "'", binary_to_list( ejabberd_sql:escape(Msg#msg.peer_resource) ), "',",
+                  "'", atom_to_list(Msg#msg.direction), "',",
+                  "'", binary_to_list(Msg#msg.type), "',",
+                  "'", binary_to_list( ejabberd_sql:escape(Msg#msg.subject) ), "',",
+                  "'", binary_to_list( ejabberd_sql:escape(Msg#msg.body) ), "',",
+                  "'", Msg#msg.timestamp, "');"],
+
+    case sql_query_internal_silent(DBRef, Query) of
+    % TODO: change this
+         {data, [{"0"}]} ->
+             ?MYDEBUG("Logged ok for ~s, peer: ~s", [ [Msg#msg.owner_name, <<"@">>, VHost],
+                                                      [Msg#msg.peer_name, <<"@">>, Msg#msg.peer_server] ]),
+             ok;
+         {error, _Reason} ->
+             error
+    end,
+    {reply, ok, State};
+handle_call({rebuild_stats_at, Date}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    Reply = rebuild_stats_at_int(DBRef, VHost, Schema, Date),
+    {reply, Reply, State};
+handle_call({delete_messages_by_user_at, [], _Date}, _From, State) ->
+    {reply, error, State};
+handle_call({delete_messages_by_user_at, Msgs, Date}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    Temp = lists:flatmap(fun(#msg{timestamp=Timestamp} = _Msg) ->
+                             ["'",Timestamp,"'",","]
+                         end, Msgs),
+
+    Temp1 = lists:append([lists:sublist(Temp, length(Temp)-1), ");"]),
+
+    Query = ["DELETE FROM ",messages_table(VHost, Schema, Date)," ",
+                             "WHERE timestamp IN (", Temp1],
+
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {updated, _} ->
+              rebuild_stats_at_int(DBRef, VHost, Schema, Date);
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({delete_all_messages_by_user_at, User, Date}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    ok = delete_all_messages_by_user_at_int(DBRef, Schema, User, VHost, Date),
+    ok = delete_stats_by_user_at_int(DBRef, Schema, User, VHost, Date),
+    {reply, ok, State};
+handle_call({delete_messages_at, Date}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    {updated, _} = sql_query_internal(DBRef, ["DROP VIEW ",view_table(VHost, Schema, Date),";"]),
+    Reply =
+      case sql_query_internal(DBRef, ["DROP TABLE ",messages_table(VHost, Schema, Date)," CASCADE;"]) of
+           {updated, _} ->
+              Query = ["DELETE FROM ",stats_table(VHost, Schema)," "
+                          "WHERE at='",Date,"';"],
+              case sql_query_internal(DBRef, Query) of
+                   {updated, _} ->
+                      ok;
+                   {error, _} ->
+                      error
+              end;
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({get_vhost_stats}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    SName = stats_table(VHost, Schema),
+    Query = ["SELECT at, sum(count) ",
+                "FROM ",SName," ",
+                "GROUP BY at ",
+                "ORDER BY DATE(at) DESC;"
+            ],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Recs} ->
+              {ok, [ {Date, list_to_integer(Count)} || {Date, Count} <- Recs]};
+           {error, Reason} ->
+              % TODO: Duplicate error message ?
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_vhost_stats_at, Date}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    SName = stats_table(VHost, Schema),
+    Query = ["SELECT username, sum(count) AS allcount ",
+                "FROM ",SName," ",
+                "JOIN ",users_table(VHost, Schema)," ON owner_id=user_id ",
+                "WHERE at='",Date,"' ",
+                "GROUP BY username ",
+                "ORDER BY allcount DESC;"
+            ],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Recs} ->
+              RFun = fun({User, Count}) ->
+                          {User, list_to_integer(Count)}
+                     end,
+              {ok, lists:reverse(lists:keysort(2, lists:map(RFun, Recs)))};
+           {error, Reason} ->
+              % TODO:
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_user_stats, User}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    {reply, get_user_stats_int(DBRef, Schema, User, VHost), State};
+handle_call({get_user_messages_at, User, Date}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    Query = ["SELECT peer_name,",
+                    "peer_server,",
+                    "peer_resource,",
+                    "direction,"
+                    "type,"
+                    "subject,"
+                    "body,"
+                    "timestamp "
+               "FROM ",view_table(VHost, Schema, Date)," "
+               "WHERE owner_name='",User,"';"],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Recs} ->
+              Fun = fun({Peer_name, Peer_server, Peer_resource,
+                         Direction,
+                         Type,
+                         Subject, Body,
+                         Timestamp}) ->
+                          #msg{peer_name=Peer_name, peer_server=Peer_server, peer_resource=Peer_resource,
+                               direction=list_to_atom(Direction),
+                               type=Type,
+                               subject=Subject, body=Body,
+                               timestamp=Timestamp}
+                    end,
+              {ok, lists:map(Fun, Recs)};
+           {error, Reason} ->
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_dates}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    SName = stats_table(VHost, Schema),
+    Query = ["SELECT at ",
+                "FROM ",SName," ",
+                "GROUP BY at ",
+                "ORDER BY at DESC;"
+            ],
+    Reply =
+       case sql_query_internal(DBRef, Query) of
+            {data, Result} ->
+               [ Date || {Date} <- Result ];
+            {error, Reason} ->
+               {error, Reason}
+       end,
+    {reply, Reply, State};
+handle_call({get_users_settings}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    Query = ["SELECT username,dolog_default,dolog_list,donotlog_list ",
+                "FROM ",settings_table(VHost, Schema)," ",
+             "JOIN ",users_table(VHost, Schema)," ON user_id=owner_id;"],
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {data, Recs} ->
+              {ok, [#user_settings{owner_name=Owner,
+                                   dolog_default=list_to_bool(DoLogDef),
+                                   dolog_list=string_to_list(DoLogL),
+                                   donotlog_list=string_to_list(DoNotLogL)
+                                  } || {Owner, DoLogDef, DoLogL, DoNotLogL} <- Recs]};
+           {error, Reason} ->
+              {error, Reason}
+      end,
+    {reply, Reply, State};
+handle_call({get_user_settings, User}, _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    Query = ["SELECT dolog_default,dolog_list,donotlog_list ",
+                "FROM ",settings_table(VHost, Schema)," ",
+             "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost, Schema)," WHERE username='",User,"');"],
+    Reply =
+      case sql_query_internal_silent(DBRef, Query) of
+           {data, []} ->
+              {ok, []};
+           {data, [{DoLogDef, DoLogL, DoNotLogL}]} ->
+              {ok, #user_settings{owner_name=User,
+                                  dolog_default=list_to_bool(DoLogDef),
+                                  dolog_list=string_to_list(DoLogL),
+                                  donotlog_list=string_to_list(DoNotLogL)}};
+           {error, Reason} ->
+              ?ERROR_MSG("Failed to get_user_settings for ~s@~s: ~p", [User, VHost, Reason]),
+              error
+      end,
+    {reply, Reply, State};
+handle_call({set_user_settings, User, #user_settings{dolog_default=DoLogDef,
+                                                     dolog_list=DoLogL,
+                                                     donotlog_list=DoNotLogL}},
+            _From, #state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    User_id = get_user_id(DBRef, VHost, Schema, User),
+    Query = ["UPDATE ",settings_table(VHost, Schema)," ",
+                "SET dolog_default=",bool_to_list(DoLogDef),", ",
+                    "dolog_list='",list_to_string(DoLogL),"', ",
+                    "donotlog_list='",list_to_string(DoNotLogL),"' ",
+                "WHERE owner_id=",User_id,";"],
+
+    Reply =
+      case sql_query_internal(DBRef, Query) of
+           {updated, 0} ->
+              IQuery = ["INSERT INTO ",settings_table(VHost, Schema)," ",
+                            "(owner_id, dolog_default, dolog_list, donotlog_list) ",
+                            "VALUES ",
+                            "(",User_id,", ",bool_to_list(DoLogDef),",'",list_to_string(DoLogL),"','",list_to_string(DoNotLogL),"');"],
+              case sql_query_internal(DBRef, IQuery) of
+                   {updated, 1} ->
+                       ?MYDEBUG("New settings for ~s@~s", [User, VHost]),
+                       ok;
+                   {error, _} ->
+                       error
+              end;
+           {updated, 1} ->
+              ?MYDEBUG("Updated settings for ~s@~s", [User, VHost]),
+              ok;
+           {error, _} ->
+              error
+      end,
+    {reply, Reply, State};
+handle_call({stop}, _From, State) ->
+   ?MYDEBUG("Stoping pgsql backend for ~p", [State#state.vhost]),
+   {stop, normal, ok, State};
+handle_call(Msg, _From, State) ->
+    ?INFO_MSG("Got call Msg: ~p, State: ~p", [Msg, State]),
+    {noreply, State}.
+
+
+handle_cast({rebuild_stats}, State) ->
+    rebuild_all_stats_int(State),
+    {noreply, State};
+handle_cast({drop_user, User}, #state{vhost=VHost, schema=Schema}=State) ->
+    Fun = fun() ->
+            {ok, DBRef} = open_pgsql_connection(State),
+            {ok, Dates} = get_user_stats_int(DBRef, Schema, User, VHost),
+            MDResult = lists:map(fun({Date, _}) ->
+                           delete_all_messages_by_user_at_int(DBRef, Schema, User, VHost, Date)
+                       end, Dates),
+            StDResult = delete_all_stats_by_user_int(DBRef, Schema, User, VHost),
+            SDResult = delete_user_settings_int(DBRef, Schema, User, VHost),
+            case lists:all(fun(Result) when Result == ok ->
+                                true;
+                              (Result) when Result == error ->
+                               false
+                           end, lists:append([MDResult, [StDResult], [SDResult]])) of
+                 true ->
+                   ?INFO_MSG("Removed ~s@~s", [User, VHost]);
+                 false ->
+                   ?ERROR_MSG("Failed to remove ~s@~s", [User, VHost])
+            end,
+            close_pgsql_connection(DBRef)
+          end,
+    spawn(Fun),
+    {noreply, State};
+handle_cast(Msg, State) ->
+    ?INFO_MSG("Got cast Msg:~p, State:~p", [Msg, State]),
+    {noreply, State}.
+
+handle_info({'DOWN', _MonitorRef, process, _Pid, _Info}, State) ->
+    {stop, connection_dropped, State};
+handle_info(Info, State) ->
+    ?INFO_MSG("Got Info:~p, State:~p", [Info, State]),
+    {noreply, State}.
+
+terminate(_Reason, #state{dbref=DBRef}=_State) ->
+    close_pgsql_connection(DBRef),
+    ok.
+
+code_change(_OldVsn, State, _Extra) ->
+    {ok, State}.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% gen_logdb callbacks
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+log_message(VHost, Msg) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {log_message, Msg}, ?CALL_TIMEOUT).
+rebuild_stats(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:cast(Proc, {rebuild_stats}).
+rebuild_stats_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {rebuild_stats_at, Date}, ?CALL_TIMEOUT).
+delete_messages_by_user_at(VHost, Msgs, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_messages_by_user_at, Msgs, Date}, ?CALL_TIMEOUT).
+delete_all_messages_by_user_at(User, VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_all_messages_by_user_at, User, Date}, ?CALL_TIMEOUT).
+delete_messages_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {delete_messages_at, Date}, ?CALL_TIMEOUT).
+get_vhost_stats(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_vhost_stats}, ?CALL_TIMEOUT).
+get_vhost_stats_at(VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_vhost_stats_at, Date}, ?CALL_TIMEOUT).
+get_user_stats(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_stats, User}, ?CALL_TIMEOUT).
+get_user_messages_at(User, VHost, Date) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_messages_at, User, Date}, ?CALL_TIMEOUT).
+get_dates(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_dates}, ?CALL_TIMEOUT).
+get_users_settings(VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_users_settings}, ?CALL_TIMEOUT).
+get_user_settings(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {get_user_settings, User}, ?CALL_TIMEOUT).
+set_user_settings(User, VHost, Set) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:call(Proc, {set_user_settings, User, Set}, ?CALL_TIMEOUT).
+drop_user(User, VHost) ->
+   Proc = gen_mod:get_module_proc(VHost, ?PROCNAME),
+   gen_server:cast(Proc, {drop_user, User}).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+get_dates_int(DBRef, VHost) ->
+    Query = ["SELECT n.nspname as \"Schema\",
+                c.relname as \"Name\",
+                CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' END as \"Type\",
+                r.rolname as \"Owner\"
+              FROM pg_catalog.pg_class c
+                   JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
+                   LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+              WHERE c.relkind IN ('r','')
+                    AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
+                    AND c.relname ~ '^(.*",escape_vhost(VHost),".*)$'
+                    AND pg_catalog.pg_table_is_visible(c.oid)
+              ORDER BY 1,2;"],
+    case sql_query_internal(DBRef, Query) of
+         {data, Recs} ->
+            lists:foldl(fun({_Schema, Table, _Type, _Owner}, Dates) ->
+                             case re:run(Table,"[0-9]+-[0-9]+-[0-9]+") of
+                                  {match, [{S, E}]} ->
+                                      lists:append(Dates, [lists:sublist(Table, S+1, E)]);
+                                  nomatch ->
+                                      Dates
+                             end
+                        end, [], Recs);
+         {error, _} ->
+            []
+    end.
+
+rebuild_all_stats_int(#state{vhost=VHost, schema=Schema}=State) ->
+    Fun = fun() ->
+             {ok, DBRef} = open_pgsql_connection(State),
+             ok = delete_nonexistent_stats(DBRef, Schema, VHost),
+             case lists:filter(fun(Date) ->
+                                 case catch rebuild_stats_at_int(DBRef, VHost, Schema, Date) of
+                                      ok -> false;
+                                      error -> true;
+                                      {'EXIT', _} -> true
+                                 end
+                             end, get_dates_int(DBRef, VHost)) of
+                  [] -> ok;
+                  FTables ->
+                     ?ERROR_MSG("Failed to rebuild stats for ~p dates", [FTables]),
+                     error
+             end,
+             close_pgsql_connection(DBRef)
+          end,
+    spawn(Fun).
+
+rebuild_stats_at_int(DBRef, VHost, Schema, Date) ->
+    TempTable = temp_table(VHost, Schema),
+    Fun =
+      fun() ->
+       Table = messages_table(VHost, Schema, Date),
+       STable = stats_table(VHost, Schema),
+
+       DQuery = [ "DELETE FROM ",STable," ",
+                     "WHERE at='",Date,"';"],
+
+       ok = create_temp_table(DBRef, VHost, Schema),
+       {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",Table," IN ACCESS EXCLUSIVE MODE;"]),
+       {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",TempTable," IN ACCESS EXCLUSIVE MODE;"]),
+       SQuery = ["INSERT INTO ",TempTable," ",
+                  "(owner_id,peer_name_id,peer_server_id,at,count) ",
+                     "SELECT owner_id,peer_name_id,peer_server_id,'",Date,"'",",count(*) ",
+                        "FROM ",Table," GROUP BY owner_id,peer_name_id,peer_server_id;"],
+       case sql_query_internal(DBRef, SQuery) of
+            {updated, 0} ->
+                Count = sql_query_internal(DBRef, ["SELECT count(*) FROM ",Table,";"]),
+                case Count of
+                     {data, [{"0"}]} ->
+                        {updated, _} = sql_query_internal(DBRef, ["DROP VIEW ",view_table(VHost, Schema, Date),";"]),
+                        {updated, _} = sql_query_internal(DBRef, ["DROP TABLE ",Table," CASCADE;"]),
+                        {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",STable," IN ACCESS EXCLUSIVE MODE;"]),
+                        {updated, _} = sql_query_internal(DBRef, DQuery),
+                        ok;
+                     _ ->
+                        ?ERROR_MSG("Failed to calculate stats for ~s table! Count was ~p.", [Date, Count]),
+                        error
+                end;
+            {updated, _} ->
+                {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",STable," IN ACCESS EXCLUSIVE MODE;"]),
+                {updated, _} = sql_query_internal(DBRef, ["LOCK TABLE ",TempTable," IN ACCESS EXCLUSIVE MODE;"]),
+                {updated, _} = sql_query_internal(DBRef, DQuery),
+                SQuery1 = ["INSERT INTO ",STable," ",
+                            "(owner_id,peer_name_id,peer_server_id,at,count) ",
+                               "SELECT owner_id,peer_name_id,peer_server_id,at,count ",
+                                  "FROM ",TempTable,";"],
+                case sql_query_internal(DBRef, SQuery1) of
+                     {updated, _} -> ok;
+                     {error, _} -> error
+                end;
+            {error, _} -> error
+       end
+      end, % fun
+
+    case sql_transaction_internal(DBRef, Fun) of
+         {atomic, _} ->
+            ?INFO_MSG("Rebuilded stats for ~s at ~s", [VHost, Date]),
+            ok;
+         {aborted, Reason} ->
+            ?ERROR_MSG("Failed to rebuild stats for ~s table: ~p.", [Date, Reason]),
+            error
+    end,
+    sql_query_internal(DBRef, ["DROP TABLE ",TempTable,";"]),
+    ok.
+
+delete_nonexistent_stats(DBRef, Schema, VHost) ->
+    Dates = get_dates_int(DBRef, VHost),
+    STable = stats_table(VHost, Schema),
+
+    Temp = lists:flatmap(fun(Date) ->
+                             ["'",Date,"'",","]
+                         end, Dates),
+
+    case Temp of
+         [] ->
+           ok;
+         _ ->
+           % replace last "," with ");"
+           Temp1 = lists:append([lists:sublist(Temp, length(Temp)-1), ");"]),
+           Query = ["DELETE FROM ",STable," ",
+                        "WHERE at NOT IN (", Temp1],
+           case sql_query_internal(DBRef, Query) of
+                {updated, _} ->
+                   ok;
+                {error, _} ->
+                   error
+           end
+    end.
+
+get_user_stats_int(DBRef, Schema, User, VHost) ->
+    SName = stats_table(VHost, Schema),
+    UName = users_table(VHost, Schema),
+    Query = ["SELECT stats.at, sum(stats.count) ",
+                 "FROM ",UName," AS users ",
+                    "JOIN ",SName," AS stats ON owner_id=user_id "
+                 "WHERE users.username='",User,"' ",
+                 "GROUP BY stats.at "
+                 "ORDER BY DATE(at) DESC;"
+             ],
+    case sql_query_internal(DBRef, Query) of
+         {data, Recs} ->
+            {ok, [ {Date, list_to_integer(Count)} || {Date, Count} <- Recs ]};
+         {error, Result} ->
+            {error, Result}
+    end.
+
+delete_all_messages_by_user_at_int(DBRef, Schema, User, VHost, Date) ->
+    DQuery = ["DELETE FROM ",messages_table(VHost, Schema, Date)," ",
+                 "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost, Schema)," WHERE username='",User,"');"],
+    case sql_query_internal(DBRef, DQuery) of
+         {updated, _} ->
+            ?INFO_MSG("Dropped messages for ~s@~s at ~s", [User, VHost, Date]),
+            ok;
+         {error, _} ->
+            error
+    end.
+
+delete_all_stats_by_user_int(DBRef, Schema, User, VHost) ->
+    SQuery = ["DELETE FROM ",stats_table(VHost, Schema)," ",
+                "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost, Schema)," WHERE username='",User,"');"],
+    case sql_query_internal(DBRef, SQuery) of
+         {updated, _} ->
+             ?INFO_MSG("Dropped all stats for ~s@~s", [User, VHost]),
+             ok;
+         {error, _} -> error
+    end.
+
+delete_stats_by_user_at_int(DBRef, Schema, User, VHost, Date) ->
+    SQuery = ["DELETE FROM ",stats_table(VHost, Schema)," ",
+                "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost, Schema)," WHERE username='",User,"') ",
+                  "AND at='",Date,"';"],
+    case sql_query_internal(DBRef, SQuery) of
+         {updated, _} ->
+             ?INFO_MSG("Dropped stats for ~s@~s at ~s", [User, VHost, Date]),
+             ok;
+         {error, _} -> error
+    end.
+
+delete_user_settings_int(DBRef, Schema, User, VHost) ->
+    Query = ["DELETE FROM ",settings_table(VHost, Schema)," ",
+                 "WHERE owner_id=(SELECT user_id FROM ",users_table(VHost, Schema)," WHERE username='",User,"');"],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} ->
+            ?INFO_MSG("Dropped ~s@~s settings", [User, VHost]),
+            ok;
+         {error, Reason} ->
+            ?ERROR_MSG("Failed to drop ~s@~s settings: ~p", [User, VHost, Reason]),
+            error
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% tables internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+create_temp_table(DBRef, VHost, Schema) ->
+    TName =  temp_table(VHost, Schema),
+    Query = ["CREATE TABLE ",TName," (",
+                "owner_id INTEGER, ",
+                "peer_name_id INTEGER, ",
+                "peer_server_id INTEGER, ",
+                "at VARCHAR(20), ",
+                "count INTEGER ",
+             ");"
+            ],
+    case sql_query_internal(DBRef, Query) of
+         {updated, _} -> ok;
+         {error, _Reason} -> error
+    end.
+
+create_stats_table(#state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    SName = stats_table(VHost, Schema),
+
+    Fun =
+      fun() ->
+        Query = ["CREATE TABLE ",SName," (",
+                    "owner_id INTEGER, ",
+                    "peer_name_id INTEGER, ",
+                    "peer_server_id INTEGER, ",
+                    "at VARCHAR(20), ",
+                    "count integer",
+                 ");"
+                ],
+        case sql_query_internal_silent(DBRef, Query) of
+             {updated, _} ->
+                {updated, _} = sql_query_internal(DBRef, ["CREATE INDEX \"s_search_i_",Schema,"_",escape_vhost(VHost),"\" ON ",SName," (owner_id, peer_name_id, peer_server_id);"]),
+                {updated, _} = sql_query_internal(DBRef, ["CREATE INDEX \"s_at_i_",Schema,"_",escape_vhost(VHost),"\" ON ",SName," (at);"]),
+                created;
+             {error, Reason} ->
+                case lists:keysearch(code, 1, Reason) of
+                     {value, {code, "42P07"}} ->
+                         exists;
+                     _ ->
+                         ?ERROR_MSG("Failed to create stats table for ~s: ~p", [VHost, Reason]),
+                         error
+                end
+        end
+      end,
+    case sql_transaction_internal(DBRef, Fun) of
+         {atomic, created} ->
+            ?MYDEBUG("Created stats table for ~s", [VHost]),
+            rebuild_all_stats_int(State),
+            ok;
+         {atomic, exists} ->
+            ?MYDEBUG("Stats table for ~s already exists", [VHost]),
+            {match, [{F, L}]} = re:run(SName, "\".*\""),
+            QTable = lists:sublist(SName, F+2, L-2),
+            OIDQuery = ["SELECT c.oid FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE c.relname='",QTable,"' AND pg_catalog.pg_table_is_visible(c.oid);"],
+            {data,[{OID}]} = sql_query_internal(DBRef, OIDQuery),
+            CheckQuery = ["SELECT a.attname FROM pg_catalog.pg_attribute a  WHERE a.attrelid = '",OID,"' AND a.attnum > 0 AND NOT a.attisdropped AND a.attname ~ '^peer_.*_id$';"],
+            case sql_query_internal(DBRef, CheckQuery) of
+                 {data, Elems} when length(Elems) == 2 ->
+                   ?MYDEBUG("Stats table structure is ok", []),
+                   ok;
+                 _ ->
+                   ?INFO_MSG("It seems like stats table structure is invalid. I will drop it and recreate", []),
+                   case sql_query_internal(DBRef, ["DROP TABLE ",SName,";"]) of
+                        {updated, _} ->
+                          ?INFO_MSG("Successfully dropped ~p", [SName]);
+                        _ ->
+                          ?ERROR_MSG("Failed to drop ~p. You should drop it and restart module", [SName])
+                   end,
+                   error
+            end;
+         {error, _} -> error
+    end.
+
+create_settings_table(#state{dbref=DBRef, vhost=VHost, schema=Schema}) ->
+    SName = settings_table(VHost, Schema),
+    Query = ["CREATE TABLE ",SName," (",
+                "owner_id INTEGER PRIMARY KEY, ",
+                "dolog_default BOOLEAN, ",
+                "dolog_list TEXT DEFAULT '', ",
+                "donotlog_list TEXT DEFAULT ''",
+             ");"
+            ],
+    case sql_query_internal_silent(DBRef, Query) of
+         {updated, _} ->
+            ?MYDEBUG("Created settings table for ~s", [VHost]),
+            ok;
+         {error, Reason} ->
+            case lists:keysearch(code, 1, Reason) of
+                 {value, {code, "42P07"}} ->
+                   ?MYDEBUG("Settings table for ~s already exists", [VHost]),
+                   ok;
+                 _ ->
+                   ?ERROR_MSG("Failed to create settings table for ~s: ~p", [VHost, Reason]),
+                   error
+            end
+    end.
+
+create_users_table(#state{dbref=DBRef, vhost=VHost, schema=Schema}) ->
+    SName = users_table(VHost, Schema),
+
+    Fun =
+      fun() ->
+        Query = ["CREATE TABLE ",SName," (",
+                    "username TEXT UNIQUE, ",
+                    "user_id SERIAL PRIMARY KEY",
+                 ");"
+                ],
+        case sql_query_internal_silent(DBRef, Query) of
+             {updated, _} ->
+                {updated, _} = sql_query_internal(DBRef, ["CREATE INDEX \"username_i_",Schema,"_",escape_vhost(VHost),"\" ON ",SName," (username);"]),
+                created;
+             {error, Reason} ->
+                case lists:keysearch(code, 1, Reason) of
+                     {value, {code, "42P07"}} ->
+                       exists;
+                     _ ->
+                       ?ERROR_MSG("Failed to create users table for ~s: ~p", [VHost, Reason]),
+                       error
+                end
+        end
+      end,
+    case sql_transaction_internal(DBRef, Fun) of
+         {atomic, created} ->
+             ?MYDEBUG("Created users table for ~s", [VHost]),
+             ok;
+         {atomic, exists} ->
+             ?MYDEBUG("Users table for ~s already exists", [VHost]),
+             ok;
+         {aborted, _} -> error
+    end.
+
+create_servers_table(#state{dbref=DBRef, vhost=VHost, schema=Schema}) ->
+    SName = servers_table(VHost, Schema),
+    Fun =
+      fun() ->
+        Query = ["CREATE TABLE ",SName," (",
+                    "server TEXT UNIQUE, ",
+                    "server_id SERIAL PRIMARY KEY",
+                 ");"
+                ],
+        case sql_query_internal_silent(DBRef, Query) of
+             {updated, _} ->
+                {updated, _} = sql_query_internal(DBRef, ["CREATE INDEX \"server_i_",Schema,"_",escape_vhost(VHost),"\" ON ",SName," (server);"]),
+                created;
+             {error, Reason} ->
+                case lists:keysearch(code, 1, Reason) of
+                     {value, {code, "42P07"}} ->
+                       exists;
+                     _ ->
+                       ?ERROR_MSG("Failed to create servers table for ~s: ~p", [VHost, Reason]),
+                       error
+                end
+        end
+      end,
+    case sql_transaction_internal(DBRef, Fun) of
+         {atomic, created} ->
+            ?MYDEBUG("Created servers table for ~s", [VHost]),
+            ok;
+         {atomic, exists} ->
+            ?MYDEBUG("Servers table for ~s already exists", [VHost]),
+            ok;
+         {aborted, _} -> error
+    end.
+
+create_resources_table(#state{dbref=DBRef, vhost=VHost, schema=Schema}) ->
+    RName = resources_table(VHost, Schema),
+    Fun = fun() ->
+            Query = ["CREATE TABLE ",RName," (",
+                     "resource TEXT UNIQUE, ",
+                     "resource_id SERIAL PRIMARY KEY",
+                     ");"
+                    ],
+            case sql_query_internal_silent(DBRef, Query) of
+                 {updated, _} ->
+                    {updated, _} = sql_query_internal(DBRef, ["CREATE INDEX \"resource_i_",Schema,"_",escape_vhost(VHost),"\" ON ",RName," (resource);"]),
+                    created;
+                 {error, Reason} ->
+                    case lists:keysearch(code, 1, Reason) of
+                         {value, {code, "42P07"}} ->
+                           exists;
+                         _ ->
+                           ?ERROR_MSG("Failed to create users table for ~s: ~p", [VHost, Reason]),
+                           error
+                    end
+            end
+          end,
+    case sql_transaction_internal(DBRef, Fun) of
+         {atomic, created} ->
+             ?MYDEBUG("Created resources table for ~s", [VHost]),
+             ok;
+         {atomic, exists} ->
+             ?MYDEBUG("Resources table for ~s already exists", [VHost]),
+             ok;
+         {aborted, _} -> error
+    end.
+
+create_internals(#state{dbref=DBRef, vhost=VHost, schema=Schema}=State) ->
+    sql_query_internal(DBRef, ["DROP FUNCTION IF EXISTS ",logmessage_name(VHost,Schema)," (tbname TEXT, atdt TEXT, owner TEXT, peer_name TEXT, peer_server TEXT, peer_resource TEXT, mdirection VARCHAR(4), mtype VARCHAR(9), msubj TEXT, mbody TEXT, mtimestamp DOUBLE PRECISION);"]),
+    case sql_query_internal(DBRef, [get_logmessage(VHost, Schema)]) of
+         {updated, _} ->
+            ?MYDEBUG("Created logmessage for ~p", [VHost]),
+            ok;
+         {error, Reason} ->
+            case lists:keysearch(code, 1, Reason) of
+                 {value, {code, "42704"}} ->
+                    ?ERROR_MSG("plpgsql language must be installed into database '~s'. Use CREATE LANGUAGE...", [State#state.db]),
+                    error;
+                 _ ->
+                    error
+            end
+    end.
+
+get_user_id(DBRef, VHost, Schema, User) ->
+    SQuery = ["SELECT user_id FROM ",users_table(VHost, Schema)," ",
+                 "WHERE username='",User,"';"],
+    case sql_query_internal(DBRef, SQuery) of
+         {data, []} ->
+             IQuery = ["INSERT INTO ",users_table(VHost, Schema)," ",
+                          "VALUES ('",User,"');"],
+             case sql_query_internal_silent(DBRef, IQuery) of
+                  {updated, _} ->
+                      {data, [{DBIdNew}]} = sql_query_internal(DBRef, SQuery),
+                      DBIdNew;
+                  {error, Reason} ->
+                      % this can be in clustered environment
+                      {value, {code, "23505"}} = lists:keysearch(code, 1, Reason),
+                      ?ERROR_MSG("Duplicate key name for ~p", [User]),
+                      {data, [{ClID}]} = sql_query_internal(DBRef, SQuery),
+                      ClID
+             end;
+         {data, [{DBId}]} ->
+            DBId
+    end.
+
+get_logmessage(VHost,Schema) ->
+    UName = users_table(VHost,Schema),
+    SName = servers_table(VHost,Schema),
+    RName = resources_table(VHost,Schema),
+    StName = stats_table(VHost,Schema),
+    io_lib:format("CREATE OR REPLACE FUNCTION ~s (tbname TEXT, vname TEXT, atdt TEXT, owner TEXT, peer_name TEXT, peer_server TEXT, peer_resource TEXT, mdirection VARCHAR(4), mtype VARCHAR(9), msubj TEXT, mbody TEXT, mtimestamp DOUBLE PRECISION) RETURNS INTEGER AS $$
+DECLARE
+   ownerID INTEGER;
+   peer_nameID INTEGER;
+   peer_serverID INTEGER;
+   peer_resourceID INTEGER;
+   tablename ALIAS for $1;
+   viewname ALIAS for $2;
+   atdate ALIAS for $3;
+BEGIN
+   SELECT INTO ownerID user_id FROM ~s WHERE username = owner;
+   IF NOT FOUND THEN
+      INSERT INTO ~s (username) VALUES (owner);
+      ownerID := lastval();
+   END IF;
+
+   SELECT INTO peer_nameID user_id FROM ~s WHERE username = peer_name;
+   IF NOT FOUND THEN
+      INSERT INTO ~s (username) VALUES (peer_name);
+      peer_nameID := lastval();
+   END IF;
+
+   SELECT INTO peer_serverID server_id FROM ~s WHERE server = peer_server;
+   IF NOT FOUND THEN
+      INSERT INTO ~s (server) VALUES (peer_server);
+      peer_serverID := lastval();
+   END IF;
+
+   SELECT INTO peer_resourceID resource_id FROM ~s WHERE resource = peer_resource;
+   IF NOT FOUND THEN
+      INSERT INTO ~s (resource) VALUES (peer_resource);
+      peer_resourceID := lastval();
+   END IF;
+
+   BEGIN
+      EXECUTE 'INSERT INTO ' || tablename || ' (owner_id, peer_name_id, peer_server_id, peer_resource_id, direction, type, subject, body, timestamp) VALUES (' || ownerID || ',' || peer_nameID || ',' || peer_serverID || ',' || peer_resourceID || ',''' || mdirection || ''',''' || mtype || ''',' || quote_literal(msubj) || ',' || quote_literal(mbody) || ',' || mtimestamp || ')';
+   EXCEPTION WHEN undefined_table THEN
+      EXECUTE 'CREATE TABLE ' || tablename || ' (' ||
+                   'owner_id INTEGER, ' ||
+                   'peer_name_id INTEGER, ' ||
+                   'peer_server_id INTEGER, ' ||
+                   'peer_resource_id INTEGER, ' ||
+                   'direction VARCHAR(4) CHECK (direction IN (''to'',''from'')), ' ||
+                   'type VARCHAR(9) CHECK (type IN (''chat'',''error'',''groupchat'',''headline'',''normal'')), ' ||
+                   'subject TEXT, ' ||
+                   'body TEXT, ' ||
+                   'timestamp DOUBLE PRECISION)';
+      EXECUTE 'CREATE INDEX \"search_i_' || '~s' || '_' || atdate || '_' || '~s' || '\"' || ' ON ' || tablename || ' (owner_id, peer_name_id, peer_server_id, peer_resource_id)';
+
+      EXECUTE 'CREATE OR REPLACE VIEW ' || viewname || ' AS ' ||
+                   'SELECT owner.username AS owner_name, ' ||
+                          'peer.username AS peer_name, ' ||
+                          'servers.server AS peer_server, ' ||
+                          'resources.resource AS peer_resource, ' ||
+                          'messages.direction, ' ||
+                          'messages.type, ' ||
+                          'messages.subject, ' ||
+                          'messages.body, ' ||
+                          'messages.timestamp ' ||
+                   'FROM ' ||
+                          '~s owner, ' ||
+                          '~s peer, ' ||
+                          '~s servers, ' ||
+                          '~s resources, ' ||
+                           tablename || ' messages ' ||
+                   'WHERE ' ||
+                          'owner.user_id=messages.owner_id and ' ||
+                          'peer.user_id=messages.peer_name_id and ' ||
+                          'servers.server_id=messages.peer_server_id and ' ||
+                          'resources.resource_id=messages.peer_resource_id ' ||
+                   'ORDER BY messages.timestamp';
+
+      EXECUTE 'INSERT INTO ' || tablename || ' (owner_id, peer_name_id, peer_server_id, peer_resource_id, direction, type, subject, body, timestamp) VALUES (' || ownerID || ',' || peer_nameID || ',' || peer_serverID || ',' || peer_resourceID || ',''' || mdirection || ''',''' || mtype || ''',' || quote_literal(msubj) || ',' || quote_literal(mbody) || ',' || mtimestamp || ')';
+   END;
+
+   UPDATE ~s SET count=count+1 where at=atdate and owner_id=ownerID and peer_name_id=peer_nameID and peer_server_id=peer_serverID;
+   IF NOT FOUND THEN
+      INSERT INTO ~s (owner_id, peer_name_id, peer_server_id, at, count) VALUES (ownerID, peer_nameID, peer_serverID, atdate, 1);
+   END IF;
+   RETURN 0;
+END;
+$$ LANGUAGE plpgsql;
+", [logmessage_name(VHost,Schema),UName,UName,UName,UName,SName,SName,RName,RName,Schema,escape_vhost(VHost),UName,UName,SName,RName,StName,StName]).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%
+% SQL internals
+%
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% like do_transaction/2 in mysql_conn.erl (changeset by Yariv Sadan <yarivvv@gmail.com>)
+sql_transaction_internal(DBRef, Fun) ->
+    case sql_query_internal(DBRef, ["BEGIN;"]) of
+         {updated, _} ->
+            case catch Fun() of
+                 error = Err ->
+                   rollback_internal(DBRef, Err);
+                 {error, _} = Err ->
+                   rollback_internal(DBRef, Err);
+                 {'EXIT', _} = Err ->
+                   rollback_internal(DBRef, Err);
+                 Res ->
+                   case sql_query_internal(DBRef, ["COMMIT;"]) of
+                        {error, _} -> rollback_internal(DBRef, {commit_error});
+                        {updated, _} ->
+                           case Res of
+                                {atomic, _} -> Res;
+                                _ -> {atomic, Res}
+                           end
+                   end
+            end;
+         {error, _} ->
+            {aborted, {begin_error}}
+    end.
+
+% like rollback/2 in mysql_conn.erl (changeset by Yariv Sadan <yarivvv@gmail.com>)
+rollback_internal(DBRef, Reason) ->
+    Res = sql_query_internal(DBRef, ["ROLLBACK;"]),
+    {aborted, {Reason, {rollback_result, Res}}}.
+
+sql_query_internal(DBRef, Query) ->
+    case sql_query_internal_silent(DBRef, Query) of
+         {error, undefined, Rez} ->
+            ?ERROR_MSG("Got undefined result: ~p while ~p", [Rez, lists:append(Query)]),
+            {error, undefined};
+         {error, Error} ->
+            ?ERROR_MSG("Failed: ~p while ~p", [Error, lists:append(Query)]),
+            {error, Error};
+         Rez -> Rez
+    end.
+
+sql_query_internal_silent(DBRef, Query) ->
+    ?MYDEBUG("DOING: \"~s\"", [lists:append(Query)]),
+    % TODO: use pquery?
+    get_result(pgsql:squery(DBRef, Query)).
+
+get_result({ok, ["CREATE TABLE"]}) ->
+    {updated, 1};
+get_result({ok, ["DROP TABLE"]}) ->
+    {updated, 1};
+get_result({ok, ["ALTER TABLE"]}) ->
+    {updated, 1};
+get_result({ok,["DROP VIEW"]}) ->
+    {updated, 1};
+get_result({ok,["DROP FUNCTION"]}) ->
+    {updated, 1};
+get_result({ok, ["CREATE INDEX"]}) ->
+    {updated, 1};
+get_result({ok, ["CREATE FUNCTION"]}) ->
+    {updated, 1};
+get_result({ok, [{[$S, $E, $L, $E, $C, $T, $  | _Rest], _Rows, Recs}]}) ->
+    Fun = fun(Rec) ->
+              list_to_tuple(
+                  lists:map(fun(Elem) when is_binary(Elem) ->
+                                  binary_to_list(Elem);
+                               (Elem) when is_list(Elem) ->
+                                  Elem;
+                               (Elem) when is_integer(Elem) ->
+                                  integer_to_list(Elem);
+                               (Elem) when is_float(Elem) ->
+                                  float_to_list(Elem);
+                               (Elem) when is_boolean(Elem) ->
+                                  atom_to_list(Elem);
+                               (Elem) ->
+                                  ?ERROR_MSG("Unknown element type ~p", [Elem]),
+                                  Elem
+                            end, Rec))
+          end,
+    Res = lists:map(Fun, Recs),
+    %{data, [list_to_tuple(Rec) || Rec <- Recs]};
+    {data, Res};
+get_result({ok, ["INSERT " ++ OIDN]}) ->
+    [_OID, N] = string:tokens(OIDN, " "),
+    {updated, list_to_integer(N)};
+get_result({ok, ["DELETE " ++ N]}) ->
+    {updated, list_to_integer(N)};
+get_result({ok, ["UPDATE " ++ N]}) ->
+    {updated, list_to_integer(N)};
+get_result({ok, ["BEGIN"]}) ->
+    {updated, 1};
+get_result({ok, ["LOCK TABLE"]}) ->
+    {updated, 1};
+get_result({ok, ["ROLLBACK"]}) ->
+    {updated, 1};
+get_result({ok, ["COMMIT"]}) ->
+    {updated, 1};
+get_result({ok, ["SET"]}) ->
+    {updated, 1};
+get_result({ok, [{error, Error}]}) ->
+    {error, Error};
+get_result(Rez) ->
+    {error, undefined, Rez}.
+
diff --git a/src/mod_muc_room.erl.orig b/src/mod_muc_room.erl.orig
new file mode 100644
index 0000000000..0778cc1577
--- /dev/null
+++ b/src/mod_muc_room.erl.orig
@@ -0,0 +1,4411 @@
+%%%----------------------------------------------------------------------
+%%% File    : mod_muc_room.erl
+%%% Author  : Alexey Shchepin <alexey@process-one.net>
+%%% Purpose : MUC room stuff
+%%% Created : 19 Mar 2003 by Alexey Shchepin <alexey@process-one.net>
+%%%
+%%%
+%%% ejabberd, Copyright (C) 2002-2018   ProcessOne
+%%%
+%%% This program is free software; you can redistribute it and/or
+%%% modify it under the terms of the GNU General Public License as
+%%% published by the Free Software Foundation; either version 2 of the
+%%% License, or (at your option) any later version.
+%%%
+%%% This program is distributed in the hope that it will be useful,
+%%% but WITHOUT ANY WARRANTY; without even the implied warranty of
+%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+%%% General Public License for more details.
+%%%
+%%% You should have received a copy of the GNU General Public License along
+%%% with this program; if not, write to the Free Software Foundation, Inc.,
+%%% 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+%%%
+%%%----------------------------------------------------------------------
+
+-module(mod_muc_room).
+
+-author('alexey@process-one.net').
+
+-behaviour(p1_fsm).
+
+%% External exports
+-export([start_link/10,
+	 start_link/8,
+	 start/10,
+	 start/8,
+	 get_role/2,
+	 get_affiliation/2,
+	 is_occupant_or_admin/2,
+	 route/2,
+	 expand_opts/1,
+	 config_fields/0]).
+
+%% gen_fsm callbacks
+-export([init/1,
+	 normal_state/2,
+	 handle_event/3,
+	 handle_sync_event/4,
+	 handle_info/3,
+	 terminate/3,
+	 code_change/4]).
+
+-include("logger.hrl").
+
+-include("xmpp.hrl").
+
+-include("mod_muc_room.hrl").
+
+-define(MAX_USERS_DEFAULT_LIST,
+	[5, 10, 20, 30, 50, 100, 200, 500, 1000, 2000, 5000]).
+
+-define(DEFAULT_MAX_USERS_PRESENCE,1000).
+
+%-define(DBGFSM, true).
+
+-ifdef(DBGFSM).
+
+-define(FSMOPTS, [{debug, [trace]}]).
+
+-else.
+
+-define(FSMOPTS, []).
+
+-endif.
+
+-type state() :: #state{}.
+-type fsm_stop() :: {stop, normal, state()}.
+-type fsm_next() :: {next_state, normal_state, state()}.
+-type fsm_transition() :: fsm_stop() | fsm_next().
+
+-export_type([state/0]).
+
+-callback set_affiliation(binary(), binary(), binary(), jid(), affiliation(),
+			  binary()) -> ok | {error, any()}.
+-callback set_affiliations(binary(), binary(), binary(),
+			   dict:dict()) -> ok | {error, any()}.
+-callback get_affiliation(binary(), binary(), binary(),
+			  binary(), binary()) -> {ok, affiliation()} | {error, any()}.
+-callback get_affiliations(binary(), binary(), binary()) -> {ok, dict:dict()} | {error, any()}.
+-callback search_affiliation(binary(), binary(), binary(), affiliation()) ->
+    {ok, [{ljid(), {affiliation(), binary()}}]} | {error, any()}.
+
+%%%----------------------------------------------------------------------
+%%% API
+%%%----------------------------------------------------------------------
+start(Host, ServerHost, Access, Room, HistorySize, RoomShaper,
+      Creator, Nick, DefRoomOpts, QueueType) ->
+    p1_fsm:start(?MODULE, [Host, ServerHost, Access, Room, HistorySize,
+			    RoomShaper, Creator, Nick, DefRoomOpts, QueueType],
+		    ?FSMOPTS).
+
+start(Host, ServerHost, Access, Room, HistorySize, RoomShaper, Opts, QueueType) ->
+    p1_fsm:start(?MODULE, [Host, ServerHost, Access, Room, HistorySize,
+			    RoomShaper, Opts, QueueType],
+		    ?FSMOPTS).
+
+start_link(Host, ServerHost, Access, Room, HistorySize, RoomShaper,
+	   Creator, Nick, DefRoomOpts, QueueType) ->
+    p1_fsm:start_link(?MODULE, [Host, ServerHost, Access, Room, HistorySize,
+				 RoomShaper, Creator, Nick, DefRoomOpts, QueueType],
+		       ?FSMOPTS).
+
+start_link(Host, ServerHost, Access, Room, HistorySize, RoomShaper, Opts, QueueType) ->
+    p1_fsm:start_link(?MODULE, [Host, ServerHost, Access, Room, HistorySize,
+				 RoomShaper, Opts, QueueType],
+		       ?FSMOPTS).
+
+%%%----------------------------------------------------------------------
+%%% Callback functions from gen_fsm
+%%%----------------------------------------------------------------------
+
+init([Host, ServerHost, Access, Room, HistorySize,
+      RoomShaper, Creator, _Nick, DefRoomOpts, QueueType]) ->
+    process_flag(trap_exit, true),
+    Shaper = shaper:new(RoomShaper),
+    RoomQueue = room_queue_new(ServerHost, Shaper, QueueType),
+    State = set_affiliation(Creator, owner,
+	    #state{host = Host, server_host = ServerHost,
+		   access = Access, room = Room,
+		   history = lqueue_new(HistorySize, QueueType),
+		   jid = jid:make(Room, Host),
+		   just_created = true,
+		   room_queue = RoomQueue,
+		   room_shaper = Shaper}),
+    State1 = set_opts(DefRoomOpts, State),
+    store_room(State1),
+    ?INFO_MSG("Created MUC room ~s@~s by ~s",
+	      [Room, Host, jid:encode(Creator)]),
+    add_to_log(room_existence, created, State1),
+    add_to_log(room_existence, started, State1),
+    {ok, normal_state, State1};
+init([Host, ServerHost, Access, Room, HistorySize, RoomShaper, Opts, QueueType]) ->
+    process_flag(trap_exit, true),
+    Shaper = shaper:new(RoomShaper),
+    RoomQueue = room_queue_new(ServerHost, Shaper, QueueType),
+    State = set_opts(Opts, #state{host = Host,
+				  server_host = ServerHost,
+				  access = Access,
+				  room = Room,
+				  history = lqueue_new(HistorySize, QueueType),
+				  jid = jid:make(Room, Host),
+				  room_queue = RoomQueue,
+				  room_shaper = Shaper}),
+    add_to_log(room_existence, started, State),
+    {ok, normal_state, State}.
+
+normal_state({route, <<"">>,
+	      #message{from = From, type = Type, lang = Lang} = Packet},
+	     StateData) ->
+    case is_user_online(From, StateData) orelse
+	is_subscriber(From, StateData) orelse
+	is_user_allowed_message_nonparticipant(From, StateData) of
+	true when Type == groupchat ->
+	    Activity = get_user_activity(From, StateData),
+	    Now = p1_time_compat:system_time(micro_seconds),
+	    MinMessageInterval = trunc(gen_mod:get_module_opt(
+					 StateData#state.server_host,
+					 mod_muc, min_message_interval)
+				       * 1000000),
+	    Size = element_size(Packet),
+	    {MessageShaper, MessageShaperInterval} =
+		shaper:update(Activity#activity.message_shaper, Size),
+	    if Activity#activity.message /= undefined ->
+		    ErrText = <<"Traffic rate limit is exceeded">>,
+		    Err = xmpp:err_resource_constraint(ErrText, Lang),
+		    ejabberd_router:route_error(Packet, Err),
+		    {next_state, normal_state, StateData};
+	       Now >= Activity#activity.message_time + MinMessageInterval,
+	       MessageShaperInterval == 0 ->
+		    {RoomShaper, RoomShaperInterval} =
+			shaper:update(StateData#state.room_shaper, Size),
+		    RoomQueueEmpty = case StateData#state.room_queue of
+					 undefined -> true;
+					 RQ -> p1_queue:is_empty(RQ)
+				     end,
+		    if RoomShaperInterval == 0, RoomQueueEmpty ->
+			    NewActivity = Activity#activity{
+					    message_time = Now,
+					    message_shaper = MessageShaper},
+			    StateData1 = store_user_activity(From,
+							     NewActivity,
+							     StateData),
+			    StateData2 = StateData1#state{room_shaper =
+							      RoomShaper},
+			    process_groupchat_message(Packet,
+						      StateData2);
+		       true ->
+			    StateData1 = if RoomQueueEmpty ->
+						 erlang:send_after(RoomShaperInterval,
+								   self(),
+								   process_room_queue),
+						 StateData#state{room_shaper =
+								     RoomShaper};
+					    true -> StateData
+					 end,
+			    NewActivity = Activity#activity{
+					    message_time = Now,
+					    message_shaper = MessageShaper,
+					    message = Packet},
+			    RoomQueue = p1_queue:in({message, From},
+						    StateData#state.room_queue),
+			    StateData2 = store_user_activity(From,
+							     NewActivity,
+							     StateData1),
+			    StateData3 = StateData2#state{room_queue = RoomQueue},
+			    {next_state, normal_state, StateData3}
+		    end;
+	       true ->
+		    MessageInterval = (Activity#activity.message_time +
+					   MinMessageInterval - Now) div 1000,
+		    Interval = lists:max([MessageInterval,
+					  MessageShaperInterval]),
+		    erlang:send_after(Interval, self(),
+				      {process_user_message, From}),
+		    NewActivity = Activity#activity{
+				    message = Packet,
+				    message_shaper = MessageShaper},
+		    StateData1 = store_user_activity(From, NewActivity,	StateData),
+		    {next_state, normal_state, StateData1}
+	    end;
+	true when Type == error ->
+	    case is_user_online(From, StateData) of
+		true ->
+		    ErrorText = <<"It is not allowed to send error messages to the"
+				  " room. The participant (~s) has sent an error "
+				  "message (~s) and got kicked from the room">>,
+		    NewState = expulse_participant(Packet, From, StateData,
+						   translate:translate(Lang,
+								       ErrorText)),
+		    close_room_if_temporary_and_empty(NewState);
+		_ ->
+		    {next_state, normal_state, StateData}
+	    end;
+	true when Type == chat ->
+	    ErrText = <<"It is not allowed to send private messages "
+			"to the conference">>,
+	    Err = xmpp:err_not_acceptable(ErrText, Lang),
+	    ejabberd_router:route_error(Packet, Err),
+	    {next_state, normal_state, StateData};
+	true when Type == normal ->
+	    {next_state, normal_state,
+	     try xmpp:decode_els(Packet) of
+		 Pkt -> process_normal_message(From, Pkt, StateData)
+	     catch _:{xmpp_codec, Why} ->
+		     Txt = xmpp:io_format_error(Why),
+		     Err = xmpp:err_bad_request(Txt, Lang),
+		     ejabberd_router:route_error(Packet, Err),
+		     StateData
+	     end};
+	true ->
+	    ErrText = <<"Improper message type">>,
+	    Err = xmpp:err_not_acceptable(ErrText, Lang),
+	    ejabberd_router:route_error(Packet, Err),
+	    {next_state, normal_state, StateData};
+	false when Type /= error ->
+	    handle_roommessage_from_nonparticipant(Packet, StateData, From),
+	    {next_state, normal_state, StateData};
+	false ->
+	    {next_state, normal_state, StateData}
+    end;
+normal_state({route, <<"">>,
+	      #iq{from = From, type = Type, lang = Lang, sub_els = [_]} = IQ0},
+	     StateData) when Type == get; Type == set ->
+    try
+	case ejabberd_hooks:run_fold(
+	       muc_process_iq,
+	       StateData#state.server_host,
+	       xmpp:set_from_to(xmpp:decode_els(IQ0),
+				From, StateData#state.jid),
+	       [StateData]) of
+	    ignore ->
+		{next_state, normal_state, StateData};
+	    #iq{type = T} = IQRes when T == error; T == result ->
+		ejabberd_router:route(IQRes),
+		{next_state, normal_state, StateData};
+	    #iq{sub_els = [SubEl]} = IQ ->
+		Res1 = case xmpp:get_ns(SubEl) of
+			   ?NS_MUC_ADMIN ->
+			       process_iq_admin(From, IQ, StateData);
+			   ?NS_MUC_OWNER ->
+			       process_iq_owner(From, IQ, StateData);
+			   ?NS_DISCO_INFO ->
+			       process_iq_disco_info(From, IQ, StateData);
+			   ?NS_DISCO_ITEMS ->
+			       process_iq_disco_items(From, IQ, StateData);
+			   ?NS_VCARD ->
+			       process_iq_vcard(From, IQ, StateData);
+			   ?NS_MUCSUB ->
+			       process_iq_mucsub(From, IQ, StateData);
+			   ?NS_CAPTCHA ->
+			       process_iq_captcha(From, IQ, StateData);
+			   _ ->
+			       Txt = <<"The feature requested is not "
+				       "supported by the conference">>,
+			       {error, xmpp:err_service_unavailable(Txt, Lang)}
+		       end,
+		{IQRes, NewStateData} =
+		    case Res1 of
+			{result, Res, SD} ->
+			    {xmpp:make_iq_result(IQ, Res), SD};
+			{result, Res} ->
+			    {xmpp:make_iq_result(IQ, Res), StateData};
+			{ignore, SD} ->
+			    {ignore, SD};
+			{error, Error} ->
+			    {xmpp:make_error(IQ0, Error), StateData}
+		    end,
+		if IQRes /= ignore ->
+			ejabberd_router:route(IQRes);
+		   true ->
+			ok
+		end,
+		case NewStateData of
+		    stop ->
+			{stop, normal, StateData};
+		    _ when NewStateData#state.just_created ->
+			close_room_if_temporary_and_empty(NewStateData);
+		    _ ->
+			{next_state, normal_state, NewStateData}
+		end
+	end
+    catch _:{xmpp_codec, Why} ->
+	    ErrTxt = xmpp:io_format_error(Why),
+	    Err = xmpp:err_bad_request(ErrTxt, Lang),
+	    ejabberd_router:route_error(IQ0, Err),
+	    {next_state, normal_state, StateData}
+    end;
+normal_state({route, <<"">>, #iq{} = IQ}, StateData) ->
+    Err = xmpp:err_bad_request(),
+    ejabberd_router:route_error(IQ, Err),
+    case StateData#state.just_created of
+	true -> {stop, normal, StateData};
+	false -> {next_state, normal_state, StateData}
+    end;
+normal_state({route, Nick, #presence{from = From} = Packet}, StateData) ->
+    Activity = get_user_activity(From, StateData),
+    Now = p1_time_compat:system_time(micro_seconds),
+    MinPresenceInterval =
+	trunc(gen_mod:get_module_opt(StateData#state.server_host,
+				     mod_muc, min_presence_interval)
+	      * 1000000),
+    if (Now >= Activity#activity.presence_time + MinPresenceInterval)
+       and (Activity#activity.presence == undefined) ->
+	    NewActivity = Activity#activity{presence_time = Now},
+	    StateData1 = store_user_activity(From, NewActivity,
+					     StateData),
+	    process_presence(Nick, Packet, StateData1);
+       true ->
+	    if Activity#activity.presence == undefined ->
+		    Interval = (Activity#activity.presence_time +
+				    MinPresenceInterval - Now) div 1000,
+		    erlang:send_after(Interval, self(),
+				      {process_user_presence, From});
+	       true -> ok
+	    end,
+	    NewActivity = Activity#activity{presence = {Nick, Packet}},
+	    StateData1 = store_user_activity(From, NewActivity,
+					     StateData),
+	    {next_state, normal_state, StateData1}
+    end;
+normal_state({route, ToNick,
+	      #message{from = From, type = Type, lang = Lang} = Packet},
+	     StateData) ->
+    case decide_fate_message(Packet, From, StateData) of
+	{expulse_sender, Reason} ->
+	    ?DEBUG(Reason, []),
+	    ErrorText = <<"It is not allowed to send error messages to the"
+			  " room. The participant (~s) has sent an error "
+			  "message (~s) and got kicked from the room">>,
+	    NewState = expulse_participant(Packet, From, StateData,
+					   translate:translate(Lang, ErrorText)),
+	    {next_state, normal_state, NewState};
+	forget_message ->
+	    {next_state, normal_state, StateData};
+	continue_delivery ->
+	    case {(StateData#state.config)#config.allow_private_messages,
+		  is_user_online(From, StateData) orelse
+		  is_subscriber(From, StateData)} of
+		{true, true} when Type == groupchat ->
+		    ErrText = <<"It is not allowed to send private messages "
+				"of type \"groupchat\"">>,
+		    Err = xmpp:err_bad_request(ErrText, Lang),
+		    ejabberd_router:route_error(Packet, Err);
+		{true, true} ->
+		    case find_jids_by_nick(ToNick, StateData) of
+			[] ->
+			    ErrText = <<"Recipient is not in the conference room">>,
+			    Err = xmpp:err_item_not_found(ErrText, Lang),
+			    ejabberd_router:route_error(Packet, Err);
+			ToJIDs ->
+			    SrcIsVisitor = is_visitor(From, StateData),
+			    DstIsModerator = is_moderator(hd(ToJIDs), StateData),
+			    PmFromVisitors =
+				(StateData#state.config)#config.allow_private_messages_from_visitors,
+			    if SrcIsVisitor == false;
+			       PmFromVisitors == anyone;
+			       (PmFromVisitors == moderators) and
+			       DstIsModerator ->
+				   {FromNick, _} = get_participant_data(From, StateData),
+				    FromNickJID =
+					jid:replace_resource(StateData#state.jid,
+							     FromNick),
+				    X = #muc_user{},
+				    PrivMsg = xmpp:set_from(
+						xmpp:set_subtag(Packet, X),
+						FromNickJID),
+				    [ejabberd_router:route(xmpp:set_to(PrivMsg, ToJID))
+				     || ToJID <- ToJIDs];
+			       true ->
+				    ErrText = <<"It is not allowed to send private messages">>,
+				    Err = xmpp:err_forbidden(ErrText, Lang),
+				    ejabberd_router:route_error(Packet, Err)
+			    end
+		    end;
+		{true, false} ->
+		    ErrText = <<"Only occupants are allowed to send messages "
+				"to the conference">>,
+		    Err = xmpp:err_not_acceptable(ErrText, Lang),
+		    ejabberd_router:route_error(Packet, Err);
+		{false, _} ->
+		    ErrText = <<"It is not allowed to send private messages">>,
+		    Err = xmpp:err_forbidden(ErrText, Lang),
+		    ejabberd_router:route_error(Packet, Err)
+	    end,
+	  {next_state, normal_state, StateData}
+    end;
+normal_state({route, ToNick,
+	      #iq{from = From, type = Type, lang = Lang} = Packet},
+	     StateData) ->
+    case {(StateData#state.config)#config.allow_query_users,
+	  (?DICT):find(jid:tolower(From), StateData#state.users)} of
+	{true, {ok, #user{nick = FromNick}}} ->
+	    case find_jid_by_nick(ToNick, StateData) of
+		false ->
+		    ErrText = <<"Recipient is not in the conference room">>,
+		    Err = xmpp:err_item_not_found(ErrText, Lang),
+		    ejabberd_router:route_error(Packet, Err);
+		To ->
+		    FromJID = jid:replace_resource(StateData#state.jid, FromNick),
+		    if Type == get; Type == set ->
+			    ToJID = case is_vcard_request(Packet) of
+					true -> jid:remove_resource(To);
+					false -> To
+				    end,
+			    ejabberd_router:route_iq(
+			      xmpp:set_from_to(Packet, FromJID, ToJID), Packet, self());
+		       true ->
+			    ejabberd_router:route(
+			      xmpp:set_from_to(Packet, FromJID, To))
+		    end
+	    end;
+	{true, error} ->
+	    ErrText = <<"Only occupants are allowed to send queries "
+			"to the conference">>,
+	    Err = xmpp:err_not_acceptable(ErrText, Lang),
+	    ejabberd_router:route_error(Packet, Err);
+	_ ->
+	    ErrText = <<"Queries to the conference members are "
+			"not allowed in this room">>,
+	    Err = xmpp:err_not_allowed(ErrText, Lang),
+	    ejabberd_router:route_error(Packet, Err)
+    end,
+    {next_state, normal_state, StateData};
+normal_state(_Event, StateData) ->
+    {next_state, normal_state, StateData}.
+
+handle_event({service_message, Msg}, _StateName,
+	     StateData) ->
+    MessagePkt = #message{type = groupchat, body = xmpp:mk_text(Msg)},
+    send_wrapped_multiple(
+      StateData#state.jid,
+      get_users_and_subscribers(StateData),
+      MessagePkt,
+      ?NS_MUCSUB_NODES_MESSAGES,
+      StateData),
+    NSD = add_message_to_history(<<"">>,
+				 StateData#state.jid, MessagePkt, StateData),
+    {next_state, normal_state, NSD};
+handle_event({destroy, Reason}, _StateName,
+	     StateData) ->
+    {result, undefined, stop} =
+	destroy_room(#muc_destroy{xmlns = ?NS_MUC_OWNER, reason = Reason},
+		     StateData),
+    ?INFO_MSG("Destroyed MUC room ~s with reason: ~p",
+	      [jid:encode(StateData#state.jid), Reason]),
+    add_to_log(room_existence, destroyed, StateData),
+    {stop, shutdown, StateData};
+handle_event(destroy, StateName, StateData) ->
+    ?INFO_MSG("Destroyed MUC room ~s",
+	      [jid:encode(StateData#state.jid)]),
+    handle_event({destroy, <<"">>}, StateName, StateData);
+handle_event({set_affiliations, Affiliations},
+	     StateName, StateData) ->
+    NewStateData = set_affiliations(Affiliations, StateData),
+    {next_state, StateName, NewStateData};
+handle_event(_Event, StateName, StateData) ->
+    {next_state, StateName, StateData}.
+
+handle_sync_event({get_disco_item, Filter, JID, Lang}, _From, StateName, StateData) ->
+    Len = ?DICT:size(StateData#state.nicks),
+    Reply = case (Filter == all) or (Filter == Len) or ((Filter /= 0) and (Len /= 0)) of
+	true ->
+	    get_roomdesc_reply(JID, StateData,
+			       get_roomdesc_tail(StateData, Lang));
+	false ->
+	    false
+    end,
+    {reply, Reply, StateName, StateData};
+%% This clause is only for backwards compatibility
+handle_sync_event({get_disco_item, JID, Lang}, From, StateName, StateData) ->
+    handle_sync_event({get_disco_item, any, JID, Lang}, From, StateName, StateData);
+handle_sync_event(get_config, _From, StateName,
+		  StateData) ->
+    {reply, {ok, StateData#state.config}, StateName,
+     StateData};
+handle_sync_event(get_state, _From, StateName,
+		  StateData) ->
+    {reply, {ok, StateData}, StateName, StateData};
+handle_sync_event({change_config, Config}, _From,
+		  StateName, StateData) ->
+    {result, undefined, NSD} = change_config(Config, StateData),
+    {reply, {ok, NSD#state.config}, StateName, NSD};
+handle_sync_event({change_state, NewStateData}, _From,
+		  StateName, _StateData) ->
+    {reply, {ok, NewStateData}, StateName, NewStateData};
+handle_sync_event({process_item_change, Item, UJID}, _From, StateName, StateData) ->
+    case process_item_change(Item, StateData, UJID) of
+	{error, _} = Err ->
+	    {reply, Err, StateName, StateData};
+	NSD ->
+	    {reply, {ok, NSD}, StateName, NSD}
+    end;
+handle_sync_event(get_subscribers, _From, StateName, StateData) ->
+    JIDs = lists:map(fun jid:make/1,
+		     ?DICT:fetch_keys(StateData#state.subscribers)),
+    {reply, {ok, JIDs}, StateName, StateData};
+handle_sync_event({muc_subscribe, From, Nick, Nodes}, _From,
+		  StateName, StateData) ->
+    IQ = #iq{type = set, id = randoms:get_string(),
+	     from = From, sub_els = [#muc_subscribe{nick = Nick,
+						    events = Nodes}]},
+    Config = StateData#state.config,
+    CaptchaRequired = Config#config.captcha_protected,
+    PasswordProtected = Config#config.password_protected,
+    TmpConfig = Config#config{captcha_protected = false,
+			       password_protected = false},
+    TmpState = StateData#state{config = TmpConfig},
+    case process_iq_mucsub(From, IQ, TmpState) of
+	{result, #muc_subscribe{events = NewNodes}, NewState} ->
+	    NewConfig = (NewState#state.config)#config{
+			  captcha_protected = CaptchaRequired,
+			  password_protected = PasswordProtected},
+	    {reply, {ok, NewNodes}, StateName,
+	     NewState#state{config = NewConfig}};
+	{ignore, NewState} ->
+	    NewConfig = (NewState#state.config)#config{
+			  captcha_protected = CaptchaRequired,
+			  password_protected = PasswordProtected},
+	    {reply, {error, <<"Request is ignored">>},
+	     NewState#state{config = NewConfig}};
+	{error, Err} ->
+	    {reply, {error, get_error_text(Err)}, StateName, StateData}
+    end;
+handle_sync_event({muc_unsubscribe, From}, _From, StateName, StateData) ->
+    IQ = #iq{type = set, id = randoms:get_string(),
+	     from = From, sub_els = [#muc_unsubscribe{}]},
+    case process_iq_mucsub(From, IQ, StateData) of
+	{result, _, NewState} ->
+	    {reply, ok, StateName, NewState};
+	{ignore, NewState} ->
+	    {reply, {error, <<"Request is ignored">>}, NewState};
+	{error, Err} ->
+	    {reply, {error, get_error_text(Err)}, StateName, StateData}
+    end;
+handle_sync_event({is_subscribed, From}, _From, StateName, StateData) ->
+    IsSubs = ?DICT:is_key(jid:split(From), StateData#state.subscribers),
+    {reply, IsSubs, StateName, StateData};
+handle_sync_event(_Event, _From, StateName,
+		  StateData) ->
+    Reply = ok, {reply, Reply, StateName, StateData}.
+
+code_change(_OldVsn, StateName, StateData, _Extra) ->
+    {ok, StateName, StateData}.
+
+handle_info({process_user_presence, From}, normal_state = _StateName, StateData) ->
+    RoomQueueEmpty = p1_queue:is_empty(StateData#state.room_queue),
+    RoomQueue = p1_queue:in({presence, From}, StateData#state.room_queue),
+    StateData1 = StateData#state{room_queue = RoomQueue},
+    if RoomQueueEmpty ->
+	   StateData2 = prepare_room_queue(StateData1),
+	   {next_state, normal_state, StateData2};
+       true -> {next_state, normal_state, StateData1}
+    end;
+handle_info({process_user_message, From},
+	    normal_state = _StateName, StateData) ->
+    RoomQueueEmpty =
+	p1_queue:is_empty(StateData#state.room_queue),
+    RoomQueue = p1_queue:in({message, From},
+			    StateData#state.room_queue),
+    StateData1 = StateData#state{room_queue = RoomQueue},
+    if RoomQueueEmpty ->
+	   StateData2 = prepare_room_queue(StateData1),
+	   {next_state, normal_state, StateData2};
+       true -> {next_state, normal_state, StateData1}
+    end;
+handle_info(process_room_queue,
+	    normal_state = StateName, StateData) ->
+    case p1_queue:out(StateData#state.room_queue) of
+      {{value, {message, From}}, RoomQueue} ->
+	  Activity = get_user_activity(From, StateData),
+	  Packet = Activity#activity.message,
+	  NewActivity = Activity#activity{message = undefined},
+	  StateData1 = store_user_activity(From, NewActivity,
+					   StateData),
+	  StateData2 = StateData1#state{room_queue = RoomQueue},
+	  StateData3 = prepare_room_queue(StateData2),
+	  process_groupchat_message(Packet, StateData3);
+      {{value, {presence, From}}, RoomQueue} ->
+	  Activity = get_user_activity(From, StateData),
+	  {Nick, Packet} = Activity#activity.presence,
+	  NewActivity = Activity#activity{presence = undefined},
+	  StateData1 = store_user_activity(From, NewActivity,
+					   StateData),
+	  StateData2 = StateData1#state{room_queue = RoomQueue},
+	  StateData3 = prepare_room_queue(StateData2),
+	  process_presence(Nick, Packet, StateData3);
+      {empty, _} -> {next_state, StateName, StateData}
+    end;
+handle_info({captcha_succeed, From}, normal_state,
+	    StateData) ->
+    NewState = case (?DICT):find(From,
+				 StateData#state.robots)
+		   of
+		 {ok, {Nick, Packet}} ->
+		     Robots = (?DICT):store(From, passed,
+					    StateData#state.robots),
+		     add_new_user(From, Nick, Packet,
+				  StateData#state{robots = Robots});
+		 _ -> StateData
+	       end,
+    {next_state, normal_state, NewState};
+handle_info({captcha_failed, From}, normal_state,
+	    StateData) ->
+    NewState = case (?DICT):find(From,
+				 StateData#state.robots)
+		   of
+		 {ok, {_Nick, Packet}} ->
+		     Robots = (?DICT):erase(From, StateData#state.robots),
+		     Txt = <<"The CAPTCHA verification has failed">>,
+		     Lang = xmpp:get_lang(Packet),
+		     Err = xmpp:err_not_authorized(Txt, Lang),
+		     ejabberd_router:route_error(Packet, Err),
+		     StateData#state{robots = Robots};
+		 _ -> StateData
+	       end,
+    {next_state, normal_state, NewState};
+handle_info(shutdown, _StateName, StateData) ->
+    {stop, shutdown, StateData};
+handle_info({iq_reply, #iq{type = Type, sub_els = Els},
+	     #iq{from = From, to = To} = IQ}, StateName, StateData) ->
+    ejabberd_router:route(
+      xmpp:set_from_to(
+	IQ#iq{type = Type, sub_els = Els},
+	To, From)),
+    {next_state, StateName, StateData};
+handle_info({iq_reply, timeout, IQ}, StateName, StateData) ->
+    Txt = <<"Request has timed out">>,
+    Err = xmpp:err_recipient_unavailable(Txt, IQ#iq.lang),
+    ejabberd_router:route_error(IQ, Err),
+    {next_state, StateName, StateData};
+handle_info(_Info, StateName, StateData) ->
+    {next_state, StateName, StateData}.
+
+terminate(Reason, _StateName, StateData) ->
+    ?INFO_MSG("Stopping MUC room ~s@~s",
+	      [StateData#state.room, StateData#state.host]),
+    ReasonT = case Reason of
+		shutdown ->
+		    <<"You are being removed from the room "
+		      "because of a system shutdown">>;
+		_ -> <<"Room terminates">>
+	      end,
+    Packet = #presence{
+		type = unavailable,
+		sub_els = [#muc_user{items = [#muc_item{affiliation = none,
+							reason = ReasonT,
+							role = none}],
+				     status_codes = [332,110]}]},
+    (?DICT):fold(fun (LJID, Info, _) ->
+			 Nick = Info#user.nick,
+			 case Reason of
+			   shutdown ->
+			       send_wrapped(jid:replace_resource(StateData#state.jid,
+								 Nick),
+					    Info#user.jid, Packet,
+					    ?NS_MUCSUB_NODES_PARTICIPANTS,
+					    StateData);
+			   _ -> ok
+			 end,
+			 tab_remove_online_user(LJID, StateData)
+		 end,
+		 [], get_users_and_subscribers(StateData)),
+    add_to_log(room_existence, stopped, StateData),
+    mod_muc:room_destroyed(StateData#state.host, StateData#state.room, self(),
+			   StateData#state.server_host),
+    ok.
+
+%%%----------------------------------------------------------------------
+%%% Internal functions
+%%%----------------------------------------------------------------------
+-spec route(pid(), stanza()) -> ok.
+route(Pid, Packet) ->
+    #jid{lresource = Nick} = xmpp:get_to(Packet),
+    p1_fsm:send_event(Pid, {route, Nick, Packet}).
+
+-spec process_groupchat_message(message(), state()) -> fsm_next().
+process_groupchat_message(#message{from = From, lang = Lang} = Packet, StateData) ->
+    IsSubscriber = is_subscriber(From, StateData),
+    case is_user_online(From, StateData) orelse IsSubscriber orelse
+	   is_user_allowed_message_nonparticipant(From, StateData)
+	of
+      true ->
+	  {FromNick, Role} = get_participant_data(From, StateData),
+	  if (Role == moderator) or (Role == participant) or IsSubscriber or
+	       ((StateData#state.config)#config.moderated == false) ->
+		 Subject = check_subject(Packet),
+		 {NewStateData1, IsAllowed} = case Subject of
+						[] -> {StateData, true};
+						_ ->
+						    case
+						      can_change_subject(Role,
+									 IsSubscriber,
+									 StateData)
+							of
+						      true ->
+							  NSD =
+							      StateData#state{subject
+										  =
+										  Subject,
+									      subject_author
+										  =
+										  FromNick},
+							  store_room(NSD),
+							  {NSD, true};
+						      _ -> {StateData, false}
+						    end
+					      end,
+		 case IsAllowed of
+		   true ->
+		       case
+			 ejabberd_hooks:run_fold(muc_filter_message,
+						 StateData#state.server_host,
+						 Packet,
+						 [StateData, FromNick])
+			   of
+			 drop ->
+			     {next_state, normal_state, StateData};
+			 NewPacket1 ->
+			     NewPacket = xmpp:remove_subtag(NewPacket1, #nick{}),
+			     Node = if Subject == [] -> ?NS_MUCSUB_NODES_MESSAGES;
+				       true -> ?NS_MUCSUB_NODES_SUBJECT
+				    end,
+			     send_wrapped_multiple(
+			       jid:replace_resource(StateData#state.jid, FromNick),
+			       get_users_and_subscribers(StateData),
+			       NewPacket, Node, NewStateData1),
+			     NewStateData2 = case has_body_or_subject(NewPacket) of
+					       true ->
+						   add_message_to_history(FromNick, From,
+									  NewPacket,
+									  NewStateData1);
+					       false ->
+						   NewStateData1
+					     end,
+			     {next_state, normal_state, NewStateData2}
+		       end;
+		   _ ->
+		       Err = case (StateData#state.config)#config.allow_change_subj of
+			       true ->
+				   xmpp:err_forbidden(
+				     <<"Only moderators and participants are "
+				       "allowed to change the subject in this "
+				       "room">>, Lang);
+			       _ ->
+				   xmpp:err_forbidden(
+				     <<"Only moderators are allowed to change "
+				       "the subject in this room">>, Lang)
+			     end,
+		       ejabberd_router:route_error(Packet, Err),
+		       {next_state, normal_state, StateData}
+		 end;
+	     true ->
+		 ErrText = <<"Visitors are not allowed to send messages "
+			     "to all occupants">>,
+		 Err = xmpp:err_forbidden(ErrText, Lang),
+		 ejabberd_router:route_error(Packet, Err),
+		 {next_state, normal_state, StateData}
+	  end;
+      false ->
+	  ErrText = <<"Only occupants are allowed to send messages "
+		      "to the conference">>,
+	  Err = xmpp:err_not_acceptable(ErrText, Lang),
+	  ejabberd_router:route_error(Packet, Err),
+	  {next_state, normal_state, StateData}
+    end.
+
+-spec process_normal_message(jid(), message(), state()) -> state().
+process_normal_message(From, #message{lang = Lang} = Pkt, StateData) ->
+    Action = lists:foldl(
+	       fun(_, {error, _} = Err) ->
+		       Err;
+		  (_, {ok, _} = Result) ->
+		       Result;
+		  (#muc_user{invites = [_|_] = Invites}, _) ->
+		       case check_invitation(From, Invites, Lang, StateData) of
+			   ok ->
+			       {ok, Invites};
+			   {error, _} = Err ->
+			       Err
+		       end;
+		  (#xdata{type = submit, fields = Fs}, _) ->
+		       try {ok, muc_request:decode(Fs)}
+		       catch _:{muc_request, Why} ->
+			       Txt = muc_request:format_error(Why),
+			       {error, xmpp:err_bad_request(Txt, Lang)}
+		       end;
+		  (_, Acc) ->
+		       Acc
+	       end, ok, xmpp:get_els(Pkt)),
+    case Action of
+	{ok, [#muc_invite{}|_] = Invitations} ->
+	    lists:foldl(
+	      fun(Invitation, AccState) ->
+		      process_invitation(From, Invitation, Lang, AccState)
+	      end, StateData, Invitations);
+	{ok, [{role, participant}]} ->
+	    process_voice_request(From, Pkt, StateData);
+	{ok, VoiceApproval} ->
+	    process_voice_approval(From, Pkt, VoiceApproval, StateData);
+	{error, Err} ->
+	    ejabberd_router:route_error(Pkt, Err),
+	    StateData;
+	ok ->
+	    StateData
+    end.
+
+-spec process_invitation(jid(), muc_invite(), binary(), state()) -> state().
+process_invitation(From, Invitation, Lang, StateData) ->
+    IJID = route_invitation(From, Invitation, Lang, StateData),
+    Config = StateData#state.config,
+    case Config#config.members_only of
+	true ->
+	    case get_affiliation(IJID, StateData) of
+		none ->
+		    NSD = set_affiliation(IJID, member, StateData),
+		    send_affiliation(IJID, member, StateData),
+		    store_room(NSD),
+		    NSD;
+		_ ->
+		    StateData
+	    end;
+	false ->
+	    StateData
+    end.
+
+-spec process_voice_request(jid(), message(), state()) -> state().
+process_voice_request(From, Pkt, StateData) ->
+    Lang = xmpp:get_lang(Pkt),
+    case (StateData#state.config)#config.allow_voice_requests of
+	true ->
+	    MinInterval = (StateData#state.config)#config.voice_request_min_interval,
+	    BareFrom = jid:remove_resource(jid:tolower(From)),
+	    NowPriority = -p1_time_compat:system_time(micro_seconds),
+	    CleanPriority = NowPriority + MinInterval * 1000000,
+	    Times = clean_treap(StateData#state.last_voice_request_time,
+				CleanPriority),
+	    case treap:lookup(BareFrom, Times) of
+		error ->
+		    Times1 = treap:insert(BareFrom,
+					  NowPriority,
+					  true, Times),
+		    NSD = StateData#state{last_voice_request_time = Times1},
+		    send_voice_request(From, Lang, NSD),
+		    NSD;
+		{ok, _, _} ->
+		    ErrText = <<"Please, wait for a while before sending "
+				"new voice request">>,
+		    Err = xmpp:err_resource_constraint(ErrText, Lang),
+		    ejabberd_router:route_error(Pkt, Err),
+		    StateData#state{last_voice_request_time = Times}
+	    end;
+	false ->
+	    ErrText = <<"Voice requests are disabled in this conference">>,
+	    Err = xmpp:err_forbidden(ErrText, Lang),
+	    ejabberd_router:route_error(Pkt, Err),
+	    StateData
+    end.
+
+-spec process_voice_approval(jid(), message(), [muc_request:property()], state()) -> state().
+process_voice_approval(From, Pkt, VoiceApproval, StateData) ->
+    Lang = xmpp:get_lang(Pkt),
+    case is_moderator(From, StateData) of
+	true ->
+	    case lists:keyfind(jid, 1, VoiceApproval) of
+		{_, TargetJid} ->
+		    Allow = proplists:get_bool(request_allow, VoiceApproval),
+		    case is_visitor(TargetJid, StateData) of
+			true when Allow ->
+			    Reason = <<>>,
+			    NSD = set_role(TargetJid, participant, StateData),
+			    catch send_new_presence(
+				    TargetJid, Reason, NSD, StateData),
+			    NSD;
+			_ ->
+			    StateData
+		    end;
+		false ->
+		    ErrText = <<"Failed to extract JID from your voice "
+				"request approval">>,
+		    Err = xmpp:err_bad_request(ErrText, Lang),
+		    ejabberd_router:route_error(Pkt, Err),
+		    StateData
+	    end;
+	false ->
+	    ErrText = <<"Only moderators can approve voice requests">>,
+	    Err = xmpp:err_not_allowed(ErrText, Lang),
+	    ejabberd_router:route_error(Pkt, Err),
+	    StateData
+    end.
+
+-spec is_vcard_request(iq()) -> boolean().
+is_vcard_request(#iq{type = T, sub_els = [El]}) ->
+    (T == get orelse T == set) andalso xmpp:get_ns(El) == ?NS_VCARD;
+is_vcard_request(_) ->
+    false.
+
+%% @doc Check if this non participant can send message to room.
+%%
+%% XEP-0045 v1.23:
+%% 7.9 Sending a Message to All Occupants
+%% an implementation MAY allow users with certain privileges
+%% (e.g., a room owner, room admin, or service-level admin)
+%% to send messages to the room even if those users are not occupants.
+-spec is_user_allowed_message_nonparticipant(jid(), state()) -> boolean().
+is_user_allowed_message_nonparticipant(JID,
+				       StateData) ->
+    case get_service_affiliation(JID, StateData) of
+      owner -> true;
+      _ -> false
+    end.
+
+%% @doc Get information of this participant, or default values.
+%% If the JID is not a participant, return values for a service message.
+-spec get_participant_data(jid(), state()) -> {binary(), role()}.
+get_participant_data(From, StateData) ->
+    case (?DICT):find(jid:tolower(From),
+		      StateData#state.users)
+	of
+      {ok, #user{nick = FromNick, role = Role}} ->
+	  {FromNick, Role};
+      error ->
+	    case ?DICT:find(jid:tolower(jid:remove_resource(From)),
+			    StateData#state.subscribers) of
+		{ok, #subscriber{nick = FromNick}} ->
+		    {FromNick, none};
+		error ->
+		    {<<"">>, moderator}
+	    end
+    end.
+
+-spec process_presence(binary(), presence(), state()) -> fsm_transition().
+process_presence(Nick, #presence{from = From, type = Type0} = Packet0, StateData) ->
+    IsOnline = is_user_online(From, StateData),
+    if Type0 == available;
+       IsOnline and ((Type0 == unavailable) or (Type0 == error)) ->
+	   case ejabberd_hooks:run_fold(muc_filter_presence,
+					StateData#state.server_host,
+					Packet0,
+					[StateData, Nick]) of
+	     drop ->
+		 {next_state, normal_state, StateData};
+	     #presence{} = Packet ->
+		 close_room_if_temporary_and_empty(
+		   do_process_presence(Nick, Packet, StateData))
+	   end;
+       true ->
+	    {next_state, normal_state, StateData}
+    end.
+
+-spec do_process_presence(binary(), presence(), state()) -> state().
+do_process_presence(Nick, #presence{from = From, type = available, lang = Lang} = Packet,
+		    StateData) ->
+    case is_user_online(From, StateData) of
+	false ->
+	    add_new_user(From, Nick, Packet, StateData);
+	true ->
+	    case is_nick_change(From, Nick, StateData) of
+		true ->
+		    case {nick_collision(From, Nick, StateData),
+			  mod_muc:can_use_nick(StateData#state.server_host,
+					       StateData#state.host,
+					       From, Nick),
+			  {(StateData#state.config)#config.allow_visitor_nickchange,
+			   is_visitor(From, StateData)}} of
+			{_, _, {false, true}} ->
+			    Packet1 = Packet#presence{sub_els = [#muc{}]},
+			    ErrText = <<"Visitors are not allowed to change their "
+					"nicknames in this room">>,
+			    Err = xmpp:err_not_allowed(ErrText, Lang),
+			    ejabberd_router:route_error(Packet1, Err),
+			    StateData;
+			{true, _, _} ->
+			    Packet1 = Packet#presence{sub_els = [#muc{}]},
+			    ErrText = <<"That nickname is already in use by another "
+					"occupant">>,
+			    Err = xmpp:err_conflict(ErrText, Lang),
+			    ejabberd_router:route_error(Packet1, Err),
+			    StateData;
+			{_, false, _} ->
+			    Packet1 = Packet#presence{sub_els = [#muc{}]},
+			    ErrText = <<"That nickname is registered by another "
+					"person">>,
+			    Err = xmpp:err_conflict(ErrText, Lang),
+			    ejabberd_router:route_error(Packet1, Err),
+			    StateData;
+			_ ->
+				    change_nick(From, Nick, StateData)
+		    end;
+		false ->
+		    Stanza = maybe_strip_status_from_presence(
+			       From, Packet, StateData),
+		    NewState = add_user_presence(From, Stanza,
+						 StateData),
+		    case xmpp:has_subtag(Packet, #muc{}) of
+			true ->
+			    send_initial_presences_and_messages(
+			      From, Nick, Packet, NewState, StateData);
+			false ->
+			    send_new_presence(From, NewState, StateData)
+		    end,
+		    NewState
+	    end
+    end;
+do_process_presence(Nick, #presence{from = From, type = unavailable} = Packet,
+		    StateData) ->
+    NewPacket = case {(StateData#state.config)#config.allow_visitor_status,
+		      is_visitor(From, StateData)} of
+		    {false, true} ->
+			strip_status(Packet);
+		    _ -> Packet
+		end,
+    NewState = add_user_presence_un(From, NewPacket, StateData),
+    case (?DICT):find(Nick, StateData#state.nicks) of
+	{ok, [_, _ | _]} ->
+	    Aff = get_affiliation(From, StateData),
+	    Item = #muc_item{affiliation = Aff, role = none, jid = From},
+	    Pres = xmpp:set_subtag(
+		     Packet, #muc_user{items = [Item],
+				       status_codes = [110]}),
+	    send_wrapped(jid:replace_resource(StateData#state.jid, Nick),
+			 From, Pres, ?NS_MUCSUB_NODES_PRESENCE, StateData);
+	_ ->
+	    send_new_presence(From, NewState, StateData)
+    end,
+    Reason = xmpp:get_text(NewPacket#presence.status),
+    remove_online_user(From, NewState, Reason);
+do_process_presence(_Nick, #presence{from = From, type = error, lang = Lang} = Packet,
+		    StateData) ->
+    ErrorText = <<"It is not allowed to send error messages to the"
+		  " room. The participant (~s) has sent an error "
+		  "message (~s) and got kicked from the room">>,
+    expulse_participant(Packet, From, StateData,
+			translate:translate(Lang, ErrorText)).
+
+-spec maybe_strip_status_from_presence(jid(), presence(),
+				       state()) -> presence().
+maybe_strip_status_from_presence(From, Packet, StateData) ->
+    case {(StateData#state.config)#config.allow_visitor_status,
+	  is_visitor(From, StateData)} of
+	{false, true} ->
+	    strip_status(Packet);
+	_Allowed -> Packet
+    end.
+
+-spec close_room_if_temporary_and_empty(state()) -> fsm_transition().
+close_room_if_temporary_and_empty(StateData1) ->
+    case not (StateData1#state.config)#config.persistent
+	andalso (?DICT):size(StateData1#state.users) == 0
+	andalso (?DICT):size(StateData1#state.subscribers) == 0 of
+      true ->
+	  ?INFO_MSG("Destroyed MUC room ~s because it's temporary "
+		    "and empty",
+		    [jid:encode(StateData1#state.jid)]),
+	  add_to_log(room_existence, destroyed, StateData1),
+	  {stop, normal, StateData1};
+      _ -> {next_state, normal_state, StateData1}
+    end.
+
+-spec get_users_and_subscribers(state()) -> dict:dict().
+get_users_and_subscribers(StateData) ->
+    OnlineSubscribers = ?DICT:fold(
+			   fun(LJID, _, Acc) ->
+				   LBareJID = jid:remove_resource(LJID),
+				   case is_subscriber(LBareJID, StateData) of
+				       true ->
+					   ?SETS:add_element(LBareJID, Acc);
+				       false ->
+					   Acc
+				   end
+			   end, ?SETS:new(), StateData#state.users),
+    ?DICT:fold(
+       fun(LBareJID, #subscriber{nick = Nick}, Acc) ->
+	       case ?SETS:is_element(LBareJID, OnlineSubscribers) of
+		   false ->
+		       ?DICT:store(LBareJID,
+				   #user{jid = jid:make(LBareJID),
+					 nick = Nick,
+					 role = none,
+					 last_presence = undefined},
+				   Acc);
+		   true ->
+		       Acc
+	       end
+       end, StateData#state.users, StateData#state.subscribers).
+
+-spec is_user_online(jid(), state()) -> boolean().
+is_user_online(JID, StateData) ->
+    LJID = jid:tolower(JID),
+    (?DICT):is_key(LJID, StateData#state.users).
+
+-spec is_subscriber(jid(), state()) -> boolean().
+is_subscriber(JID, StateData) ->
+    LJID = jid:tolower(jid:remove_resource(JID)),
+    (?DICT):is_key(LJID, StateData#state.subscribers).
+
+%% Check if the user is occupant of the room, or at least is an admin or owner.
+-spec is_occupant_or_admin(jid(), state()) -> boolean().
+is_occupant_or_admin(JID, StateData) ->
+    FAffiliation = get_affiliation(JID, StateData),
+    FRole = get_role(JID, StateData),
+    case FRole /= none orelse
+	   FAffiliation == member orelse
+	   FAffiliation == admin orelse FAffiliation == owner
+	of
+      true -> true;
+      _ -> false
+    end.
+
+%% Decide the fate of the message and its sender
+%% Returns: continue_delivery | forget_message | {expulse_sender, Reason}
+-spec decide_fate_message(message(), jid(), state()) ->
+				 continue_delivery | forget_message |
+				 {expulse_sender, binary()}.
+decide_fate_message(#message{type = error} = Msg,
+		    From, StateData) ->
+    Err = xmpp:get_error(Msg),
+    PD = case check_error_kick(Err) of
+	   %% If this is an error stanza and its condition matches a criteria
+	   true ->
+	       Reason = str:format("This participant is considered a ghost "
+				   "and is expulsed: ~s",
+				   [jid:encode(From)]),
+	       {expulse_sender, Reason};
+	   false -> continue_delivery
+	 end,
+    case PD of
+      {expulse_sender, R} ->
+	  case is_user_online(From, StateData) of
+	    true -> {expulse_sender, R};
+	    false -> forget_message
+	  end;
+      Other -> Other
+    end;
+decide_fate_message(_, _, _) -> continue_delivery.
+
+%% Check if the elements of this error stanza indicate
+%% that the sender is a dead participant.
+%% If so, return true to kick the participant.
+-spec check_error_kick(stanza_error()) -> boolean().
+check_error_kick(#stanza_error{reason = Reason}) ->
+    case Reason of
+	#gone{} -> true;
+	'internal-server-error' -> true;
+	'item-not-found' -> true;
+	'jid-malformed' -> true;
+	'recipient-unavailable' -> true;
+	#redirect{} -> true;
+	'remote-server-not-found' -> true;
+	'remote-server-timeout' -> true;
+	'service-unavailable' -> true;
+	_ -> false
+    end;
+check_error_kick(undefined) ->
+    false.
+
+-spec get_error_condition(stanza_error()) -> string().
+get_error_condition(#stanza_error{reason = Reason}) ->
+    case Reason of
+	#gone{} -> "gone";
+	#redirect{} -> "redirect";
+	Atom -> atom_to_list(Atom)
+    end;
+get_error_condition(undefined) ->
+    "undefined".
+
+-spec get_error_text(stanza_error()) -> binary().
+get_error_text(#stanza_error{text = Txt}) ->
+    xmpp:get_text(Txt).
+
+-spec make_reason(stanza(), jid(), state(), binary()) -> binary().
+make_reason(Packet, From, StateData, Reason1) ->
+    {ok, #user{nick = FromNick}} = (?DICT):find(jid:tolower(From), StateData#state.users),
+    Condition = get_error_condition(xmpp:get_error(Packet)),
+    str:format(Reason1, [FromNick, Condition]).
+
+-spec expulse_participant(stanza(), jid(), state(), binary()) ->
+				 state().
+expulse_participant(Packet, From, StateData, Reason1) ->
+    Reason2 = make_reason(Packet, From, StateData, Reason1),
+    NewState = add_user_presence_un(From,
+				    #presence{type = unavailable,
+					      status = xmpp:mk_text(Reason2)},
+				    StateData),
+    LJID = jid:tolower(From),
+    {ok, #user{nick = Nick}} = (?DICT):find(LJID, StateData#state.users),
+    case (?DICT):find(Nick, StateData#state.nicks) of
+	{ok, [_, _ | _]} ->
+	    Aff = get_affiliation(From, StateData),
+	    Item = #muc_item{affiliation = Aff, role = none, jid = From},
+	    Pres = xmpp:set_subtag(
+		     Packet, #muc_user{items = [Item],
+				       status_codes = [110]}),
+	    send_wrapped(jid:replace_resource(StateData#state.jid, Nick),
+			 From, Pres, ?NS_MUCSUB_NODES_PRESENCE, StateData);
+	_ ->
+	    send_new_presence(From, NewState, StateData)
+    end,
+    remove_online_user(From, NewState).
+
+-spec get_owners(state()) -> [jid:jid()].
+get_owners(StateData) ->
+    ?DICT:fold(
+       fun(LJID, owner, Acc) ->
+	       [jid:make(LJID)|Acc];
+	  (LJID, {owner, _}, Acc) ->
+	       [jid:make(LJID)|Acc];
+	  (_, _, Acc) ->
+	       Acc
+       end, [], StateData#state.affiliations).
+
+-spec set_affiliation(jid(), affiliation(), state()) -> state().
+set_affiliation(JID, Affiliation, StateData) ->
+    set_affiliation(JID, Affiliation, StateData, <<"">>).
+
+-spec set_affiliation(jid(), affiliation(), state(), binary()) -> state().
+set_affiliation(JID, Affiliation,
+		#state{config = #config{persistent = false}} = StateData,
+		Reason) ->
+    set_affiliation_fallback(JID, Affiliation, StateData, Reason);
+set_affiliation(JID, Affiliation, StateData, Reason) ->
+    ServerHost = StateData#state.server_host,
+    Room = StateData#state.room,
+    Host = StateData#state.host,
+    Mod = gen_mod:db_mod(ServerHost, mod_muc),
+    case Mod:set_affiliation(ServerHost, Room, Host, JID, Affiliation, Reason) of
+	ok ->
+	    StateData;
+	{error, _} ->
+	    set_affiliation_fallback(JID, Affiliation, StateData, Reason)
+    end.
+
+-spec set_affiliation_fallback(jid(), affiliation(), state(), binary()) -> state().
+set_affiliation_fallback(JID, Affiliation, StateData, Reason) ->
+    LJID = jid:remove_resource(jid:tolower(JID)),
+    Affiliations = case Affiliation of
+		       none ->
+			   (?DICT):erase(LJID, StateData#state.affiliations);
+		       _ ->
+			   (?DICT):store(LJID, {Affiliation, Reason},
+					 StateData#state.affiliations)
+		   end,
+    StateData#state{affiliations = Affiliations}.
+
+-spec set_affiliations(dict:dict(), state()) -> state().
+set_affiliations(Affiliations,
+                 #state{config = #config{persistent = false}} = StateData) ->
+    set_affiliations_fallback(Affiliations, StateData);
+set_affiliations(Affiliations, StateData) ->
+    Room = StateData#state.room,
+    Host = StateData#state.host,
+    ServerHost = StateData#state.server_host,
+    Mod = gen_mod:db_mod(ServerHost, mod_muc),
+    case Mod:set_affiliations(ServerHost, Room, Host, Affiliations) of
+	ok ->
+	    StateData;
+	{error, _} ->
+	    set_affiliations_fallback(Affiliations, StateData)
+    end.
+
+-spec set_affiliations_fallback(dict:dict(), state()) -> state().
+set_affiliations_fallback(Affiliations, StateData) ->
+    StateData#state{affiliations = Affiliations}.
+
+-spec get_affiliation(ljid() | jid(), state()) -> affiliation().
+get_affiliation(#jid{} = JID, StateData) ->
+    case get_service_affiliation(JID, StateData) of
+        owner ->
+            owner;
+        none ->
+            case do_get_affiliation(JID, StateData) of
+                {Affiliation, _Reason} -> Affiliation;
+                Affiliation -> Affiliation
+            end
+    end;
+get_affiliation(LJID, StateData) ->
+    get_affiliation(jid:make(LJID), StateData).
+
+-spec do_get_affiliation(jid(), state()) -> affiliation().
+do_get_affiliation(JID, #state{config = #config{persistent = false}} = StateData) ->
+    do_get_affiliation_fallback(JID, StateData);
+do_get_affiliation(JID, StateData) ->
+    Room = StateData#state.room,
+    Host = StateData#state.host,
+    LServer = JID#jid.lserver,
+    LUser = JID#jid.luser,
+    ServerHost = StateData#state.server_host,
+    Mod = gen_mod:db_mod(ServerHost, mod_muc),
+    case Mod:get_affiliation(ServerHost, Room, Host, LUser, LServer) of
+	{error, _} ->
+	    do_get_affiliation_fallback(JID, StateData);
+	{ok, Affiliation} ->
+	    Affiliation
+    end.
+
+-spec do_get_affiliation_fallback(jid(), state()) -> affiliation().
+do_get_affiliation_fallback(JID, StateData) ->
+    LJID = jid:tolower(JID),
+    case (?DICT):find(LJID, StateData#state.affiliations) of
+        {ok, Affiliation} -> Affiliation;
+        _ ->
+            LJID1 = jid:remove_resource(LJID),
+            case (?DICT):find(LJID1, StateData#state.affiliations)
+            of
+                {ok, Affiliation} -> Affiliation;
+                _ ->
+                    LJID2 = setelement(1, LJID, <<"">>),
+                    case (?DICT):find(LJID2,
+                                      StateData#state.affiliations)
+                    of
+                        {ok, Affiliation} -> Affiliation;
+                        _ ->
+                            LJID3 = jid:remove_resource(LJID2),
+                            case (?DICT):find(LJID3,
+                                              StateData#state.affiliations)
+                            of
+                                {ok, Affiliation} -> Affiliation;
+                                _ -> none
+                            end
+                    end
+            end
+    end.
+
+-spec get_affiliations(state()) -> dict:dict().
+get_affiliations(#state{config = #config{persistent = false}} = StateData) ->
+    get_affiliations_callback(StateData);
+get_affiliations(StateData) ->
+    Room = StateData#state.room,
+    Host = StateData#state.host,
+    ServerHost = StateData#state.server_host,
+    Mod = gen_mod:db_mod(ServerHost, mod_muc),
+    case Mod:get_affiliations(ServerHost, Room, Host) of
+	{error, _} ->
+	    get_affiliations_callback(StateData);
+	{ok, Affiliations} ->
+	    Affiliations
+    end.
+
+-spec get_affiliations_callback(state()) -> dict:dict().
+get_affiliations_callback(StateData) ->
+    StateData#state.affiliations.
+
+-spec get_service_affiliation(jid(), state()) -> owner | none.
+get_service_affiliation(JID, StateData) ->
+    {_AccessRoute, _AccessCreate, AccessAdmin,
+     _AccessPersistent} =
+	StateData#state.access,
+    case acl:match_rule(StateData#state.server_host,
+			AccessAdmin, JID)
+	of
+      allow -> owner;
+      _ -> none
+    end.
+
+-spec set_role(jid(), role(), state()) -> state().
+set_role(JID, Role, StateData) ->
+    LJID = jid:tolower(JID),
+    LJIDs = case LJID of
+	      {U, S, <<"">>} ->
+		  (?DICT):fold(fun (J, _, Js) ->
+				       case J of
+					 {U, S, _} -> [J | Js];
+					 _ -> Js
+				       end
+			       end,
+			       [], StateData#state.users);
+	      _ ->
+		  case (?DICT):is_key(LJID, StateData#state.users) of
+		    true -> [LJID];
+		    _ -> []
+		  end
+	    end,
+    {Users, Nicks} = case Role of
+		       none ->
+			   lists:foldl(fun (J, {Us, Ns}) ->
+					       NewNs = case (?DICT):find(J, Us)
+							   of
+							 {ok,
+							  #user{nick = Nick}} ->
+							     (?DICT):erase(Nick,
+									   Ns);
+							 _ -> Ns
+						       end,
+					       {(?DICT):erase(J, Us), NewNs}
+				       end,
+				       {StateData#state.users,
+					StateData#state.nicks},
+				       LJIDs);
+		       _ ->
+			   {lists:foldl(
+			      fun (J, Us) ->
+				      {ok, User} = (?DICT):find(J, Us),
+				      if User#user.last_presence == undefined ->
+					      Us;
+					 true ->
+					      (?DICT):store(J, User#user{role = Role}, Us)
+				      end
+			      end,
+			      StateData#state.users, LJIDs),
+			    StateData#state.nicks}
+		     end,
+    StateData#state{users = Users, nicks = Nicks}.
+
+-spec get_role(jid(), state()) -> role().
+get_role(JID, StateData) ->
+    LJID = jid:tolower(JID),
+    case (?DICT):find(LJID, StateData#state.users) of
+      {ok, #user{role = Role}} -> Role;
+      _ -> none
+    end.
+
+-spec get_default_role(affiliation(), state()) -> role().
+get_default_role(Affiliation, StateData) ->
+    case Affiliation of
+      owner -> moderator;
+      admin -> moderator;
+      member -> participant;
+      outcast -> none;
+      none ->
+	  case (StateData#state.config)#config.members_only of
+	    true -> none;
+	    _ ->
+		case (StateData#state.config)#config.members_by_default
+		    of
+		  true -> participant;
+		  _ -> visitor
+		end
+	  end
+    end.
+
+-spec is_visitor(jid(), state()) -> boolean().
+is_visitor(Jid, StateData) ->
+    get_role(Jid, StateData) =:= visitor.
+
+-spec is_moderator(jid(), state()) -> boolean().
+is_moderator(Jid, StateData) ->
+    get_role(Jid, StateData) =:= moderator.
+
+-spec get_max_users(state()) -> non_neg_integer().
+get_max_users(StateData) ->
+    MaxUsers = (StateData#state.config)#config.max_users,
+    ServiceMaxUsers = get_service_max_users(StateData),
+    if MaxUsers =< ServiceMaxUsers -> MaxUsers;
+       true -> ServiceMaxUsers
+    end.
+
+-spec get_service_max_users(state()) -> pos_integer().
+get_service_max_users(StateData) ->
+    gen_mod:get_module_opt(StateData#state.server_host,
+			   mod_muc, max_users).
+
+-spec get_max_users_admin_threshold(state()) -> pos_integer().
+get_max_users_admin_threshold(StateData) ->
+    gen_mod:get_module_opt(StateData#state.server_host,
+			   mod_muc, max_users_admin_threshold).
+
+-spec room_queue_new(binary(), shaper:shaper(), _) -> p1_queue:queue().
+room_queue_new(ServerHost, Shaper, QueueType) ->
+    HaveRoomShaper = Shaper /= none,
+    HaveMessageShaper = gen_mod:get_module_opt(
+			  ServerHost, mod_muc,
+			  user_message_shaper) /= none,
+    HavePresenceShaper = gen_mod:get_module_opt(
+			   ServerHost, mod_muc,
+			   user_presence_shaper) /= none,
+    HaveMinMessageInterval = gen_mod:get_module_opt(
+			       ServerHost, mod_muc,
+			       min_message_interval) /= 0,
+    HaveMinPresenceInterval = gen_mod:get_module_opt(
+				ServerHost, mod_muc,
+				min_presence_interval) /= 0,
+    if HaveRoomShaper or HaveMessageShaper or HavePresenceShaper
+       or HaveMinMessageInterval or HaveMinPresenceInterval ->
+	    p1_queue:new(QueueType);
+       true ->
+	    undefined
+    end.
+
+-spec get_user_activity(jid(), state()) -> #activity{}.
+get_user_activity(JID, StateData) ->
+    case treap:lookup(jid:tolower(JID),
+		      StateData#state.activity)
+	of
+      {ok, _P, A} -> A;
+      error ->
+	  MessageShaper =
+	      shaper:new(gen_mod:get_module_opt(StateData#state.server_host,
+						mod_muc, user_message_shaper)),
+	  PresenceShaper =
+	      shaper:new(gen_mod:get_module_opt(StateData#state.server_host,
+						mod_muc, user_presence_shaper)),
+	  #activity{message_shaper = MessageShaper,
+		    presence_shaper = PresenceShaper}
+    end.
+
+-spec store_user_activity(jid(), #activity{}, state()) -> state().
+store_user_activity(JID, UserActivity, StateData) ->
+    MinMessageInterval =
+	trunc(gen_mod:get_module_opt(StateData#state.server_host,
+				     mod_muc, min_message_interval)
+	      * 1000),
+    MinPresenceInterval =
+	trunc(gen_mod:get_module_opt(StateData#state.server_host,
+				     mod_muc, min_presence_interval)
+	      * 1000),
+    Key = jid:tolower(JID),
+    Now = p1_time_compat:system_time(micro_seconds),
+    Activity1 = clean_treap(StateData#state.activity,
+			    {1, -Now}),
+    Activity = case treap:lookup(Key, Activity1) of
+		 {ok, _P, _A} -> treap:delete(Key, Activity1);
+		 error -> Activity1
+	       end,
+    StateData1 = case MinMessageInterval == 0 andalso
+			MinPresenceInterval == 0 andalso
+			  UserActivity#activity.message_shaper == none andalso
+			    UserActivity#activity.presence_shaper == none
+			      andalso
+			      UserActivity#activity.message == undefined andalso
+				UserActivity#activity.presence == undefined
+		     of
+		   true -> StateData#state{activity = Activity};
+		   false ->
+		       case UserActivity#activity.message == undefined andalso
+			      UserActivity#activity.presence == undefined
+			   of
+			 true ->
+			     {_, MessageShaperInterval} =
+				 shaper:update(UserActivity#activity.message_shaper,
+					       100000),
+			     {_, PresenceShaperInterval} =
+				 shaper:update(UserActivity#activity.presence_shaper,
+					       100000),
+			     Delay = lists:max([MessageShaperInterval,
+						PresenceShaperInterval,
+						MinMessageInterval,
+						MinPresenceInterval])
+				       * 1000,
+			     Priority = {1, -(Now + Delay)},
+			     StateData#state{activity =
+						 treap:insert(Key, Priority,
+							      UserActivity,
+							      Activity)};
+			 false ->
+			     Priority = {0, 0},
+			     StateData#state{activity =
+						 treap:insert(Key, Priority,
+							      UserActivity,
+							      Activity)}
+		       end
+		 end,
+    StateData1.
+
+-spec clean_treap(treap:treap(), integer() | {1, integer()}) -> treap:treap().
+clean_treap(Treap, CleanPriority) ->
+    case treap:is_empty(Treap) of
+      true -> Treap;
+      false ->
+	  {_Key, Priority, _Value} = treap:get_root(Treap),
+	  if Priority > CleanPriority ->
+		 clean_treap(treap:delete_root(Treap), CleanPriority);
+	     true -> Treap
+	  end
+    end.
+
+-spec prepare_room_queue(state()) -> state().
+prepare_room_queue(StateData) ->
+    case p1_queue:out(StateData#state.room_queue) of
+      {{value, {message, From}}, _RoomQueue} ->
+	  Activity = get_user_activity(From, StateData),
+	  Packet = Activity#activity.message,
+	  Size = element_size(Packet),
+	  {RoomShaper, RoomShaperInterval} =
+	      shaper:update(StateData#state.room_shaper, Size),
+	  erlang:send_after(RoomShaperInterval, self(),
+			    process_room_queue),
+	  StateData#state{room_shaper = RoomShaper};
+      {{value, {presence, From}}, _RoomQueue} ->
+	  Activity = get_user_activity(From, StateData),
+	  {_Nick, Packet} = Activity#activity.presence,
+	  Size = element_size(Packet),
+	  {RoomShaper, RoomShaperInterval} =
+	      shaper:update(StateData#state.room_shaper, Size),
+	  erlang:send_after(RoomShaperInterval, self(),
+			    process_room_queue),
+	  StateData#state{room_shaper = RoomShaper};
+      {empty, _} -> StateData
+    end.
+
+-spec update_online_user(jid(), #user{}, state()) -> state().
+update_online_user(JID, #user{nick = Nick} = User, StateData) ->
+    LJID = jid:tolower(JID),
+    Nicks1 = case (?DICT):find(LJID, StateData#state.users) of
+		 {ok, #user{nick = OldNick}} ->
+		     case lists:delete(
+			    LJID, ?DICT:fetch(OldNick, StateData#state.nicks)) of
+			 [] ->
+			     ?DICT:erase(OldNick, StateData#state.nicks);
+			 LJIDs ->
+			     ?DICT:store(OldNick, LJIDs, StateData#state.nicks)
+		     end;
+		 error ->
+		     StateData#state.nicks
+	     end,
+    Nicks = (?DICT):update(Nick,
+			   fun (LJIDs) -> [LJID|LJIDs -- [LJID]] end,
+			   [LJID], Nicks1),
+    Users = (?DICT):update(LJID,
+			   fun(U) ->
+				   U#user{nick = Nick}
+			   end, User, StateData#state.users),
+    NewStateData = StateData#state{users = Users, nicks = Nicks},
+    case {?DICT:find(LJID, StateData#state.users),
+	  ?DICT:find(LJID, NewStateData#state.users)} of
+	{{ok, #user{nick = Old}}, {ok, #user{nick = New}}} when Old /= New ->
+	    send_nick_changing(JID, Old, NewStateData, true, true);
+	_ ->
+	    ok
+    end,
+    NewStateData.
+
+set_subscriber(JID, Nick, Nodes, StateData) ->
+    BareJID = jid:remove_resource(JID),
+    LBareJID = jid:tolower(BareJID),
+    Subscribers = ?DICT:store(LBareJID,
+			      #subscriber{jid = BareJID,
+					  nick = Nick,
+					  nodes = Nodes},
+			      StateData#state.subscribers),
+    Nicks = ?DICT:store(Nick, [LBareJID], StateData#state.subscriber_nicks),
+    NewStateData = StateData#state{subscribers = Subscribers,
+				   subscriber_nicks = Nicks},
+    store_room(NewStateData, [{add_subscription, BareJID, Nick, Nodes}]),
+    case not ?DICT:is_key(LBareJID, StateData#state.subscribers) of
+	true ->
+	    send_subscriptions_change_notifications(BareJID, Nick, subscribe, NewStateData);
+	_ ->
+	    ok
+    end,
+    NewStateData.
+
+-spec add_online_user(jid(), binary(), role(), state()) -> state().
+add_online_user(JID, Nick, Role, StateData) ->
+    tab_add_online_user(JID, StateData),
+    User = #user{jid = JID, nick = Nick, role = Role},
+    update_online_user(JID, User, StateData).
+
+-spec remove_online_user(jid(), state()) -> state().
+remove_online_user(JID, StateData) ->
+    remove_online_user(JID, StateData, <<"">>).
+
+-spec remove_online_user(jid(), state(), binary()) -> state().
+remove_online_user(JID, StateData, Reason) ->
+    LJID = jid:tolower(JID),
+    {ok, #user{nick = Nick}} = (?DICT):find(LJID,
+					    StateData#state.users),
+    add_to_log(leave, {Nick, Reason}, StateData),
+    tab_remove_online_user(JID, StateData),
+    Users = (?DICT):erase(LJID, StateData#state.users),
+    Nicks = case (?DICT):find(Nick, StateData#state.nicks)
+		of
+	      {ok, [LJID]} ->
+		  (?DICT):erase(Nick, StateData#state.nicks);
+	      {ok, U} ->
+		  (?DICT):store(Nick, U -- [LJID], StateData#state.nicks);
+	      error -> StateData#state.nicks
+	    end,
+    StateData#state{users = Users, nicks = Nicks}.
+
+-spec filter_presence(presence()) -> presence().
+filter_presence(Presence) ->
+    Els = lists:filter(
+	    fun(El) ->
+		    XMLNS = xmpp:get_ns(El),
+		    case catch binary:part(XMLNS, 0, size(?NS_MUC)) of
+			?NS_MUC -> false;
+			_ -> true
+		    end
+	    end, xmpp:get_els(Presence)),
+    xmpp:set_els(Presence, Els).
+
+-spec strip_status(presence()) -> presence().
+strip_status(Presence) ->
+    Presence#presence{status = []}.
+
+-spec add_user_presence(jid(), presence(), state()) -> state().
+add_user_presence(JID, Presence, StateData) ->
+    LJID = jid:tolower(JID),
+    FPresence = filter_presence(Presence),
+    Users = (?DICT):update(LJID,
+			   fun (#user{} = User) ->
+				   User#user{last_presence = FPresence}
+			   end,
+			   StateData#state.users),
+    StateData#state{users = Users}.
+
+-spec add_user_presence_un(jid(), presence(), state()) -> state().
+add_user_presence_un(JID, Presence, StateData) ->
+    LJID = jid:tolower(JID),
+    FPresence = filter_presence(Presence),
+    Users = (?DICT):update(LJID,
+			   fun (#user{} = User) ->
+				   User#user{last_presence = FPresence,
+					     role = none}
+			   end,
+			   StateData#state.users),
+    StateData#state{users = Users}.
+
+%% Find and return a list of the full JIDs of the users of Nick.
+%% Return jid record.
+-spec find_jids_by_nick(binary(), state()) -> [jid()].
+find_jids_by_nick(Nick, StateData) ->
+    Nicks = ?DICT:merge(fun(_, Val, _) -> Val end,
+			StateData#state.nicks,
+			StateData#state.subscriber_nicks),
+    case (?DICT):find(Nick, Nicks) of
+      {ok, [User]} -> [jid:make(User)];
+      {ok, Users} -> [jid:make(LJID) || LJID <- Users];
+      error -> []
+    end.
+
+%% Find and return the full JID of the user of Nick with
+%% highest-priority presence.  Return jid record.
+-spec find_jid_by_nick(binary(), state()) -> jid() | false.
+find_jid_by_nick(Nick, StateData) ->
+    case (?DICT):find(Nick, StateData#state.nicks) of
+      {ok, [User]} -> jid:make(User);
+      {ok, [FirstUser | Users]} ->
+	  #user{last_presence = FirstPresence} =
+	      (?DICT):fetch(FirstUser, StateData#state.users),
+	  {LJID, _} = lists:foldl(fun (Compare,
+				       {HighestUser, HighestPresence}) ->
+					  #user{last_presence = P1} =
+					      (?DICT):fetch(Compare,
+							    StateData#state.users),
+					  case higher_presence(P1,
+							       HighestPresence)
+					      of
+					    true -> {Compare, P1};
+					    false ->
+						{HighestUser, HighestPresence}
+					  end
+				  end,
+				  {FirstUser, FirstPresence}, Users),
+	  jid:make(LJID);
+      error -> false
+    end.
+
+-spec higher_presence(undefined | presence(),
+		      undefined | presence()) -> boolean().
+higher_presence(Pres1, Pres2) when Pres1 /= undefined, Pres2 /= undefined ->
+    Pri1 = get_priority_from_presence(Pres1),
+    Pri2 = get_priority_from_presence(Pres2),
+    Pri1 > Pri2;
+higher_presence(Pres1, Pres2) ->
+    Pres1 > Pres2.
+
+-spec get_priority_from_presence(presence()) -> integer().
+get_priority_from_presence(#presence{priority = Prio}) ->
+    case Prio of
+        undefined -> 0;
+        _ -> Prio
+    end.
+
+-spec find_nick_by_jid(jid(), state()) -> binary().
+find_nick_by_jid(JID, StateData) ->
+    LJID = jid:tolower(JID),
+    {ok, #user{nick = Nick}} = (?DICT):find(LJID, StateData#state.users),
+    Nick.
+
+-spec is_nick_change(jid(), binary(), state()) -> boolean().
+is_nick_change(JID, Nick, StateData) ->
+    LJID = jid:tolower(JID),
+    case Nick of
+      <<"">> -> false;
+      _ ->
+	  {ok, #user{nick = OldNick}} = (?DICT):find(LJID,
+						     StateData#state.users),
+	  Nick /= OldNick
+    end.
+
+-spec nick_collision(jid(), binary(), state()) -> boolean().
+nick_collision(User, Nick, StateData) ->
+    UserOfNick = case find_jid_by_nick(Nick, StateData) of
+		     false ->
+			 case ?DICT:find(Nick, StateData#state.subscriber_nicks) of
+			     {ok, [J]} -> J;
+			     error -> false
+			 end;
+		     J -> J
+		 end,
+    (UserOfNick /= false andalso
+      jid:remove_resource(jid:tolower(UserOfNick))
+	/= jid:remove_resource(jid:tolower(User))).
+
+-spec add_new_user(jid(), binary(), presence(), state()) -> state();
+		  (jid(), binary(), iq(), state()) -> {error, stanza_error()} |
+						      {ignore, state()} |
+						      {result, muc_subscribe(), state()}.
+add_new_user(From, Nick, Packet, StateData) ->
+    Lang = xmpp:get_lang(Packet),
+    MaxUsers = get_max_users(StateData),
+    MaxAdminUsers = MaxUsers +
+		      get_max_users_admin_threshold(StateData),
+    NUsers = dict:fold(fun (_, _, Acc) -> Acc + 1 end, 0,
+		       StateData#state.users),
+    Affiliation = get_affiliation(From, StateData),
+    ServiceAffiliation = get_service_affiliation(From,
+						 StateData),
+    NConferences = tab_count_user(From, StateData),
+    MaxConferences =
+	gen_mod:get_module_opt(StateData#state.server_host,
+			       mod_muc, max_user_conferences),
+    Collision = nick_collision(From, Nick, StateData),
+    IsSubscribeRequest = not is_record(Packet, presence),
+    case {(ServiceAffiliation == owner orelse
+	     ((Affiliation == admin orelse Affiliation == owner)
+	       andalso NUsers < MaxAdminUsers)
+	       orelse NUsers < MaxUsers)
+	    andalso NConferences < MaxConferences,
+	  Collision,
+	  mod_muc:can_use_nick(StateData#state.server_host,
+			       StateData#state.host, From, Nick),
+	  get_default_role(Affiliation, StateData)}
+	of
+      {false, _, _, _} when NUsers >= MaxUsers orelse NUsers >= MaxAdminUsers ->
+	  Txt = <<"Too many users in this conference">>,
+	  Err = xmpp:err_resource_constraint(Txt, Lang),
+	  if not IsSubscribeRequest ->
+		  ejabberd_router:route_error(Packet, Err),
+		  StateData;
+	     true ->
+		  {error, Err}
+	  end;
+      {false, _, _, _} when NConferences >= MaxConferences ->
+	  Txt = <<"You have joined too many conferences">>,
+	  Err = xmpp:err_resource_constraint(Txt, Lang),
+	  if not IsSubscribeRequest ->
+		  ejabberd_router:route_error(Packet, Err),
+		  StateData;
+	     true ->
+		  {error, Err}
+	  end;
+      {false, _, _, _} ->
+	  Err = xmpp:err_service_unavailable(),
+	  if not IsSubscribeRequest ->
+		  ejabberd_router:route_error(Packet, Err),
+		  StateData;
+	     true ->
+		  {error, Err}
+	  end;
+      {_, _, _, none} ->
+	  Err = case Affiliation of
+		    outcast ->
+			ErrText = <<"You have been banned from this room">>,
+			xmpp:err_forbidden(ErrText, Lang);
+		    _ ->
+			ErrText = <<"Membership is required to enter this room">>,
+			xmpp:err_registration_required(ErrText, Lang)
+		end,
+	  if not IsSubscribeRequest ->
+		  ejabberd_router:route_error(Packet, Err),
+		  StateData;
+	     true ->
+		  {error, Err}
+	  end;
+      {_, true, _, _} ->
+	  ErrText = <<"That nickname is already in use by another occupant">>,
+	  Err = xmpp:err_conflict(ErrText, Lang),
+	  if not IsSubscribeRequest ->
+		  ejabberd_router:route_error(Packet, Err),
+		  StateData;
+	     true ->
+		  {error, Err}
+	  end;
+      {_, _, false, _} ->
+	  ErrText = <<"That nickname is registered by another person">>,
+	  Err = xmpp:err_conflict(ErrText, Lang),
+	  if not IsSubscribeRequest ->
+		  ejabberd_router:route_error(Packet, Err),
+		  StateData;
+	     true ->
+		  {error, Err}
+	  end;
+      {_, _, _, Role} ->
+	  case check_password(ServiceAffiliation, Affiliation,
+			      Packet, From, StateData)
+	      of
+	    true ->
+		Nodes = get_subscription_nodes(Packet),
+		NewStateData =
+		      if not IsSubscribeRequest ->
+			      NewState = add_user_presence(
+					   From, Packet,
+					   add_online_user(From, Nick, Role,
+							   StateData)),
+			      send_initial_presences_and_messages(
+				From, Nick, Packet, NewState, StateData),
+			      NewState;
+			 true ->
+			      set_subscriber(From, Nick, Nodes, StateData)
+		      end,
+		  ResultState =
+		      case NewStateData#state.just_created of
+			  true ->
+			      NewStateData#state{just_created = false};
+			  false ->
+			      Robots = (?DICT):erase(From, StateData#state.robots),
+			      NewStateData#state{robots = Robots}
+		      end,
+		  if not IsSubscribeRequest -> ResultState;
+		     true -> {result, subscribe_result(Packet), ResultState}
+		  end;
+	    need_password ->
+		ErrText = <<"A password is required to enter this room">>,
+		Err = xmpp:err_not_authorized(ErrText, Lang),
+		if not IsSubscribeRequest ->
+			ejabberd_router:route_error(Packet, Err),
+			StateData;
+		   true ->
+			{error, Err}
+		end;
+	    captcha_required ->
+		SID = xmpp:get_id(Packet),
+		RoomJID = StateData#state.jid,
+		To = jid:replace_resource(RoomJID, Nick),
+		Limiter = {From#jid.luser, From#jid.lserver},
+		case ejabberd_captcha:create_captcha(SID, RoomJID, To,
+						     Lang, Limiter, From)
+                   of
+		  {ok, ID, Body, CaptchaEls} ->
+		      MsgPkt = #message{from = RoomJID,
+					to = From,
+					id = ID, body = Body,
+					sub_els = CaptchaEls},
+		      Robots = (?DICT):store(From, {Nick, Packet},
+					     StateData#state.robots),
+		      ejabberd_router:route(MsgPkt),
+		      NewState = StateData#state{robots = Robots},
+		      if not IsSubscribeRequest ->
+			      NewState;
+			 true ->
+			      {ignore, NewState}
+		      end;
+		  {error, limit} ->
+		      ErrText = <<"Too many CAPTCHA requests">>,
+		      Err = xmpp:err_resource_constraint(ErrText, Lang),
+		      if not IsSubscribeRequest ->
+			      ejabberd_router:route_error(Packet, Err),
+			      StateData;
+			 true ->
+			      {error, Err}
+		      end;
+		  _ ->
+		      ErrText = <<"Unable to generate a CAPTCHA">>,
+		      Err = xmpp:err_internal_server_error(ErrText, Lang),
+		      if not IsSubscribeRequest ->
+			      ejabberd_router:route_error(Packet, Err),
+			      StateData;
+			 true ->
+			      {error, Err}
+		      end
+		end;
+	    _ ->
+		ErrText = <<"Incorrect password">>,
+		Err = xmpp:err_not_authorized(ErrText, Lang),
+		if not IsSubscribeRequest ->
+			ejabberd_router:route_error(Packet, Err),
+			StateData;
+		   true ->
+			{error, Err}
+		end
+	  end
+    end.
+
+-spec check_password(affiliation(), affiliation(),
+		     presence() | iq(), jid(), state()) ->
+      boolean() | need_password | captcha_required.
+check_password(owner, _Affiliation, _Packet, _From,
+	       _StateData) ->
+    %% Don't check pass if user is owner in MUC service (access_admin option)
+    true;
+check_password(_ServiceAffiliation, Affiliation, Packet,
+	       From, StateData) ->
+    case (StateData#state.config)#config.password_protected
+	of
+      false -> check_captcha(Affiliation, From, StateData);
+      true ->
+	  Pass = extract_password(Packet),
+	  case Pass of
+	    false -> need_password;
+	    _ ->
+		case (StateData#state.config)#config.password of
+		  Pass -> true;
+		  _ -> false
+		end
+	  end
+    end.
+
+-spec check_captcha(affiliation(), jid(), state()) -> true | captcha_required.
+check_captcha(Affiliation, From, StateData) ->
+    case (StateData#state.config)#config.captcha_protected
+	   andalso ejabberd_captcha:is_feature_available()
+	of
+      true when Affiliation == none ->
+	  case (?DICT):find(From, StateData#state.robots) of
+	    {ok, passed} -> true;
+	    _ ->
+		WList =
+		    (StateData#state.config)#config.captcha_whitelist,
+		#jid{luser = U, lserver = S, lresource = R} = From,
+		case (?SETS):is_element({U, S, R}, WList) of
+		  true -> true;
+		  false ->
+		      case (?SETS):is_element({U, S, <<"">>}, WList) of
+			true -> true;
+			false ->
+			    case (?SETS):is_element({<<"">>, S, <<"">>}, WList)
+				of
+			      true -> true;
+			      false -> captcha_required
+			    end
+		      end
+		end
+	  end;
+      _ -> true
+    end.
+
+-spec extract_password(presence() | iq()) -> binary() | false.
+extract_password(#presence{} = Pres) ->
+    case xmpp:get_subtag(Pres, #muc{}) of
+	#muc{password = Password} when is_binary(Password) ->
+	    Password;
+	_ ->
+	    false
+    end;
+extract_password(#iq{} = IQ) ->
+    case xmpp:get_subtag(IQ, #muc_subscribe{}) of
+	#muc_subscribe{password = Password} when Password /= <<"">> ->
+	    Password;
+	_ ->
+	    false
+    end.
+
+-spec get_history(binary(), stanza(), state()) -> lqueue().
+get_history(Nick, Packet, #state{history = History}) ->
+    case xmpp:get_subtag(Packet, #muc{}) of
+	#muc{history = #muc_history{} = MUCHistory} ->
+	    Now = p1_time_compat:timestamp(),
+	    Q = History#lqueue.queue,
+	    filter_history(Q, Now, Nick, MUCHistory);
+	_ ->
+	    p1_queue:to_list(History#lqueue.queue)
+    end.
+
+-spec filter_history(p1_queue:queue(), erlang:timestamp(),
+		     binary(), muc_history()) -> list().
+filter_history(Queue, Now, Nick,
+	       #muc_history{since = Since,
+			    seconds = Seconds,
+			    maxstanzas = MaxStanzas,
+			    maxchars = MaxChars}) ->
+    {History, _, _} =
+	lists:foldr(
+	  fun({_, _, _, TimeStamp, Size} = Elem,
+	      {Elems, NumStanzas, NumChars} = Acc) ->
+		  NowDiff = timer:now_diff(Now, TimeStamp) div 1000000,
+		  Chars = Size + byte_size(Nick) + 1,
+		  if (NumStanzas < MaxStanzas) andalso
+		     (TimeStamp > Since) andalso
+		     (NowDiff =< Seconds) andalso
+		     (NumChars + Chars =< MaxChars) ->
+			  {[Elem|Elems], NumStanzas + 1, NumChars + Chars};
+		     true ->
+			  Acc
+		  end
+	  end, {[], 0, 0}, p1_queue:to_list(Queue)),
+    History.
+
+-spec is_room_overcrowded(state()) -> boolean().
+is_room_overcrowded(StateData) ->
+    MaxUsersPresence = gen_mod:get_module_opt(
+			 StateData#state.server_host,
+			 mod_muc, max_users_presence),
+    (?DICT):size(StateData#state.users) > MaxUsersPresence.
+
+-spec presence_broadcast_allowed(jid(), state()) -> boolean().
+presence_broadcast_allowed(JID, StateData) ->
+    Role = get_role(JID, StateData),
+    lists:member(Role, (StateData#state.config)#config.presence_broadcast).
+
+-spec send_initial_presences_and_messages(
+	jid(), binary(), presence(), state(), state()) -> ok.
+send_initial_presences_and_messages(From, Nick, Presence, NewState, OldState) ->
+    send_self_presence(From, NewState),
+    send_existing_presences(From, NewState),
+    send_initial_presence(From, NewState, OldState),
+    History = get_history(Nick, Presence, NewState),
+    send_history(From, History, NewState),
+    send_subject(From, OldState).
+
+-spec send_self_presence(jid(), state()) -> ok.
+send_self_presence(JID, State) ->
+    AvatarHash = (State#state.config)#config.vcard_xupdate,
+    DiscoInfo = make_disco_info(JID, State),
+    DiscoHash = mod_caps:compute_disco_hash(DiscoInfo, sha),
+    Els1 = [#caps{hash = <<"sha-1">>,
+		  node = ejabberd_config:get_uri(),
+		  version = DiscoHash}],
+    Els2 = if is_binary(AvatarHash) ->
+		   [#vcard_xupdate{hash = AvatarHash}|Els1];
+	      true ->
+		   Els1
+	   end,
+    ejabberd_router:route(#presence{from = State#state.jid, to = JID,
+				    id = randoms:get_string(),
+				    sub_els = Els2}).
+
+-spec send_initial_presence(jid(), state(), state()) -> ok.
+send_initial_presence(NJID, StateData, OldStateData) ->
+    send_new_presence1(NJID, <<"">>, true, StateData, OldStateData).
+
+-spec send_update_presence(jid(), state(), state()) -> ok.
+send_update_presence(JID, StateData, OldStateData) ->
+    send_update_presence(JID, <<"">>, StateData, OldStateData).
+
+-spec send_update_presence(jid(), binary(), state(), state()) -> ok.
+send_update_presence(JID, Reason, StateData, OldStateData) ->
+    case is_room_overcrowded(StateData) of
+	true -> ok;
+	false -> send_update_presence1(JID, Reason, StateData, OldStateData)
+    end.
+
+-spec send_update_presence1(jid(), binary(), state(), state()) -> ok.
+send_update_presence1(JID, Reason, StateData, OldStateData) ->
+    LJID = jid:tolower(JID),
+    LJIDs = case LJID of
+	      {U, S, <<"">>} ->
+		  (?DICT):fold(fun (J, _, Js) ->
+				       case J of
+					 {U, S, _} -> [J | Js];
+					 _ -> Js
+				       end
+			       end,
+			       [], StateData#state.users);
+	      _ ->
+		  case (?DICT):is_key(LJID, StateData#state.users) of
+		    true -> [LJID];
+		    _ -> []
+		  end
+	    end,
+    lists:foreach(fun (J) ->
+			  send_new_presence1(J, Reason, false, StateData,
+					     OldStateData)
+		  end,
+		  LJIDs).
+
+-spec send_new_presence(jid(), state(), state()) -> ok.
+send_new_presence(NJID, StateData, OldStateData) ->
+    send_new_presence(NJID, <<"">>, false, StateData, OldStateData).
+
+-spec send_new_presence(jid(), binary(), state(), state()) -> ok.
+send_new_presence(NJID, Reason, StateData, OldStateData) ->
+    send_new_presence(NJID, Reason, false, StateData, OldStateData).
+
+-spec send_new_presence(jid(), binary(), boolean(), state(), state()) -> ok.
+send_new_presence(NJID, Reason, IsInitialPresence, StateData, OldStateData) ->
+    case is_room_overcrowded(StateData) of
+	true -> ok;
+	false -> send_new_presence1(NJID, Reason, IsInitialPresence, StateData,
+				    OldStateData)
+    end.
+
+-spec is_ra_changed(jid(), boolean(), state(), state()) -> boolean().
+is_ra_changed(_, _IsInitialPresence = true, _, _) ->
+    false;
+is_ra_changed(JID, _IsInitialPresence = false, NewStateData, OldStateData) ->
+    NewRole = get_role(JID, NewStateData),
+    NewAff = get_affiliation(JID, NewStateData),
+    OldRole = get_role(JID, OldStateData),
+    OldAff = get_affiliation(JID, OldStateData),
+    if (NewRole == none) and (NewAff == OldAff) ->
+	    %% A user is leaving the room;
+	    false;
+       true ->
+	    (NewRole /= OldRole) or (NewAff /= OldAff)
+    end.
+
+-spec send_new_presence1(jid(), binary(), boolean(), state(), state()) -> ok.
+send_new_presence1(NJID, Reason, IsInitialPresence, StateData, OldStateData) ->
+    LNJID = jid:tolower(NJID),
+    #user{nick = Nick} = (?DICT):fetch(LNJID, StateData#state.users),
+    LJID = find_jid_by_nick(Nick, StateData),
+    {ok,
+     #user{jid = RealJID, role = Role0,
+	   last_presence = Presence0} = UserInfo} =
+	(?DICT):find(jid:tolower(LJID),
+		     StateData#state.users),
+    {Role1, Presence1} =
+        case presence_broadcast_allowed(NJID, StateData) of
+            true -> {Role0, Presence0};
+            false -> {none, #presence{type = unavailable}}
+        end,
+    Affiliation = get_affiliation(LJID, StateData),
+    UserList =
+        case not (presence_broadcast_allowed(NJID, StateData) orelse
+             presence_broadcast_allowed(NJID, OldStateData)) of
+            true ->
+                [{LNJID, UserInfo}];
+            false ->
+                (?DICT):to_list(get_users_and_subscribers(StateData))
+        end,
+    lists:foreach(
+      fun({LUJID, Info}) ->
+	      IsSelfPresence = LNJID == LUJID,
+	      {Role, Presence} = if IsSelfPresence -> {Role0, Presence0};
+				    true -> {Role1, Presence1}
+				 end,
+	      Item0 = #muc_item{affiliation = Affiliation,
+				role = Role},
+	      Item1 = case Info#user.role == moderator orelse
+			  (StateData#state.config)#config.anonymous
+			  == false orelse IsSelfPresence of
+			  true -> Item0#muc_item{jid = RealJID};
+			  false -> Item0
+		      end,
+	      Item = Item1#muc_item{reason = Reason},
+	      StatusCodes = status_codes(IsInitialPresence, IsSelfPresence,
+					 StateData),
+	      Pres = if Presence == undefined -> #presence{};
+			true -> Presence
+		     end,
+	      Packet = xmpp:set_subtag(
+			 Pres, #muc_user{items = [Item],
+					 status_codes = StatusCodes}),
+	      Node1 = case is_ra_changed(NJID, IsInitialPresence, StateData, OldStateData) of
+			  true -> ?NS_MUCSUB_NODES_AFFILIATIONS;
+			  false -> ?NS_MUCSUB_NODES_PRESENCE
+		      end,
+	      send_wrapped(jid:replace_resource(StateData#state.jid, Nick),
+			   Info#user.jid, Packet, Node1, StateData),
+	      Type = xmpp:get_type(Packet),
+	      IsSubscriber = is_subscriber(Info#user.jid, StateData),
+	      IsOccupant = Info#user.last_presence /= undefined,
+	      if (IsSubscriber and not IsOccupant) and
+		 (IsInitialPresence or (Type == unavailable)) ->
+		      Node2 = ?NS_MUCSUB_NODES_PARTICIPANTS,
+		      send_wrapped(jid:replace_resource(StateData#state.jid, Nick),
+				   Info#user.jid, Packet, Node2, StateData);
+		 true ->
+		      ok
+	      end
+      end,
+      UserList).
+
+-spec send_existing_presences(jid(), state()) -> ok.
+send_existing_presences(ToJID, StateData) ->
+    case is_room_overcrowded(StateData) of
+	true -> ok;
+	false -> send_existing_presences1(ToJID, StateData)
+    end.
+
+-spec send_existing_presences1(jid(), state()) -> ok.
+send_existing_presences1(ToJID, StateData) ->
+    LToJID = jid:tolower(ToJID),
+    {ok, #user{jid = RealToJID, role = Role}} =
+	(?DICT):find(LToJID, StateData#state.users),
+    lists:foreach(
+      fun({FromNick, _Users}) ->
+	      LJID = find_jid_by_nick(FromNick, StateData),
+	      #user{jid = FromJID, role = FromRole,
+		    last_presence = Presence} =
+		  (?DICT):fetch(jid:tolower(LJID),
+				StateData#state.users),
+	      PresenceBroadcast =
+		  lists:member(
+		    FromRole, (StateData#state.config)#config.presence_broadcast),
+	      case {RealToJID, PresenceBroadcast} of
+		  {FromJID, _} -> ok;
+		  {_, false} -> ok;
+		  _ ->
+		      FromAffiliation = get_affiliation(LJID, StateData),
+		      Item0 = #muc_item{affiliation = FromAffiliation,
+					role = FromRole},
+		      Item = case Role == moderator orelse
+				 (StateData#state.config)#config.anonymous
+				 == false of
+				 true -> Item0#muc_item{jid = FromJID};
+				 false -> Item0
+			     end,
+		      Packet = xmpp:set_subtag(
+				 Presence, #muc_user{items = [Item]}),
+		      send_wrapped(jid:replace_resource(StateData#state.jid, FromNick),
+				   RealToJID, Packet, ?NS_MUCSUB_NODES_PRESENCE, StateData)
+	      end
+      end,
+      (?DICT):to_list(StateData#state.nicks)).
+
+-spec set_nick(jid(), binary(), state()) -> state().
+set_nick(JID, Nick, State) ->
+    LJID = jid:tolower(JID),
+    {ok, #user{nick = OldNick}} = (?DICT):find(LJID, State#state.users),
+    Users = (?DICT):update(LJID,
+			   fun (#user{} = User) -> User#user{nick = Nick} end,
+			   State#state.users),
+    OldNickUsers = (?DICT):fetch(OldNick, State#state.nicks),
+    NewNickUsers = case (?DICT):find(Nick, State#state.nicks) of
+		       {ok, U} -> U;
+		       error -> []
+		   end,
+    Nicks = case OldNickUsers of
+		[LJID] ->
+		    (?DICT):store(Nick, [LJID | NewNickUsers -- [LJID]],
+				  (?DICT):erase(OldNick, State#state.nicks));
+		[_ | _] ->
+		    (?DICT):store(Nick, [LJID | NewNickUsers -- [LJID]],
+				  (?DICT):store(OldNick, OldNickUsers -- [LJID],
+						State#state.nicks))
+	    end,
+    State#state{users = Users, nicks = Nicks}.
+
+-spec change_nick(jid(), binary(), state()) -> state().
+change_nick(JID, Nick, StateData) ->
+    LJID = jid:tolower(JID),
+    {ok, #user{nick = OldNick}} = (?DICT):find(LJID, StateData#state.users),
+    OldNickUsers = (?DICT):fetch(OldNick, StateData#state.nicks),
+    NewNickUsers = case (?DICT):find(Nick, StateData#state.nicks) of
+		       {ok, U} -> U;
+		       error -> []
+		   end,
+    SendOldUnavailable = length(OldNickUsers) == 1,
+    SendNewAvailable = SendOldUnavailable orelse NewNickUsers == [],
+    NewStateData = set_nick(JID, Nick, StateData),
+    case presence_broadcast_allowed(JID, NewStateData) of
+        true ->
+            send_nick_changing(JID, OldNick, NewStateData,
+                               SendOldUnavailable, SendNewAvailable);
+        false -> ok
+    end,
+    add_to_log(nickchange, {OldNick, Nick}, StateData),
+    NewStateData.
+
+-spec send_nick_changing(jid(), binary(), state(), boolean(), boolean()) -> ok.
+send_nick_changing(JID, OldNick, StateData,
+		   SendOldUnavailable, SendNewAvailable) ->
+    {ok,
+     #user{jid = RealJID, nick = Nick, role = Role,
+	   last_presence = Presence}} =
+	(?DICT):find(jid:tolower(JID),
+		     StateData#state.users),
+    Affiliation = get_affiliation(JID, StateData),
+    lists:foreach(
+      fun({LJID, Info}) when Presence /= undefined ->
+	      IsSelfPresence = LJID == jid:tolower(JID),
+	      Item0 = #muc_item{affiliation = Affiliation, role = Role},
+	      Item = case Info#user.role == moderator orelse
+			 (StateData#state.config)#config.anonymous
+			 == false orelse IsSelfPresence of
+			 true -> Item0#muc_item{jid = RealJID};
+			 false -> Item0
+		     end,
+	      Status110 = case IsSelfPresence of
+			      true -> [110];
+			      false -> []
+			  end,
+	      Packet1 = #presence{
+			   type = unavailable,
+			   sub_els = [#muc_user{
+					 items = [Item#muc_item{nick = Nick}],
+					 status_codes = [303|Status110]}]},
+	      Packet2 = xmpp:set_subtag(Presence,
+					#muc_user{items = [Item],
+						  status_codes = Status110}),
+	      if SendOldUnavailable ->
+		      send_wrapped(
+			jid:replace_resource(StateData#state.jid, OldNick),
+			Info#user.jid, Packet1, ?NS_MUCSUB_NODES_PRESENCE,
+			StateData);
+		 true -> ok
+	      end,
+	      if SendNewAvailable ->
+		      send_wrapped(
+			jid:replace_resource(StateData#state.jid, Nick),
+			Info#user.jid, Packet2, ?NS_MUCSUB_NODES_PRESENCE,
+			StateData);
+		 true -> ok
+	      end;
+	 (_) ->
+	      ok
+      end,
+		  ?DICT:to_list(get_users_and_subscribers(StateData))).
+
+-spec maybe_send_affiliation(jid(), affiliation(), state()) -> ok.
+maybe_send_affiliation(JID, Affiliation, StateData) ->
+    LJID = jid:tolower(JID),
+    Users = get_users_and_subscribers(StateData),
+    IsOccupant = case LJID of
+		   {LUser, LServer, <<"">>} ->
+		       not (?DICT):is_empty(
+			     (?DICT):filter(fun({U, S, _}, _) ->
+						    U == LUser andalso
+						      S == LServer
+					    end, Users));
+		   {_LUser, _LServer, _LResource} ->
+		       (?DICT):is_key(LJID, Users)
+		 end,
+    case IsOccupant of
+      true ->
+	  ok; % The new affiliation is published via presence.
+      false ->
+	  send_affiliation(JID, Affiliation, StateData)
+    end.
+
+-spec send_affiliation(jid(), affiliation(), state()) -> ok.
+send_affiliation(JID, Affiliation, StateData) ->
+    Item = #muc_item{jid = JID,
+		     affiliation = Affiliation,
+		     role = none},
+    Message = #message{id = randoms:get_string(),
+		       sub_els = [#muc_user{items = [Item]}]},
+    Users = get_users_and_subscribers(StateData),
+    Recipients = case (StateData#state.config)#config.anonymous of
+		   true ->
+		       (?DICT):filter(fun(_, #user{role = moderator}) ->
+					      true;
+					 (_, _) ->
+					      false
+				      end, Users);
+		   false ->
+		       Users
+		 end,
+    send_wrapped_multiple(StateData#state.jid, Recipients, Message,
+			  ?NS_MUCSUB_NODES_AFFILIATIONS, StateData).
+
+-spec status_codes(boolean(), boolean(), state()) -> [pos_integer()].
+status_codes(IsInitialPresence, _IsSelfPresence = true, StateData) ->
+    S0 = [110],
+    case IsInitialPresence of
+	true ->
+	    S1 = case StateData#state.just_created of
+		     true -> [201|S0];
+		     false -> S0
+		 end,
+	    S2 = case (StateData#state.config)#config.anonymous of
+		     true -> S1;
+		     false -> [100|S1]
+		 end,
+	    S3 = case (StateData#state.config)#config.logging of
+		     true -> [170|S2];
+		     false -> S2
+		 end,
+	    S3;
+	false -> S0
+    end;
+status_codes(_IsInitialPresence, _IsSelfPresence = false, _StateData) -> [].
+
+-spec lqueue_new(non_neg_integer(), ram | file) -> lqueue().
+lqueue_new(Max, Type) ->
+    #lqueue{queue = p1_queue:new(Type), max = Max}.
+
+-spec lqueue_in(term(), lqueue()) -> lqueue().
+%% If the message queue limit is set to 0, do not store messages.
+lqueue_in(_Item, LQ = #lqueue{max = 0}) -> LQ;
+%% Otherwise, rotate messages in the queue store.
+lqueue_in(Item, #lqueue{queue = Q1, max = Max}) ->
+    Len = p1_queue:len(Q1),
+    Q2 = p1_queue:in(Item, Q1),
+    if Len >= Max ->
+	   Q3 = lqueue_cut(Q2, Len - Max + 1),
+	   #lqueue{queue = Q3, max = Max};
+       true -> #lqueue{queue = Q2, max = Max}
+    end.
+
+-spec lqueue_cut(p1_queue:queue(), non_neg_integer()) -> p1_queue:queue().
+lqueue_cut(Q, 0) -> Q;
+lqueue_cut(Q, N) ->
+    {_, Q1} = p1_queue:out(Q),
+    lqueue_cut(Q1, N - 1).
+
+-spec add_message_to_history(binary(), jid(), message(), state()) -> state().
+add_message_to_history(FromNick, FromJID, Packet, StateData) ->
+    add_to_log(text, {FromNick, Packet}, StateData),
+    case check_subject(Packet) of
+	[] ->
+	    TimeStamp = p1_time_compat:timestamp(),
+	    AddrPacket = case (StateData#state.config)#config.anonymous of
+			     true -> Packet;
+			     false ->
+				 Addresses = #addresses{
+						list = [#address{type = ofrom,
+								 jid = FromJID}]},
+				 xmpp:set_subtag(Packet, Addresses)
+			 end,
+	    TSPacket = xmpp_util:add_delay_info(
+			 AddrPacket, StateData#state.jid, TimeStamp),
+	    SPacket = xmpp:set_from_to(
+			TSPacket,
+			jid:replace_resource(StateData#state.jid, FromNick),
+			StateData#state.jid),
+	    Size = element_size(SPacket),
+	    Q1 = lqueue_in({FromNick, TSPacket, false,
+			    TimeStamp, Size},
+			   StateData#state.history),
+	    StateData#state{history = Q1};
+	_ ->
+	    StateData
+    end.
+
+-spec send_history(jid(), list(), state()) -> ok.
+send_history(JID, History, StateData) ->
+    lists:foreach(
+      fun({Nick, Packet, _HaveSubject, _TimeStamp, _Size}) ->
+	      ejabberd_router:route(
+		xmpp:set_from_to(
+		  Packet,
+		  jid:replace_resource(StateData#state.jid, Nick),
+		  JID))
+      end, History).
+
+-spec send_subject(jid(), state()) -> ok.
+send_subject(JID, #state{subject_author = Nick} = StateData) ->
+    Subject = case StateData#state.subject of
+		  [] -> [#text{}];
+		  [_|_] = S -> S
+	      end,
+    Packet = #message{from = jid:replace_resource(StateData#state.jid, Nick),
+		      to = JID, type = groupchat, subject = Subject},
+    ejabberd_router:route(Packet).
+
+-spec check_subject(message()) -> [text()].
+check_subject(#message{subject = [_|_] = Subj, body = [],
+		       thread = undefined}) ->
+    Subj;
+check_subject(_) ->
+    [].
+
+-spec can_change_subject(role(), boolean(), state()) -> boolean().
+can_change_subject(Role, IsSubscriber, StateData) ->
+    case (StateData#state.config)#config.allow_change_subj
+	of
+      true -> Role == moderator orelse Role == participant orelse IsSubscriber == true;
+      _ -> Role == moderator
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% Admin stuff
+
+-spec process_iq_admin(jid(), iq(), #state{}) -> {error, stanza_error()} |
+						 {result, undefined, #state{}} |
+						 {result, muc_admin()}.
+process_iq_admin(_From, #iq{lang = Lang, sub_els = [#muc_admin{items = []}]},
+		 _StateData) ->
+    Txt = <<"No 'item' element found">>,
+    {error, xmpp:err_bad_request(Txt, Lang)};
+process_iq_admin(From, #iq{type = set, lang = Lang,
+			   sub_els = [#muc_admin{items = Items}]},
+		 StateData) ->
+    process_admin_items_set(From, Items, Lang, StateData);
+process_iq_admin(From, #iq{type = get, lang = Lang,
+			   sub_els = [#muc_admin{items = [Item]}]},
+		 StateData) ->
+    FAffiliation = get_affiliation(From, StateData),
+    FRole = get_role(From, StateData),
+    case Item of
+	#muc_item{role = undefined, affiliation = undefined} ->
+	    Txt = <<"Neither 'role' nor 'affiliation' attribute found">>,
+	    {error, xmpp:err_bad_request(Txt, Lang)};
+	#muc_item{role = undefined, affiliation = Affiliation} ->
+	    if (FAffiliation == owner) or
+	       (FAffiliation == admin) or
+	       ((FAffiliation == member) and
+		not (StateData#state.config)#config.anonymous) ->
+		    Items = items_with_affiliation(Affiliation, StateData),
+		    {result, #muc_admin{items = Items}};
+	       true ->
+		    ErrText = <<"Administrator privileges required">>,
+		    {error, xmpp:err_forbidden(ErrText, Lang)}
+	    end;
+	#muc_item{role = Role} ->
+	    if FRole == moderator ->
+		    Items = items_with_role(Role, StateData),
+		    {result, #muc_admin{items = Items}};
+	       true ->
+		    ErrText = <<"Moderator privileges required">>,
+		    {error, xmpp:err_forbidden(ErrText, Lang)}
+	    end
+    end;
+process_iq_admin(_From, #iq{type = get, lang = Lang}, _StateData) ->
+    ErrText = <<"Too many <item/> elements">>,
+    {error, xmpp:err_bad_request(ErrText, Lang)}.
+
+-spec items_with_role(role(), state()) -> [muc_item()].
+items_with_role(SRole, StateData) ->
+    lists:map(fun ({_, U}) -> user_to_item(U, StateData)
+	      end,
+	      search_role(SRole, StateData)).
+
+-spec items_with_affiliation(affiliation(), state()) -> [muc_item()].
+items_with_affiliation(SAffiliation, StateData) ->
+    lists:map(
+      fun({JID, {Affiliation, Reason}}) ->
+	      #muc_item{affiliation = Affiliation, jid = jid:make(JID),
+			reason = Reason};
+	 ({JID, Affiliation}) ->
+	      #muc_item{affiliation = Affiliation, jid = jid:make(JID)}
+      end,
+      search_affiliation(SAffiliation, StateData)).
+
+-spec user_to_item(#user{}, state()) -> muc_item().
+user_to_item(#user{role = Role, nick = Nick, jid = JID},
+	     StateData) ->
+    Affiliation = get_affiliation(JID, StateData),
+    #muc_item{role = Role,
+	      affiliation = Affiliation,
+	      nick = Nick,
+	      jid = JID}.
+
+-spec search_role(role(), state()) -> [{ljid(), #user{}}].
+search_role(Role, StateData) ->
+    lists:filter(fun ({_, #user{role = R}}) -> Role == R
+		 end,
+		 (?DICT):to_list(StateData#state.users)).
+
+-spec search_affiliation(affiliation(), state()) ->
+			 [{ljid(),
+			   affiliation() | {affiliation(), binary()}}].
+search_affiliation(Affiliation,
+                   #state{config = #config{persistent = false}} = StateData) ->
+    search_affiliation_fallback(Affiliation, StateData);
+search_affiliation(Affiliation, StateData) ->
+    Room = StateData#state.room,
+    Host = StateData#state.host,
+    ServerHost = StateData#state.server_host,
+    Mod = gen_mod:db_mod(ServerHost, mod_muc),
+    case Mod:search_affiliation(ServerHost, Room, Host, Affiliation) of
+	{ok, AffiliationList} ->
+	    AffiliationList;
+	{error, _} ->
+	    search_affiliation_fallback(Affiliation, StateData)
+    end.
+
+-spec search_affiliation_fallback(affiliation(), state()) ->
+				  [{ljid(),
+				    affiliation() | {affiliation(), binary()}}].
+search_affiliation_fallback(Affiliation, StateData) ->
+    lists:filter(
+      fun({_, A}) ->
+	      case A of
+		  {A1, _Reason} -> Affiliation == A1;
+		  _ -> Affiliation == A
+	      end
+      end,
+      (?DICT):to_list(StateData#state.affiliations)).
+
+-spec process_admin_items_set(jid(), [muc_item()], binary(),
+			      #state{}) -> {result, undefined, #state{}} |
+					   {error, stanza_error()}.
+process_admin_items_set(UJID, Items, Lang, StateData) ->
+    UAffiliation = get_affiliation(UJID, StateData),
+    URole = get_role(UJID, StateData),
+    case catch find_changed_items(UJID, UAffiliation, URole,
+				  Items, Lang, StateData, [])
+	of
+      {result, Res} ->
+	  ?INFO_MSG("Processing MUC admin query from ~s in "
+		    "room ~s:~n ~p",
+		    [jid:encode(UJID),
+		     jid:encode(StateData#state.jid), Res]),
+	  case lists:foldl(process_item_change(UJID),
+			   StateData, lists:flatten(Res)) of
+	      {error, _} = Err ->
+		  Err;
+	      NSD ->
+		  store_room(NSD),
+		  {result, undefined, NSD}
+	  end;
+	{error, Err} -> {error, Err}
+    end.
+
+-spec process_item_change(jid()) -> function().
+process_item_change(UJID) ->
+    fun(_, {error, _} = Err) ->
+	    Err;
+       (Item, SD) ->
+	    process_item_change(Item, SD, UJID)
+    end.
+
+-type admin_action() :: {jid(), affiliation | role,
+			 affiliation() | role(), binary()}.
+
+-spec process_item_change(admin_action(), state(), undefined | jid()) -> state() | {error, stanza_error()}.
+process_item_change(Item, SD, UJID) ->
+    try case Item of
+	    {JID, affiliation, owner, _} when JID#jid.luser == <<"">> ->
+		%% If the provided JID does not have username,
+		%% forget the affiliation completely
+		SD;
+	    {JID, role, none, Reason} ->
+		send_kickban_presence(UJID, JID, Reason, 307, SD),
+		set_role(JID, none, SD);
+	    {JID, affiliation, none, Reason} ->
+		case (SD#state.config)#config.members_only of
+		    true ->
+			send_kickban_presence(UJID, JID, Reason, 321, none, SD),
+			maybe_send_affiliation(JID, none, SD),
+			SD1 = set_affiliation(JID, none, SD),
+			set_role(JID, none, SD1);
+		    _ ->
+			SD1 = set_affiliation(JID, none, SD),
+			send_update_presence(JID, Reason, SD1, SD),
+			maybe_send_affiliation(JID, none, SD1),
+			SD1
+		end;
+	    {JID, affiliation, outcast, Reason} ->
+		send_kickban_presence(UJID, JID, Reason, 301, outcast, SD),
+		maybe_send_affiliation(JID, outcast, SD),
+		set_affiliation(JID, outcast, set_role(JID, none, SD), Reason);
+	    {JID, affiliation, A, Reason} when (A == admin) or (A == owner) ->
+		SD1 = set_affiliation(JID, A, SD, Reason),
+		SD2 = set_role(JID, moderator, SD1),
+		send_update_presence(JID, Reason, SD2, SD),
+		maybe_send_affiliation(JID, A, SD2),
+		SD2;
+	    {JID, affiliation, member, Reason} ->
+		SD1 = set_affiliation(JID, member, SD, Reason),
+		SD2 = set_role(JID, participant, SD1),
+		send_update_presence(JID, Reason, SD2, SD),
+		maybe_send_affiliation(JID, member, SD2),
+		SD2;
+	    {JID, role, Role, Reason} ->
+		SD1 = set_role(JID, Role, SD),
+		send_new_presence(JID, Reason, SD1, SD),
+		SD1;
+	    {JID, affiliation, A, _Reason} ->
+		SD1 = set_affiliation(JID, A, SD),
+		send_update_presence(JID, SD1, SD),
+		maybe_send_affiliation(JID, A, SD1),
+		SD1
+	end
+    catch E:R ->
+		FromSuffix = case UJID of
+			#jid{} ->
+				JidString = jid:encode(UJID),
+				<<" from ", JidString/binary>>;
+			undefined ->
+				<<"">>
+		end,
+		?ERROR_MSG("failed to set item ~p~s: ~p",
+		       [Item, FromSuffix,
+			{E, {R, erlang:get_stacktrace()}}]),
+	    {error, xmpp:err_internal_server_error()}
+    end.
+
+-spec find_changed_items(jid(), affiliation(), role(),
+			 [muc_item()], binary(), state(), [admin_action()]) ->
+				{result, [admin_action()]}.
+find_changed_items(_UJID, _UAffiliation, _URole, [],
+		   _Lang, _StateData, Res) ->
+    {result, Res};
+find_changed_items(_UJID, _UAffiliation, _URole,
+		   [#muc_item{jid = undefined, nick = <<"">>}|_],
+		   Lang, _StateData, _Res) ->
+    Txt = <<"Neither 'jid' nor 'nick' attribute found">>,
+    throw({error, xmpp:err_bad_request(Txt, Lang)});
+find_changed_items(_UJID, _UAffiliation, _URole,
+		   [#muc_item{role = undefined, affiliation = undefined}|_],
+		   Lang, _StateData, _Res) ->
+    Txt = <<"Neither 'role' nor 'affiliation' attribute found">>,
+    throw({error, xmpp:err_bad_request(Txt, Lang)});
+find_changed_items(UJID, UAffiliation, URole,
+		   [#muc_item{jid = J, nick = Nick, reason = Reason,
+			      role = Role, affiliation = Affiliation}|Items],
+		   Lang, StateData, Res) ->
+    [JID | _] = JIDs =
+	if J /= undefined ->
+		[J];
+	   Nick /= <<"">> ->
+		case find_jids_by_nick(Nick, StateData) of
+		    [] ->
+			ErrText = {<<"Nickname ~s does not exist in the room">>,
+				   [Nick]},
+			throw({error, xmpp:err_not_acceptable(ErrText, Lang)});
+		    JIDList ->
+			JIDList
+		end
+	end,
+    {RoleOrAff, RoleOrAffValue} = if Role == undefined ->
+					  {affiliation, Affiliation};
+				     true ->
+					  {role, Role}
+				  end,
+    TAffiliation = get_affiliation(JID, StateData),
+    TRole = get_role(JID, StateData),
+    ServiceAf = get_service_affiliation(JID, StateData),
+    CanChangeRA = case can_change_ra(UAffiliation,
+				     URole,
+				     TAffiliation,
+				     TRole, RoleOrAff, RoleOrAffValue,
+				     ServiceAf) of
+		      nothing -> nothing;
+		      true -> true;
+		      check_owner ->
+			  case search_affiliation(owner, StateData) of
+			      [{OJID, _}] ->
+				  jid:remove_resource(OJID)
+				      /=
+				      jid:tolower(jid:remove_resource(UJID));
+			      _ -> true
+			  end;
+		      _ -> false
+		  end,
+    case CanChangeRA of
+	nothing ->
+	    find_changed_items(UJID, UAffiliation, URole,
+			       Items, Lang, StateData,
+			       Res);
+	true ->
+	    MoreRes = case RoleOrAff of
+			  affiliation ->
+			      [{jid:remove_resource(Jidx),
+				RoleOrAff, RoleOrAffValue, Reason}
+			       || Jidx <- JIDs];
+			  role ->
+			      [{Jidx, RoleOrAff, RoleOrAffValue, Reason}
+			       || Jidx <- JIDs]
+		      end,
+	    find_changed_items(UJID, UAffiliation, URole,
+			       Items, Lang, StateData,
+			       MoreRes ++ Res);
+	false ->
+	    Txt = <<"Changing role/affiliation is not allowed">>,
+	    throw({error, xmpp:err_not_allowed(Txt, Lang)})
+    end.
+
+-spec can_change_ra(affiliation(), role(), affiliation(), role(),
+		    affiliation, affiliation(), affiliation()) -> boolean() | nothing | check_owner;
+		   (affiliation(), role(), affiliation(), role(),
+		    role, role(), affiliation()) -> boolean() | nothing | check_owner.
+can_change_ra(_FAffiliation, _FRole, owner, _TRole,
+	      affiliation, owner, owner) ->
+    %% A room owner tries to add as persistent owner a
+    %% participant that is already owner because he is MUC admin
+    true;
+can_change_ra(_FAffiliation, _FRole, _TAffiliation,
+	      _TRole, _RoleorAffiliation, _Value, owner) ->
+    %% Nobody can decrease MUC admin's role/affiliation
+    false;
+can_change_ra(_FAffiliation, _FRole, TAffiliation,
+	      _TRole, affiliation, Value, _ServiceAf)
+    when TAffiliation == Value ->
+    nothing;
+can_change_ra(_FAffiliation, _FRole, _TAffiliation,
+	      TRole, role, Value, _ServiceAf)
+    when TRole == Value ->
+    nothing;
+can_change_ra(FAffiliation, _FRole, outcast, _TRole,
+	      affiliation, none, _ServiceAf)
+    when (FAffiliation == owner) or
+	   (FAffiliation == admin) ->
+    true;
+can_change_ra(FAffiliation, _FRole, outcast, _TRole,
+	      affiliation, member, _ServiceAf)
+    when (FAffiliation == owner) or
+	   (FAffiliation == admin) ->
+    true;
+can_change_ra(owner, _FRole, outcast, _TRole,
+	      affiliation, admin, _ServiceAf) ->
+    true;
+can_change_ra(owner, _FRole, outcast, _TRole,
+	      affiliation, owner, _ServiceAf) ->
+    true;
+can_change_ra(FAffiliation, _FRole, none, _TRole,
+	      affiliation, outcast, _ServiceAf)
+    when (FAffiliation == owner) or
+	   (FAffiliation == admin) ->
+    true;
+can_change_ra(FAffiliation, _FRole, none, _TRole,
+	      affiliation, member, _ServiceAf)
+    when (FAffiliation == owner) or
+	   (FAffiliation == admin) ->
+    true;
+can_change_ra(owner, _FRole, none, _TRole, affiliation,
+	      admin, _ServiceAf) ->
+    true;
+can_change_ra(owner, _FRole, none, _TRole, affiliation,
+	      owner, _ServiceAf) ->
+    true;
+can_change_ra(FAffiliation, _FRole, member, _TRole,
+	      affiliation, outcast, _ServiceAf)
+    when (FAffiliation == owner) or
+	   (FAffiliation == admin) ->
+    true;
+can_change_ra(FAffiliation, _FRole, member, _TRole,
+	      affiliation, none, _ServiceAf)
+    when (FAffiliation == owner) or
+	   (FAffiliation == admin) ->
+    true;
+can_change_ra(owner, _FRole, member, _TRole,
+	      affiliation, admin, _ServiceAf) ->
+    true;
+can_change_ra(owner, _FRole, member, _TRole,
+	      affiliation, owner, _ServiceAf) ->
+    true;
+can_change_ra(owner, _FRole, admin, _TRole, affiliation,
+	      _Affiliation, _ServiceAf) ->
+    true;
+can_change_ra(owner, _FRole, owner, _TRole, affiliation,
+	      _Affiliation, _ServiceAf) ->
+    check_owner;
+can_change_ra(_FAffiliation, _FRole, _TAffiliation,
+	      _TRole, affiliation, _Value, _ServiceAf) ->
+    false;
+can_change_ra(_FAffiliation, moderator, _TAffiliation,
+	      visitor, role, none, _ServiceAf) ->
+    true;
+can_change_ra(_FAffiliation, moderator, _TAffiliation,
+	      visitor, role, participant, _ServiceAf) ->
+    true;
+can_change_ra(FAffiliation, _FRole, _TAffiliation,
+	      visitor, role, moderator, _ServiceAf)
+    when (FAffiliation == owner) or
+	   (FAffiliation == admin) ->
+    true;
+can_change_ra(_FAffiliation, moderator, _TAffiliation,
+	      participant, role, none, _ServiceAf) ->
+    true;
+can_change_ra(_FAffiliation, moderator, _TAffiliation,
+	      participant, role, visitor, _ServiceAf) ->
+    true;
+can_change_ra(FAffiliation, _FRole, _TAffiliation,
+	      participant, role, moderator, _ServiceAf)
+    when (FAffiliation == owner) or
+	   (FAffiliation == admin) ->
+    true;
+can_change_ra(_FAffiliation, _FRole, owner, moderator,
+	      role, visitor, _ServiceAf) ->
+    false;
+can_change_ra(owner, _FRole, _TAffiliation, moderator,
+	      role, visitor, _ServiceAf) ->
+    true;
+can_change_ra(_FAffiliation, _FRole, admin, moderator,
+	      role, visitor, _ServiceAf) ->
+    false;
+can_change_ra(admin, _FRole, _TAffiliation, moderator,
+	      role, visitor, _ServiceAf) ->
+    true;
+can_change_ra(_FAffiliation, _FRole, owner, moderator,
+	      role, participant, _ServiceAf) ->
+    false;
+can_change_ra(owner, _FRole, _TAffiliation, moderator,
+	      role, participant, _ServiceAf) ->
+    true;
+can_change_ra(_FAffiliation, _FRole, admin, moderator,
+	      role, participant, _ServiceAf) ->
+    false;
+can_change_ra(admin, _FRole, _TAffiliation, moderator,
+	      role, participant, _ServiceAf) ->
+    true;
+can_change_ra(_FAffiliation, _FRole, _TAffiliation,
+	      _TRole, role, _Value, _ServiceAf) ->
+    false.
+
+-spec send_kickban_presence(undefined | jid(), jid(), binary(),
+			    pos_integer(), state()) -> ok.
+send_kickban_presence(UJID, JID, Reason, Code, StateData) ->
+    NewAffiliation = get_affiliation(JID, StateData),
+    send_kickban_presence(UJID, JID, Reason, Code, NewAffiliation,
+			  StateData).
+
+-spec send_kickban_presence(undefined | jid(), jid(), binary(), pos_integer(),
+			    affiliation(), state()) -> ok.
+send_kickban_presence(UJID, JID, Reason, Code, NewAffiliation,
+		      StateData) ->
+    LJID = jid:tolower(JID),
+    LJIDs = case LJID of
+	      {U, S, <<"">>} ->
+		  (?DICT):fold(fun (J, _, Js) ->
+				       case J of
+					 {U, S, _} -> [J | Js];
+					 _ -> Js
+				       end
+			       end,
+			       [], StateData#state.users);
+	      _ ->
+		  case (?DICT):is_key(LJID, StateData#state.users) of
+		    true -> [LJID];
+		    _ -> []
+		  end
+	    end,
+    lists:foreach(fun (J) ->
+			  {ok, #user{nick = Nick}} = (?DICT):find(J,
+								  StateData#state.users),
+			  add_to_log(kickban, {Nick, Reason, Code}, StateData),
+			  tab_remove_online_user(J, StateData),
+			  send_kickban_presence1(UJID, J, Reason, Code,
+						 NewAffiliation, StateData)
+		  end,
+		  LJIDs).
+
+-spec send_kickban_presence1(undefined | jid(), jid(), binary(), pos_integer(),
+			     affiliation(), state()) -> ok.
+send_kickban_presence1(MJID, UJID, Reason, Code, Affiliation,
+		       StateData) ->
+    {ok, #user{jid = RealJID, nick = Nick}} =
+	(?DICT):find(jid:tolower(UJID),
+		     StateData#state.users),
+    ActorNick = get_actor_nick(MJID, StateData),
+    lists:foreach(
+      fun({LJID, Info}) ->
+	      IsSelfPresence = jid:tolower(UJID) == LJID,
+	      Item0 = #muc_item{affiliation = Affiliation,
+				role = none},
+	      Item1 = case Info#user.role == moderator orelse
+			  (StateData#state.config)#config.anonymous
+			  == false orelse IsSelfPresence of
+			  true -> Item0#muc_item{jid = RealJID};
+			  false -> Item0
+		      end,
+	      Item2 = Item1#muc_item{reason = Reason},
+	      Item = case ActorNick of
+			 <<"">> -> Item2;
+			 _ -> Item2#muc_item{actor = #muc_actor{nick = ActorNick}}
+		     end,
+	      Codes = if IsSelfPresence -> [110, Code];
+			 true -> [Code]
+		      end,
+	      Packet = #presence{type = unavailable,
+				 sub_els = [#muc_user{items = [Item],
+						      status_codes = Codes}]},
+	      RoomJIDNick = jid:replace_resource(StateData#state.jid, Nick),
+	      send_wrapped(RoomJIDNick, Info#user.jid, Packet,
+			   ?NS_MUCSUB_NODES_AFFILIATIONS, StateData),
+			  IsSubscriber = is_subscriber(Info#user.jid, StateData),
+	      IsOccupant = Info#user.last_presence /= undefined,
+	      if (IsSubscriber and not IsOccupant) ->
+		      send_wrapped(RoomJIDNick, Info#user.jid, Packet,
+				   ?NS_MUCSUB_NODES_PARTICIPANTS, StateData);
+		 true ->
+		      ok
+	      end
+      end,
+		  (?DICT):to_list(get_users_and_subscribers(StateData))).
+
+-spec get_actor_nick(undefined | jid(), state()) -> binary().
+get_actor_nick(undefined, _StateData) ->
+    <<"">>;
+get_actor_nick(MJID, StateData) ->
+    case (?DICT):find(jid:tolower(MJID), StateData#state.users) of
+	{ok, #user{nick = ActorNick}} -> ActorNick;
+	_ -> <<"">>
+    end.
+
+convert_legacy_fields(Fs) ->
+    lists:map(
+      fun(#xdata_field{var = Var} = F) ->
+	      NewVar = case Var of
+			   <<"muc#roomconfig_allowvisitorstatus">> ->
+			       <<"allow_visitor_status">>;
+			   <<"muc#roomconfig_allowvisitornickchange">> ->
+			       <<"allow_visitor_nickchange">>;
+			   <<"muc#roomconfig_allowvoicerequests">> ->
+			       <<"allow_voice_requests">>;
+			   <<"muc#roomconfig_allow_subscription">> ->
+			       <<"allow_subscription">>;
+			   <<"muc#roomconfig_voicerequestmininterval">> ->
+			       <<"voice_request_min_interval">>;
+			   <<"muc#roomconfig_captcha_whitelist">> ->
+			       <<"captcha_whitelist">>;
+			   <<"muc#roomconfig_mam">> ->
+			       <<"mam">>;
+			   _ ->
+			       Var
+		       end,
+	      F#xdata_field{var = NewVar}
+      end, Fs).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% Owner stuff
+-spec process_iq_owner(jid(), iq(), state()) ->
+			      {result, undefined | muc_owner()} |
+			      {result, undefined | muc_owner(), state() | stop} |
+			      {error, stanza_error()}.
+process_iq_owner(From, #iq{type = set, lang = Lang,
+			   sub_els = [#muc_owner{destroy = Destroy,
+						 config = Config,
+						 items = Items}]},
+		 StateData) ->
+    FAffiliation = get_affiliation(From, StateData),
+    if FAffiliation /= owner ->
+	    ErrText = <<"Owner privileges required">>,
+	    {error, xmpp:err_forbidden(ErrText, Lang)};
+       Destroy /= undefined, Config == undefined, Items == [] ->
+	    ?INFO_MSG("Destroyed MUC room ~s by the owner ~s",
+		      [jid:encode(StateData#state.jid), jid:encode(From)]),
+	    add_to_log(room_existence, destroyed, StateData),
+	    destroy_room(Destroy, StateData);
+       Config /= undefined, Destroy == undefined, Items == [] ->
+	    case Config of
+		#xdata{type = cancel} ->
+		    {result, undefined};
+		#xdata{type = submit, fields = Fs} ->
+		    Fs1 = convert_legacy_fields(Fs),
+		    try muc_roomconfig:decode(Fs1) of
+			Options ->
+			    case is_allowed_log_change(Options, StateData, From) andalso
+				is_allowed_persistent_change(Options, StateData, From) andalso
+				is_allowed_room_name_desc_limits(Options, StateData) andalso
+				is_password_settings_correct(Options, StateData) of
+				true ->
+				    set_config(Options, StateData, Lang);
+				false ->
+				    {error, xmpp:err_not_acceptable()}
+			    end
+		    catch _:{muc_roomconfig, Why} ->
+			    Txt = muc_roomconfig:format_error(Why),
+			    {error, xmpp:err_bad_request(Txt, Lang)}
+		    end;
+		_ ->
+		    Txt = <<"Incorrect data form">>,
+		    {error, xmpp:err_bad_request(Txt, Lang)}
+	    end;
+       Items /= [], Config == undefined, Destroy == undefined ->
+	    process_admin_items_set(From, Items, Lang, StateData);
+       true ->
+	    {error, xmpp:err_bad_request()}
+    end;
+process_iq_owner(From, #iq{type = get, lang = Lang,
+			   sub_els = [#muc_owner{destroy = Destroy,
+						 config = Config,
+						 items = Items}]},
+		 StateData) ->
+    FAffiliation = get_affiliation(From, StateData),
+    if FAffiliation /= owner ->
+	    ErrText = <<"Owner privileges required">>,
+	    {error, xmpp:err_forbidden(ErrText, Lang)};
+       Destroy == undefined, Config == undefined ->
+	    case Items of
+		[] ->
+		    {result,
+		     #muc_owner{config = get_config(Lang, StateData, From)}};
+		[#muc_item{affiliation = undefined}] ->
+		    Txt = <<"No 'affiliation' attribute found">>,
+		    {error, xmpp:err_bad_request(Txt, Lang)};
+		[#muc_item{affiliation = Affiliation}] ->
+		    Items = items_with_affiliation(Affiliation, StateData),
+		    {result, #muc_owner{items = Items}};
+		[_|_] ->
+		    Txt = <<"Too many <item/> elements">>,
+		    {error, xmpp:err_bad_request(Txt, Lang)}
+	    end;
+       true ->
+	    {error, xmpp:err_bad_request()}
+    end.
+
+-spec is_allowed_log_change(muc_roomconfig:result(), state(), jid()) -> boolean().
+is_allowed_log_change(Options, StateData, From) ->
+    case proplists:is_defined(enablelogging, Options) of
+	false -> true;
+	true ->
+	    allow ==
+		mod_muc_log:check_access_log(StateData#state.server_host,
+					     From)
+    end.
+
+-spec is_allowed_persistent_change(muc_roomconfig:result(), state(), jid()) -> boolean().
+is_allowed_persistent_change(Options, StateData, From) ->
+    case proplists:is_defined(persistentroom, Options) of
+      false -> true;
+      true ->
+	  {_AccessRoute, _AccessCreate, _AccessAdmin,
+	   AccessPersistent} =
+	      StateData#state.access,
+	  allow ==
+	    acl:match_rule(StateData#state.server_host,
+			   AccessPersistent, From)
+    end.
+
+%% Check if the Room Name and Room Description defined in the Data Form
+%% are conformant to the configured limits
+-spec is_allowed_room_name_desc_limits(muc_roomconfig:result(), state()) -> boolean().
+is_allowed_room_name_desc_limits(Options, StateData) ->
+    RoomName = proplists:get_value(roomname, Options, <<"">>),
+    RoomDesc = proplists:get_value(roomdesc, Options, <<"">>),
+    MaxRoomName = gen_mod:get_module_opt(
+		    StateData#state.server_host,
+		    mod_muc, max_room_name),
+    MaxRoomDesc = gen_mod:get_module_opt(
+		    StateData#state.server_host,
+		    mod_muc, max_room_desc),
+    (byte_size(RoomName) =< MaxRoomName)
+	andalso (byte_size(RoomDesc) =< MaxRoomDesc).
+
+%% Return false if:
+%% "the password for a password-protected room is blank"
+-spec is_password_settings_correct(muc_roomconfig:result(), state()) -> boolean().
+is_password_settings_correct(Options, StateData) ->
+    Config = StateData#state.config,
+    OldProtected = Config#config.password_protected,
+    OldPassword = Config#config.password,
+    NewProtected = proplists:get_value(passwordprotectedroom, Options),
+    NewPassword = proplists:get_value(roomsecret, Options),
+    case {OldProtected, NewProtected, OldPassword, NewPassword} of
+	{true, undefined, <<"">>, undefined} -> false;
+	{true, undefined, _, <<"">>} -> false;
+	{_, true, <<"">>, undefined} -> false;
+	{_, true, _, <<"">>} -> false;
+	_ -> true
+    end.
+
+-spec get_default_room_maxusers(state()) -> non_neg_integer().
+get_default_room_maxusers(RoomState) ->
+    DefRoomOpts =
+	gen_mod:get_module_opt(RoomState#state.server_host,
+			       mod_muc, default_room_options),
+    RoomState2 = set_opts(DefRoomOpts, RoomState),
+    (RoomState2#state.config)#config.max_users.
+
+-spec get_config(binary(), state(), jid()) -> xdata().
+get_config(Lang, StateData, From) ->
+    {_AccessRoute, _AccessCreate, _AccessAdmin, AccessPersistent} =
+	StateData#state.access,
+    ServiceMaxUsers = get_service_max_users(StateData),
+    DefaultRoomMaxUsers = get_default_room_maxusers(StateData),
+    Config = StateData#state.config,
+    MaxUsersRoom = get_max_users(StateData),
+    Title = str:format(
+	      translate:translate(Lang, <<"Configuration of room ~s">>),
+	      [jid:encode(StateData#state.jid)]),
+    Fs = [{roomname, Config#config.title},
+	  {roomdesc, Config#config.description},
+	  {lang, Config#config.lang}] ++
+	case acl:match_rule(StateData#state.server_host, AccessPersistent, From) of
+	    allow -> [{persistentroom, Config#config.persistent}];
+	    deny -> []
+	end ++
+	[{publicroom, Config#config.public},
+	 {public_list, Config#config.public_list},
+	 {passwordprotectedroom, Config#config.password_protected},
+	 {roomsecret, case Config#config.password_protected of
+			  true -> Config#config.password;
+			  false -> <<"">>
+		      end},
+	 {maxusers, MaxUsersRoom,
+	  [if is_integer(ServiceMaxUsers) -> [];
+	      true -> [{<<"No limit">>, <<"none">>}]
+	   end] ++ [{integer_to_binary(N), N}
+		    || N <- lists:usort([ServiceMaxUsers,
+					 DefaultRoomMaxUsers,
+					 MaxUsersRoom
+					 | ?MAX_USERS_DEFAULT_LIST]),
+		       N =< ServiceMaxUsers]},
+	 {whois, if Config#config.anonymous -> moderators;
+		    true -> anyone
+		 end},
+	 {presencebroadcast, Config#config.presence_broadcast},
+	 {membersonly, Config#config.members_only},
+	 {moderatedroom, Config#config.moderated},
+	 {members_by_default, Config#config.members_by_default},
+	 {changesubject, Config#config.allow_change_subj},
+	 {allow_private_messages, Config#config.allow_private_messages},
+	 {allow_private_messages_from_visitors,
+	  Config#config.allow_private_messages_from_visitors},
+	 {allow_query_users, Config#config.allow_query_users},
+	 {allowinvites, Config#config.allow_user_invites},
+	 {allow_visitor_status, Config#config.allow_visitor_status},
+	 {allow_visitor_nickchange, Config#config.allow_visitor_nickchange},
+	 {allow_voice_requests, Config#config.allow_voice_requests},
+	 {allow_subscription, Config#config.allow_subscription},
+	 {voice_request_min_interval, Config#config.voice_request_min_interval},
+	 {pubsub, Config#config.pubsub}]
+	++
+	case ejabberd_captcha:is_feature_available() of
+	    true -> [{captcha_protected, Config#config.captcha_protected}];
+	    false -> []
+	end ++
+	[{captcha_whitelist,
+	  lists:map(fun jid:make/1, ?SETS:to_list(Config#config.captcha_whitelist))}]
+	++
+	case mod_muc_log:check_access_log(StateData#state.server_host, From) of
+	    allow -> [{enablelogging, Config#config.logging}];
+	    deny -> []
+	end,
+    Fields = ejabberd_hooks:run_fold(get_room_config,
+				     StateData#state.server_host,
+				     Fs,
+				     [StateData, From, Lang]),
+    #xdata{type = form, title = Title,
+	   fields = muc_roomconfig:encode(Fields, Lang)}.
+
+-spec set_config(muc_roomconfig:result(), state(), binary()) ->
+			{error, stanza_error()} | {result, undefined, state()}.
+set_config(Options, StateData, Lang) ->
+    try
+	#config{} = Config = set_config(Options, StateData#state.config,
+					StateData#state.server_host, Lang),
+	{result, _, NSD} = Res = change_config(Config, StateData),
+	Type = case {(StateData#state.config)#config.logging,
+		     Config#config.logging}
+	       of
+		   {true, false} -> roomconfig_change_disabledlogging;
+		   {false, true} -> roomconfig_change_enabledlogging;
+		   {_, _} -> roomconfig_change
+	       end,
+	Users = [{U#user.jid, U#user.nick, U#user.role}
+		 || {_, U} <- (?DICT):to_list(StateData#state.users)],
+	add_to_log(Type, Users, NSD),
+	Res
+    catch  _:{badmatch, {error, #stanza_error{}} = Err} ->
+	    Err
+    end.
+
+get_config_opt_name(Pos) ->
+    Fs = [config|record_info(fields, config)],
+    lists:nth(Pos, Fs).
+
+-spec set_config([muc_roomconfig:property()], #config{},
+		  binary(), binary()) -> #config{} | {error, stanza_error()}.
+set_config(Opts, Config, ServerHost, Lang) ->
+    lists:foldl(
+      fun(_, {error, _} = Err) -> Err;
+	 ({roomname, Title}, C) -> C#config{title = Title};
+	 ({roomdesc, Desc}, C) -> C#config{description = Desc};
+	 ({changesubject, V}, C) -> C#config{allow_change_subj = V};
+	 ({allow_query_users, V}, C) -> C#config{allow_query_users = V};
+	 ({allow_private_messages, V}, C) ->
+	      C#config{allow_private_messages = V};
+	 ({allow_private_messages_from_visitors, V}, C) ->
+	      C#config{allow_private_messages_from_visitors = V};
+	 ({allow_visitor_status, V}, C) -> C#config{allow_visitor_status = V};
+	 ({allow_visitor_nickchange, V}, C) ->
+	      C#config{allow_visitor_nickchange = V};
+	 ({publicroom, V}, C) -> C#config{public = V};
+	 ({public_list, V}, C) -> C#config{public_list = V};
+	 ({persistentroom, V}, C) -> C#config{persistent = V};
+	 ({moderatedroom, V}, C) -> C#config{moderated = V};
+	 ({members_by_default, V}, C) -> C#config{members_by_default = V};
+	 ({membersonly, V}, C) -> C#config{members_only = V};
+	 ({captcha_protected, V}, C) -> C#config{captcha_protected = V};
+	 ({allowinvites, V}, C) -> C#config{allow_user_invites = V};
+	 ({allow_subscription, V}, C) -> C#config{allow_subscription = V};
+	 ({passwordprotectedroom, V}, C) -> C#config{password_protected = V};
+	 ({roomsecret, V}, C) -> C#config{password = V};
+	 ({anonymous, V}, C) -> C#config{anonymous = V};
+	 ({presencebroadcast, V}, C) -> C#config{presence_broadcast = V};
+	 ({allow_voice_requests, V}, C) -> C#config{allow_voice_requests = V};
+	 ({voice_request_min_interval, V}, C) ->
+	      C#config{voice_request_min_interval = V};
+	 ({whois, moderators}, C) -> C#config{anonymous = true};
+	 ({whois, anyone}, C) -> C#config{anonymous = false};
+	 ({maxusers, V}, C) -> C#config{max_users = V};
+	 ({enablelogging, V}, C) -> C#config{logging = V};
+	 ({pubsub, V}, C) -> C#config{pubsub = V};
+	 ({lang, L}, C) -> C#config{lang = L};
+	 ({captcha_whitelist, Js}, C) ->
+	      LJIDs = [jid:tolower(J) || J <- Js],
+	      C#config{captcha_whitelist = ?SETS:from_list(LJIDs)};
+	 ({O, V} = Opt, C) ->
+	      case ejabberd_hooks:run_fold(set_room_option,
+					   ServerHost,
+					   {0, undefined},
+					   [Opt, Lang]) of
+		  {0, undefined} ->
+		      ?ERROR_MSG("set_room_option hook failed for "
+				 "option '~s' with value ~p", [O, V]),
+		      Txt = {<<"Failed to process option '~s'">>, [O]},
+		      {error, xmpp:err_internal_server_error(Txt, Lang)};
+		  {Pos, Val} ->
+		      setelement(Pos, C, Val)
+	      end
+      end, Config, Opts).
+
+-spec change_config(#config{}, state()) -> {result, undefined, state()}.
+change_config(Config, StateData) ->
+    send_config_change_info(Config, StateData),
+    StateData0 = StateData#state{config = Config},
+    StateData1 = remove_subscriptions(StateData0),
+    StateData2 =
+        case {(StateData#state.config)#config.persistent,
+              Config#config.persistent} of
+            {WasPersistent, true} ->
+                if not WasPersistent ->
+                        set_affiliations(StateData1#state.affiliations,
+                                         StateData1);
+                   true ->
+                        ok
+                end,
+                store_room(StateData1),
+                StateData1;
+            {true, false} ->
+                Affiliations = get_affiliations(StateData),
+                mod_muc:forget_room(StateData1#state.server_host,
+                                    StateData1#state.host,
+                                    StateData1#state.room),
+                StateData1#state{affiliations = Affiliations};
+            {false, false} ->
+                StateData1
+        end,
+    case {(StateData#state.config)#config.members_only,
+	  Config#config.members_only} of
+        {false, true} ->
+            StateData3 = remove_nonmembers(StateData2),
+            {result, undefined, StateData3};
+        _ ->
+            {result, undefined, StateData2}
+    end.
+
+-spec send_config_change_info(#config{}, state()) -> ok.
+send_config_change_info(Config, #state{config = Config}) -> ok;
+send_config_change_info(New, #state{config = Old} = StateData) ->
+    Codes = case {Old#config.logging, New#config.logging} of
+	      {false, true} -> [170];
+	      {true, false} -> [171];
+	      _ -> []
+	    end
+	      ++
+	      case {Old#config.anonymous, New#config.anonymous} of
+		{true, false} -> [172];
+		{false, true} -> [173];
+		_ -> []
+	      end
+		++
+		case Old#config{anonymous = New#config.anonymous,
+				logging = New#config.logging} of
+		  New -> [];
+		  _ -> [104]
+		end,
+    if Codes /= [] ->
+	    lists:foreach(
+	      fun({_LJID, #user{jid = JID}}) ->
+		      send_self_presence(JID, StateData#state{config = New})
+	      end, ?DICT:to_list(StateData#state.users)),
+	    Message = #message{type = groupchat,
+			       id = randoms:get_string(),
+			       sub_els = [#muc_user{status_codes = Codes}]},
+	    send_wrapped_multiple(StateData#state.jid,
+			  get_users_and_subscribers(StateData),
+				  Message,
+				  ?NS_MUCSUB_NODES_CONFIG,
+				  StateData);
+       true ->
+	    ok
+    end.
+
+-spec remove_nonmembers(state()) -> state().
+remove_nonmembers(StateData) ->
+    lists:foldl(fun ({_LJID, #user{jid = JID}}, SD) ->
+			Affiliation = get_affiliation(JID, SD),
+			case Affiliation of
+			  none ->
+			      catch send_kickban_presence(undefined, JID, <<"">>,
+							  322, SD),
+			      set_role(JID, none, SD);
+			  _ -> SD
+			end
+		end,
+		StateData, (?DICT):to_list(get_users_and_subscribers(StateData))).
+
+-spec set_opts([{atom(), any()}], state()) -> state().
+set_opts([], StateData) ->
+    set_vcard_xupdate(StateData);
+set_opts([{Opt, Val} | Opts], StateData) ->
+    NSD = case Opt of
+	    title ->
+		StateData#state{config =
+				    (StateData#state.config)#config{title =
+									Val}};
+	    description ->
+		StateData#state{config =
+				    (StateData#state.config)#config{description
+									= Val}};
+	    allow_change_subj ->
+		StateData#state{config =
+				    (StateData#state.config)#config{allow_change_subj
+									= Val}};
+	    allow_query_users ->
+		StateData#state{config =
+				    (StateData#state.config)#config{allow_query_users
+									= Val}};
+	    allow_private_messages ->
+		StateData#state{config =
+				    (StateData#state.config)#config{allow_private_messages
+									= Val}};
+	    allow_private_messages_from_visitors ->
+		StateData#state{config =
+				    (StateData#state.config)#config{allow_private_messages_from_visitors
+									= Val}};
+	    allow_visitor_nickchange ->
+		StateData#state{config =
+				    (StateData#state.config)#config{allow_visitor_nickchange
+									= Val}};
+	    allow_visitor_status ->
+		StateData#state{config =
+				    (StateData#state.config)#config{allow_visitor_status
+									= Val}};
+	    public ->
+		StateData#state{config =
+				    (StateData#state.config)#config{public =
+									Val}};
+	    public_list ->
+		StateData#state{config =
+				    (StateData#state.config)#config{public_list
+									= Val}};
+	    persistent ->
+		StateData#state{config =
+				    (StateData#state.config)#config{persistent =
+									Val}};
+	    moderated ->
+		StateData#state{config =
+				    (StateData#state.config)#config{moderated =
+									Val}};
+	    members_by_default ->
+		StateData#state{config =
+				    (StateData#state.config)#config{members_by_default
+									= Val}};
+	    members_only ->
+		StateData#state{config =
+				    (StateData#state.config)#config{members_only
+									= Val}};
+	    allow_user_invites ->
+		StateData#state{config =
+				    (StateData#state.config)#config{allow_user_invites
+									= Val}};
+	    password_protected ->
+		StateData#state{config =
+				    (StateData#state.config)#config{password_protected
+									= Val}};
+	    captcha_protected ->
+		StateData#state{config =
+				    (StateData#state.config)#config{captcha_protected
+									= Val}};
+	    password ->
+		StateData#state{config =
+				    (StateData#state.config)#config{password =
+									Val}};
+	    anonymous ->
+		StateData#state{config =
+				    (StateData#state.config)#config{anonymous =
+									Val}};
+	    presence_broadcast ->
+		StateData#state{config =
+				    (StateData#state.config)#config{presence_broadcast =
+									Val}};
+	    logging ->
+		StateData#state{config =
+				    (StateData#state.config)#config{logging =
+									Val}};
+	    mam ->
+		StateData#state{config =
+				    (StateData#state.config)#config{mam = Val}};
+	    captcha_whitelist ->
+		StateData#state{config =
+				    (StateData#state.config)#config{captcha_whitelist
+									=
+									(?SETS):from_list(Val)}};
+	    allow_voice_requests ->
+		StateData#state{config =
+				    (StateData#state.config)#config{allow_voice_requests
+									= Val}};
+	    voice_request_min_interval ->
+		StateData#state{config =
+				    (StateData#state.config)#config{voice_request_min_interval
+									= Val}};
+	    max_users ->
+		ServiceMaxUsers = get_service_max_users(StateData),
+		MaxUsers = if Val =< ServiceMaxUsers -> Val;
+			      true -> ServiceMaxUsers
+			   end,
+		StateData#state{config =
+				    (StateData#state.config)#config{max_users =
+									MaxUsers}};
+	    vcard ->
+		StateData#state{config =
+				    (StateData#state.config)#config{vcard =
+									Val}};
+	    vcard_xupdate ->
+		StateData#state{config =
+				    (StateData#state.config)#config{vcard_xupdate =
+									Val}};
+	    pubsub ->
+		StateData#state{config =
+				    (StateData#state.config)#config{pubsub = Val}};
+	    allow_subscription ->
+		StateData#state{config =
+				    (StateData#state.config)#config{allow_subscription = Val}};
+	    lang ->
+		StateData#state{config =
+				    (StateData#state.config)#config{lang = Val}};
+	    subscribers ->
+		  {Subscribers, Nicks} =
+		      lists:foldl(
+			fun({JID, Nick, Nodes}, {SubAcc, NickAcc}) ->
+				BareJID = jid:remove_resource(JID),
+				{?DICT:store(
+				    jid:tolower(BareJID),
+				    #subscriber{jid = BareJID,
+						nick = Nick,
+						nodes = Nodes},
+				    SubAcc),
+				 ?DICT:store(Nick, [jid:tolower(BareJID)], NickAcc)}
+			end, {?DICT:new(), ?DICT:new()}, Val),
+		  StateData#state{subscribers = Subscribers,
+				  subscriber_nicks = Nicks};
+	    affiliations ->
+		StateData#state{affiliations = (?DICT):from_list(Val)};
+	    subject ->
+		  Subj = if Val == <<"">> -> [];
+			    is_binary(Val) -> [#text{data = Val}];
+			    is_list(Val) -> Val
+			 end,
+		  StateData#state{subject = Subj};
+	    subject_author -> StateData#state{subject_author = Val};
+	    _ -> StateData
+	  end,
+    set_opts(Opts, NSD).
+
+set_vcard_xupdate(#state{config =
+			     #config{vcard = VCardRaw,
+				     vcard_xupdate = undefined} = Config} = State)
+  when VCardRaw /= <<"">> ->
+    case fxml_stream:parse_element(VCardRaw) of
+	{error, _} ->
+	    State;
+	El ->
+	    Hash = mod_vcard_xupdate:compute_hash(El),
+	    State#state{config = Config#config{vcard_xupdate = Hash}}
+    end;
+set_vcard_xupdate(State) ->
+    State.
+
+-define(MAKE_CONFIG_OPT(Opt),
+	{get_config_opt_name(Opt), element(Opt, Config)}).
+
+-spec make_opts(state()) -> [{atom(), any()}].
+make_opts(StateData) ->
+    Config = StateData#state.config,
+    Subscribers = (?DICT):fold(
+		    fun(_LJID, Sub, Acc) ->
+			    [{Sub#subscriber.jid,
+			      Sub#subscriber.nick,
+			      Sub#subscriber.nodes}|Acc]
+		    end, [], StateData#state.subscribers),
+    [?MAKE_CONFIG_OPT(#config.title), ?MAKE_CONFIG_OPT(#config.description),
+     ?MAKE_CONFIG_OPT(#config.allow_change_subj),
+     ?MAKE_CONFIG_OPT(#config.allow_query_users),
+     ?MAKE_CONFIG_OPT(#config.allow_private_messages),
+     ?MAKE_CONFIG_OPT(#config.allow_private_messages_from_visitors),
+     ?MAKE_CONFIG_OPT(#config.allow_visitor_status),
+     ?MAKE_CONFIG_OPT(#config.allow_visitor_nickchange),
+     ?MAKE_CONFIG_OPT(#config.public), ?MAKE_CONFIG_OPT(#config.public_list),
+     ?MAKE_CONFIG_OPT(#config.persistent),
+     ?MAKE_CONFIG_OPT(#config.moderated),
+     ?MAKE_CONFIG_OPT(#config.members_by_default),
+     ?MAKE_CONFIG_OPT(#config.members_only),
+     ?MAKE_CONFIG_OPT(#config.allow_user_invites),
+     ?MAKE_CONFIG_OPT(#config.password_protected),
+     ?MAKE_CONFIG_OPT(#config.captcha_protected),
+     ?MAKE_CONFIG_OPT(#config.password), ?MAKE_CONFIG_OPT(#config.anonymous),
+     ?MAKE_CONFIG_OPT(#config.logging), ?MAKE_CONFIG_OPT(#config.max_users),
+     ?MAKE_CONFIG_OPT(#config.allow_voice_requests),
+     ?MAKE_CONFIG_OPT(#config.allow_subscription),
+     ?MAKE_CONFIG_OPT(#config.mam),
+     ?MAKE_CONFIG_OPT(#config.presence_broadcast),
+     ?MAKE_CONFIG_OPT(#config.voice_request_min_interval),
+     ?MAKE_CONFIG_OPT(#config.vcard),
+     ?MAKE_CONFIG_OPT(#config.vcard_xupdate),
+     ?MAKE_CONFIG_OPT(#config.pubsub),
+     ?MAKE_CONFIG_OPT(#config.lang),
+     {captcha_whitelist,
+      (?SETS):to_list((StateData#state.config)#config.captcha_whitelist)},
+     {affiliations,
+      (?DICT):to_list(StateData#state.affiliations)},
+     {subject, StateData#state.subject},
+     {subject_author, StateData#state.subject_author},
+     {subscribers, Subscribers}].
+
+expand_opts(CompactOpts) ->
+    DefConfig = #config{},
+    Fields = record_info(fields, config),
+    {_, Opts1} =
+        lists:foldl(
+          fun(Field, {Pos, Opts}) ->
+                  case lists:keyfind(Field, 1, CompactOpts) of
+                      false ->
+                          DefV = element(Pos, DefConfig),
+                          DefVal = case (?SETS):is_set(DefV) of
+                                       true -> (?SETS):to_list(DefV);
+                                       false -> DefV
+                                   end,
+                          {Pos+1, [{Field, DefVal}|Opts]};
+                      {_, Val} ->
+                          {Pos+1, [{Field, Val}|Opts]}
+                  end
+          end, {2, []}, Fields),
+    SubjectAuthor = proplists:get_value(subject_author, CompactOpts, <<"">>),
+    Subject = proplists:get_value(subject, CompactOpts, <<"">>),
+    Subscribers = proplists:get_value(subscribers, CompactOpts, []),
+    [{subject, Subject},
+     {subject_author, SubjectAuthor},
+     {subscribers, Subscribers}
+     | lists:reverse(Opts1)].
+
+config_fields() ->
+    [subject, subject_author, subscribers | record_info(fields, config)].
+
+-spec destroy_room(muc_destroy(), state()) -> {result, undefined, stop}.
+destroy_room(DEl, StateData) ->
+    Destroy = DEl#muc_destroy{xmlns = ?NS_MUC_USER},
+    lists:foreach(
+      fun({_LJID, Info}) ->
+	      Nick = Info#user.nick,
+	      Item = #muc_item{affiliation = none,
+			       role = none},
+	      Packet = #presence{
+			  type = unavailable,
+			  sub_els = [#muc_user{items = [Item],
+					       destroy = Destroy}]},
+	      send_wrapped(jid:replace_resource(StateData#state.jid, Nick),
+			   Info#user.jid, Packet,
+			   ?NS_MUCSUB_NODES_CONFIG, StateData)
+      end,
+		  (?DICT):to_list(get_users_and_subscribers(StateData))),
+    case (StateData#state.config)#config.persistent of
+      true ->
+	  mod_muc:forget_room(StateData#state.server_host,
+			      StateData#state.host, StateData#state.room);
+      false -> ok
+    end,
+    {result, undefined, stop}.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% Disco
+
+-define(CONFIG_OPT_TO_FEATURE(Opt, Fiftrue, Fiffalse),
+	case Opt of
+	  true -> Fiftrue;
+	  false -> Fiffalse
+	end).
+
+-spec make_disco_info(jid(), state()) -> disco_info().
+make_disco_info(_From, StateData) ->
+    Config = StateData#state.config,
+    Feats = [?NS_VCARD, ?NS_MUC,
+	     ?CONFIG_OPT_TO_FEATURE((Config#config.public),
+				    <<"muc_public">>, <<"muc_hidden">>),
+	     ?CONFIG_OPT_TO_FEATURE((Config#config.persistent),
+				    <<"muc_persistent">>, <<"muc_temporary">>),
+	     ?CONFIG_OPT_TO_FEATURE((Config#config.members_only),
+				    <<"muc_membersonly">>, <<"muc_open">>),
+	     ?CONFIG_OPT_TO_FEATURE((Config#config.anonymous),
+				    <<"muc_semianonymous">>, <<"muc_nonanonymous">>),
+	     ?CONFIG_OPT_TO_FEATURE((Config#config.moderated),
+				    <<"muc_moderated">>, <<"muc_unmoderated">>),
+	     ?CONFIG_OPT_TO_FEATURE((Config#config.password_protected),
+				    <<"muc_passwordprotected">>, <<"muc_unsecured">>)]
+	++ case Config#config.allow_subscription of
+	       true -> [?NS_MUCSUB];
+	       false -> []
+	   end
+	++ case {gen_mod:is_loaded(StateData#state.server_host, mod_mam),
+		 Config#config.mam} of
+	       {true, true} ->
+		   [?NS_MAM_TMP, ?NS_MAM_0, ?NS_MAM_1, ?NS_MAM_2, ?NS_SID_0];
+	       _ ->
+		   []
+	   end,
+    #disco_info{identities = [#identity{category = <<"conference">>,
+					type = <<"text">>,
+					name = get_title(StateData)}],
+		features = Feats}.
+
+-spec process_iq_disco_info(jid(), iq(), state()) ->
+				   {result, disco_info()} | {error, stanza_error()}.
+process_iq_disco_info(_From, #iq{type = set, lang = Lang}, _StateData) ->
+    Txt = <<"Value 'set' of 'type' attribute is not allowed">>,
+    {error, xmpp:err_not_allowed(Txt, Lang)};
+process_iq_disco_info(From, #iq{type = get, lang = Lang,
+				sub_els = [#disco_info{node = <<>>}]},
+		      StateData) ->
+    DiscoInfo = make_disco_info(From, StateData),
+    Extras = iq_disco_info_extras(Lang, StateData, false),
+    {result, DiscoInfo#disco_info{xdata = [Extras]}};
+process_iq_disco_info(From, #iq{type = get, lang = Lang,
+				sub_els = [#disco_info{node = Node}]},
+		      StateData) ->
+    try
+	true = mod_caps:is_valid_node(Node),
+	DiscoInfo = make_disco_info(From, StateData),
+	Hash = mod_caps:compute_disco_hash(DiscoInfo, sha),
+	Node = <<(ejabberd_config:get_uri())/binary, $#, Hash/binary>>,
+	Extras = iq_disco_info_extras(Lang, StateData, true),
+	{result, DiscoInfo#disco_info{node = Node, xdata = [Extras]}}
+    catch _:{badmatch, _} ->
+	    Txt = <<"Invalid node name">>,
+	    {error, xmpp:err_item_not_found(Txt, Lang)}
+    end.
+
+-spec iq_disco_info_extras(binary(), state(), boolean()) -> xdata().
+iq_disco_info_extras(Lang, StateData, Static) ->
+    Config = StateData#state.config,
+    AllowPM = case Config#config.allow_private_messages of
+		  false -> none;
+		  true ->
+		      case Config#config.allow_private_messages_from_visitors of
+			  nobody -> participants;
+			  _ -> anyone
+		      end
+	      end,
+    Fs1 = [{roomname, Config#config.title},
+	   {description, Config#config.description},
+	   {contactjid, get_owners(StateData)},
+	   {changesubject, Config#config.allow_change_subj},
+	   {allowinvites, Config#config.allow_user_invites},
+	   {allowpm, AllowPM},
+	   {lang, Config#config.lang}],
+    Fs2 = case Config#config.pubsub of
+	      Node when is_binary(Node), Node /= <<"">> ->
+		  [{pubsub, Node}|Fs1];
+	      _ ->
+		  Fs1
+	  end,
+    Fs3 = case Static of
+	      false ->
+		  [{occupants, ?DICT:size(StateData#state.nicks)}|Fs2];
+	      true ->
+		  Fs2
+	  end,
+    #xdata{type = result,
+	   fields = muc_roominfo:encode(Fs3, Lang)}.
+
+-spec process_iq_disco_items(jid(), iq(), state()) ->
+				    {error, stanza_error()} | {result, disco_items()}.
+process_iq_disco_items(_From, #iq{type = set, lang = Lang}, _StateData) ->
+    Txt = <<"Value 'set' of 'type' attribute is not allowed">>,
+    {error, xmpp:err_not_allowed(Txt, Lang)};
+process_iq_disco_items(From, #iq{type = get}, StateData) ->
+    case (StateData#state.config)#config.public_list of
+      true ->
+	  {result, get_mucroom_disco_items(StateData)};
+      _ ->
+	  case is_occupant_or_admin(From, StateData) of
+	    true ->
+		{result, get_mucroom_disco_items(StateData)};
+	    _ ->
+		%% If the list of occupants is private,
+		%% the room MUST return an empty <query/> element
+		%% (http://xmpp.org/extensions/xep-0045.html#disco-roomitems)
+		{result, #disco_items{}}
+	  end
+    end.
+
+-spec process_iq_captcha(jid(), iq(), state()) -> {error, stanza_error()} |
+						  {result, undefined}.
+process_iq_captcha(_From, #iq{type = get, lang = Lang}, _StateData) ->
+    Txt = <<"Value 'get' of 'type' attribute is not allowed">>,
+    {error, xmpp:err_not_allowed(Txt, Lang)};
+process_iq_captcha(_From, #iq{type = set, lang = Lang, sub_els = [SubEl]},
+		   _StateData) ->
+    case ejabberd_captcha:process_reply(SubEl) of
+      ok -> {result, undefined};
+      {error, malformed} ->
+	    Txt = <<"Incorrect CAPTCHA submit">>,
+	    {error, xmpp:err_bad_request(Txt, Lang)};
+      _ ->
+	    Txt = <<"The CAPTCHA verification has failed">>,
+	    {error, xmpp:err_not_allowed(Txt, Lang)}
+    end.
+
+-spec process_iq_vcard(jid(), iq(), state()) ->
+			      {result, vcard_temp() | xmlel()} |
+			      {result, undefined, state()} |
+			      {error, stanza_error()}.
+process_iq_vcard(_From, #iq{type = get}, StateData) ->
+    #state{config = #config{vcard = VCardRaw}} = StateData,
+    case fxml_stream:parse_element(VCardRaw) of
+	#xmlel{} = VCard ->
+	    {result, VCard};
+	{error, _} ->
+	    {error, xmpp:err_item_not_found()}
+    end;
+process_iq_vcard(From, #iq{type = set, lang = Lang, sub_els = [Pkt]},
+		 StateData) ->
+    case get_affiliation(From, StateData) of
+	owner ->
+	    SubEl = xmpp:encode(Pkt),
+	    VCardRaw = fxml:element_to_binary(SubEl),
+	    Hash = mod_vcard_xupdate:compute_hash(SubEl),
+	    Config = StateData#state.config,
+	    NewConfig = Config#config{vcard = VCardRaw, vcard_xupdate = Hash},
+	    change_config(NewConfig, StateData);
+	_ ->
+	    ErrText = <<"Owner privileges required">>,
+	    {error, xmpp:err_forbidden(ErrText, Lang)}
+    end.
+
+-spec process_iq_mucsub(jid(), iq(), state()) ->
+      {error, stanza_error()} |
+      {result, undefined | muc_subscribe() | muc_subscriptions(), state()} |
+      {ignore, state()}.
+process_iq_mucsub(_From, #iq{type = set, lang = Lang,
+			     sub_els = [#muc_subscribe{}]},
+		  #state{just_created = false, config = #config{allow_subscription = false}}) ->
+    {error, xmpp:err_not_allowed(<<"Subscriptions are not allowed">>, Lang)};
+process_iq_mucsub(From,
+		  #iq{type = set, lang = Lang,
+		      sub_els = [#muc_subscribe{jid = #jid{} = SubJid} = Mucsub]},
+		  StateData) ->
+    FAffiliation = get_affiliation(From, StateData),
+    FRole = get_role(From, StateData),
+    if FRole == moderator; FAffiliation == owner; FAffiliation == admin ->
+	    process_iq_mucsub(SubJid,
+			      #iq{type = set, lang = Lang,
+				  sub_els = [Mucsub#muc_subscribe{jid = undefined}]},
+			      StateData);
+       true ->
+	    Txt = <<"Moderator privileges required">>,
+	    {error, xmpp:err_forbidden(Txt, Lang)}
+    end;
+process_iq_mucsub(From,
+		  #iq{type = set, lang = Lang,
+		      sub_els = [#muc_subscribe{nick = Nick}]} = Packet,
+		  StateData) ->
+    LBareJID = jid:tolower(jid:remove_resource(From)),
+    case (?DICT):find(LBareJID, StateData#state.subscribers) of
+	{ok, #subscriber{nick = Nick1}} when Nick1 /= Nick ->
+	    Nodes = get_subscription_nodes(Packet),
+	    case {nick_collision(From, Nick, StateData),
+		  mod_muc:can_use_nick(StateData#state.server_host,
+				       StateData#state.host,
+				       From, Nick)} of
+		{true, _} ->
+		    ErrText = <<"That nickname is already in use by another occupant">>,
+		    {error, xmpp:err_conflict(ErrText, Lang)};
+		{_, false} ->
+		    ErrText = <<"That nickname is registered by another person">>,
+		    {error, xmpp:err_conflict(ErrText, Lang)};
+		_ ->
+		    NewStateData = set_subscriber(From, Nick, Nodes, StateData),
+		    {result, subscribe_result(Packet), NewStateData}
+	    end;
+	{ok, #subscriber{}} ->
+	    Nodes = get_subscription_nodes(Packet),
+	    NewStateData = set_subscriber(From, Nick, Nodes, StateData),
+	    {result, subscribe_result(Packet), NewStateData};
+	error ->
+	    SD2 = StateData#state{config = (StateData#state.config)#config{allow_subscription = true}},
+	    add_new_user(From, Nick, Packet, SD2)
+    end;
+process_iq_mucsub(From, #iq{type = set, lang = Lang,
+			    sub_els = [#muc_unsubscribe{jid = #jid{} = UnsubJid}]},
+		  StateData) ->
+    FAffiliation = get_affiliation(From, StateData),
+    FRole = get_role(From, StateData),
+    if FRole == moderator; FAffiliation == owner; FAffiliation == admin ->
+	    process_iq_mucsub(UnsubJid,
+			      #iq{type = set, lang = Lang,
+				  sub_els = [#muc_unsubscribe{jid = undefined}]},
+			      StateData);
+       true ->
+	    Txt = <<"Moderator privileges required">>,
+	    {error, xmpp:err_forbidden(Txt, Lang)}
+    end;
+process_iq_mucsub(From, #iq{type = set, sub_els = [#muc_unsubscribe{}]},
+		  StateData) ->
+    LBareJID = jid:tolower(jid:remove_resource(From)),
+    case ?DICT:find(LBareJID, StateData#state.subscribers) of
+	{ok, #subscriber{nick = Nick}} ->
+	    Nicks = ?DICT:erase(Nick, StateData#state.subscriber_nicks),
+	    Subscribers = ?DICT:erase(LBareJID, StateData#state.subscribers),
+	    NewStateData = StateData#state{subscribers = Subscribers,
+					   subscriber_nicks = Nicks},
+	    store_room(NewStateData, [{del_subscription, LBareJID}]),
+	    send_subscriptions_change_notifications(LBareJID, Nick, unsubscribe, StateData),
+	    NewStateData2 = case close_room_if_temporary_and_empty(NewStateData) of
+		{stop, normal, _} -> stop;
+		{next_state, normal_state, SD} -> SD
+	    end,
+	    {result, undefined, NewStateData2};
+	_ ->
+	    {result, undefined, StateData}
+    end;
+process_iq_mucsub(From, #iq{type = get, lang = Lang,
+			    sub_els = [#muc_subscriptions{}]},
+		  StateData) ->
+    FAffiliation = get_affiliation(From, StateData),
+    FRole = get_role(From, StateData),
+    if FRole == moderator; FAffiliation == owner; FAffiliation == admin ->
+	    JIDs = dict:fold(
+		     fun(_, #subscriber{jid = J}, Acc) ->
+			     [J|Acc]
+		     end, [], StateData#state.subscribers),
+	    {result, #muc_subscriptions{list = JIDs}, StateData};
+       true ->
+	    Txt = <<"Moderator privileges required">>,
+	    {error, xmpp:err_forbidden(Txt, Lang)}
+    end;
+process_iq_mucsub(_From, #iq{type = get, lang = Lang}, _StateData) ->
+    Txt = <<"Value 'get' of 'type' attribute is not allowed">>,
+    {error, xmpp:err_bad_request(Txt, Lang)}.
+
+remove_subscriptions(StateData) ->
+    if not (StateData#state.config)#config.allow_subscription ->
+	    StateData#state{subscribers = ?DICT:new(),
+			    subscriber_nicks = ?DICT:new()};
+       true ->
+	    StateData
+    end.
+
+-spec get_subscription_nodes(stanza()) -> [binary()].
+get_subscription_nodes(#iq{sub_els = [#muc_subscribe{events = Nodes}]}) ->
+    lists:filter(
+      fun(Node) ->
+	      lists:member(Node, [?NS_MUCSUB_NODES_PRESENCE,
+				  ?NS_MUCSUB_NODES_MESSAGES,
+				  ?NS_MUCSUB_NODES_AFFILIATIONS,
+				  ?NS_MUCSUB_NODES_SUBJECT,
+				  ?NS_MUCSUB_NODES_CONFIG,
+				  ?NS_MUCSUB_NODES_PARTICIPANTS,
+				  ?NS_MUCSUB_NODES_SUBSCRIBERS])
+      end, Nodes);
+get_subscription_nodes(_) ->
+    [].
+
+-spec subscribe_result(iq()) -> muc_subscribe().
+subscribe_result(#iq{sub_els = [#muc_subscribe{nick = Nick}]} = Packet) ->
+    #muc_subscribe{nick = Nick, events = get_subscription_nodes(Packet)}.
+
+-spec get_title(state()) -> binary().
+get_title(StateData) ->
+    case (StateData#state.config)#config.title of
+      <<"">> -> StateData#state.room;
+      Name -> Name
+    end.
+
+-spec get_roomdesc_reply(jid(), state(), binary()) -> {item, binary()} | false.
+get_roomdesc_reply(JID, StateData, Tail) ->
+    IsOccupantOrAdmin = is_occupant_or_admin(JID,
+					     StateData),
+    if (StateData#state.config)#config.public or
+	 IsOccupantOrAdmin ->
+	   if (StateData#state.config)#config.public_list or
+		IsOccupantOrAdmin ->
+		  {item, <<(get_title(StateData))/binary,Tail/binary>>};
+	      true -> {item, get_title(StateData)}
+	   end;
+       true -> false
+    end.
+
+-spec get_roomdesc_tail(state(), binary()) -> binary().
+get_roomdesc_tail(StateData, Lang) ->
+    Desc = case (StateData#state.config)#config.public of
+	     true -> <<"">>;
+	     _ -> translate:translate(Lang, <<"private, ">>)
+	   end,
+    Len = (?DICT):size(StateData#state.nicks),
+    <<" (", Desc/binary, (integer_to_binary(Len))/binary, ")">>.
+
+-spec get_mucroom_disco_items(state()) -> disco_items().
+get_mucroom_disco_items(StateData) ->
+    Items = ?DICT:fold(
+	       fun(Nick, _, Acc) ->
+		       [#disco_item{jid = jid:make(StateData#state.room,
+						   StateData#state.host,
+						   Nick),
+				    name = Nick}|Acc]
+	       end, [], StateData#state.nicks),
+    #disco_items{items = Items}.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% Voice request support
+
+-spec prepare_request_form(jid(), binary(), binary()) -> message().
+prepare_request_form(Requester, Nick, Lang) ->
+    Title = translate:translate(Lang, <<"Voice request">>),
+    Instruction = translate:translate(
+		    Lang, <<"Either approve or decline the voice request.">>),
+    Fs = muc_request:encode([{role, participant},
+			     {jid, Requester},
+			     {roomnick, Nick},
+			     {request_allow, false}],
+			    Lang),
+    #message{type = normal,
+	     sub_els = [#xdata{type = form,
+			       title = Title,
+			       instructions = [Instruction],
+			       fields = Fs}]}.
+
+-spec send_voice_request(jid(), binary(), state()) -> ok.
+send_voice_request(From, Lang, StateData) ->
+    Moderators = search_role(moderator, StateData),
+    FromNick = find_nick_by_jid(From, StateData),
+    lists:foreach(
+      fun({_, User}) ->
+	      ejabberd_router:route(
+		xmpp:set_from_to(
+		  prepare_request_form(From, FromNick, Lang),
+		  StateData#state.jid, User#user.jid))
+      end, Moderators).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% Invitation support
+-spec check_invitation(jid(), [muc_invite()], binary(), state()) ->
+			      ok | {error, stanza_error()}.
+check_invitation(From, Invitations, Lang, StateData) ->
+    FAffiliation = get_affiliation(From, StateData),
+    CanInvite = (StateData#state.config)#config.allow_user_invites orelse
+	        FAffiliation == admin orelse FAffiliation == owner,
+    case CanInvite of
+	true ->
+	    case lists:all(
+		   fun(#muc_invite{to = #jid{}}) -> true;
+		      (_) -> false
+		   end, Invitations) of
+		true ->
+		    ok;
+		false ->
+		    Txt = <<"No 'to' attribute found in the invitation">>,
+		    {error, xmpp:err_bad_request(Txt, Lang)}
+	    end;
+	false ->
+	    Txt = <<"Invitations are not allowed in this conference">>,
+	    {error, xmpp:err_not_allowed(Txt, Lang)}
+    end.
+
+-spec route_invitation(jid(), muc_invite(), binary(), state()) -> jid().
+route_invitation(From, Invitation, Lang, StateData) ->
+    #muc_invite{to = JID, reason = Reason} = Invitation,
+    Invite = Invitation#muc_invite{to = undefined, from = From},
+    Password = case (StateData#state.config)#config.password_protected of
+		   true ->
+		       (StateData#state.config)#config.password;
+		   false ->
+		       undefined
+	       end,
+    XUser = #muc_user{password = Password, invites = [Invite]},
+    XConference = #x_conference{jid = jid:make(StateData#state.room,
+					       StateData#state.host),
+				reason = Reason},
+    Body = iolist_to_binary(
+	     [io_lib:format(
+		translate:translate(
+		  Lang,
+		  <<"~s invites you to the room ~s">>),
+		[jid:encode(From),
+		 jid:encode({StateData#state.room, StateData#state.host, <<"">>})]),
+	      case (StateData#state.config)#config.password_protected of
+		  true ->
+		      <<", ",
+			(translate:translate(
+			   Lang, <<"the password is">>))/binary,
+			" '",
+			((StateData#state.config)#config.password)/binary,
+			"'">>;
+		  _ -> <<"">>
+	      end,
+	      case Reason of
+		  <<"">> -> <<"">>;
+		  _ -> <<" (", Reason/binary, ") ">>
+	      end]),
+    Msg = #message{from = StateData#state.jid,
+		   to = JID,
+		   type = normal,
+		   body = xmpp:mk_text(Body),
+		   sub_els = [XUser, XConference]},
+    ejabberd_hooks:run(muc_invite, StateData#state.server_host,
+		       [StateData#state.jid, StateData#state.config,
+			From, JID, Reason]),
+    ejabberd_router:route(Msg),
+    JID.
+
+%% Handle a message sent to the room by a non-participant.
+%% If it is a decline, send to the inviter.
+%% Otherwise, an error message is sent to the sender.
+-spec handle_roommessage_from_nonparticipant(message(), state(), jid()) -> ok.
+handle_roommessage_from_nonparticipant(Packet, StateData, From) ->
+    try xmpp:try_subtag(Packet, #muc_user{}) of
+	#muc_user{decline = #muc_decline{to = #jid{} = To} = Decline} = XUser ->
+	    NewDecline = Decline#muc_decline{to = undefined, from = From},
+	    NewXUser = XUser#muc_user{decline = NewDecline},
+	    NewPacket = xmpp:set_subtag(Packet, NewXUser),
+	    ejabberd_router:route(
+	      xmpp:set_from_to(NewPacket, StateData#state.jid, To));
+	_ ->
+	    ErrText = <<"Only occupants are allowed to send messages "
+			"to the conference">>,
+	    Err = xmpp:err_not_acceptable(ErrText, xmpp:get_lang(Packet)),
+	    ejabberd_router:route_error(Packet, Err)
+    catch _:{xmpp_codec, Why} ->
+	    Txt = xmpp:io_format_error(Why),
+	    Err = xmpp:err_bad_request(Txt, xmpp:get_lang(Packet)),
+	    ejabberd_router:route_error(Packet, Err)
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% Logging
+
+add_to_log(Type, Data, StateData)
+    when Type == roomconfig_change_disabledlogging ->
+    mod_muc_log:add_to_log(StateData#state.server_host,
+			   roomconfig_change, Data, StateData#state.jid,
+			   make_opts(StateData));
+add_to_log(Type, Data, StateData) ->
+    case (StateData#state.config)#config.logging of
+      true ->
+	  mod_muc_log:add_to_log(StateData#state.server_host,
+				 Type, Data, StateData#state.jid,
+				 make_opts(StateData));
+      false -> ok
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%% Users number checking
+
+-spec tab_add_online_user(jid(), state()) -> any().
+tab_add_online_user(JID, StateData) ->
+    Room = StateData#state.room,
+    Host = StateData#state.host,
+    ServerHost = StateData#state.server_host,
+    ejabberd_hooks:run(join_room, ServerHost, [ServerHost, Room, Host, JID]),
+    mod_muc:register_online_user(ServerHost, jid:tolower(JID), Room, Host).
+
+-spec tab_remove_online_user(jid(), state()) -> any().
+tab_remove_online_user(JID, StateData) ->
+    Room = StateData#state.room,
+    Host = StateData#state.host,
+    ServerHost = StateData#state.server_host,
+    ejabberd_hooks:run(leave_room, ServerHost, [ServerHost, Room, Host, JID]),
+    mod_muc:unregister_online_user(ServerHost, jid:tolower(JID), Room, Host).
+
+-spec tab_count_user(jid(), state()) -> non_neg_integer().
+tab_count_user(JID, StateData) ->
+    ServerHost = StateData#state.server_host,
+    {LUser, LServer, _} = jid:tolower(JID),
+    mod_muc:count_online_rooms_by_user(ServerHost, LUser, LServer).
+
+-spec element_size(stanza()) -> non_neg_integer().
+element_size(El) ->
+    byte_size(fxml:element_to_binary(xmpp:encode(El, ?NS_CLIENT))).
+
+-spec store_room(state()) -> ok.
+store_room(StateData) ->
+    store_room(StateData, []).
+store_room(StateData, ChangesHints) ->
+    if (StateData#state.config)#config.persistent ->
+	    mod_muc:store_room(StateData#state.server_host,
+			       StateData#state.host, StateData#state.room,
+			       make_opts(StateData),
+			       ChangesHints);
+       true ->
+	    ok
+    end.
+
+-spec send_subscriptions_change_notifications(jid(), binary(), subscribe|unsubscribe, state()) -> ok.
+send_subscriptions_change_notifications(From, Nick, Type, State) ->
+    ?DICT:fold(fun(_, #subscriber{nodes = Nodes, jid = JID}, _) ->
+		    case lists:member(?NS_MUCSUB_NODES_SUBSCRIBERS, Nodes) of
+			true ->
+			    ShowJid = case (State#state.config)#config.anonymous == false orelse
+					   get_role(JID, State) == moderator orelse
+					   get_default_role(get_affiliation(JID, State), State) == moderator of
+					  true -> true;
+					  _ -> false
+				      end,
+			    Payload = case {Type, ShowJid} of
+					 {subscribe, true} ->
+					     #muc_subscribe{jid = From, nick = Nick};
+					 {subscribe, _} ->
+					     #muc_subscribe{nick = Nick};
+					 {unsubscribe, true} ->
+					     #muc_unsubscribe{jid = From, nick = Nick};
+					 {unsubscribe, _} ->
+					     #muc_unsubscribe{nick = Nick}
+				     end,
+			    Packet = #message{
+				sub_els = [#ps_event{
+				    items = #ps_items{
+					node = ?NS_MUCSUB_NODES_SUBSCRIBERS,
+					items = [#ps_item{
+					    id = randoms:get_string(),
+					    sub_els = [Payload]}]}}]},
+			    ejabberd_router:route(xmpp:set_from_to(Packet, From, JID));
+			false ->
+			    ok
+		    end
+	       end, ok, State#state.subscribers).
+
+-spec send_wrapped(jid(), jid(), stanza(), binary(), state()) -> ok.
+send_wrapped(From, To, Packet, Node, State) ->
+    LTo = jid:tolower(To),
+    LBareTo = jid:tolower(jid:remove_resource(To)),
+    IsOffline = case ?DICT:find(LTo, State#state.users) of
+		    {ok, #user{last_presence = undefined}} -> true;
+		    error -> true;
+		    _ -> false
+		end,
+    if IsOffline ->
+	    case ?DICT:find(LBareTo, State#state.subscribers) of
+		{ok, #subscriber{nodes = Nodes, jid = JID}} ->
+	    case lists:member(Node, Nodes) of
+		true ->
+			    NewPacket = wrap(From, JID, Packet, Node),
+			    ejabberd_router:route(
+			      xmpp:set_from_to(NewPacket, State#state.jid, JID));
+		false ->
+		    ok
+	    end;
+	_ ->
+		    ok
+	    end;
+       true ->
+	    case Packet of
+		#presence{type = unavailable} ->
+		    case xmpp:get_subtag(Packet, #muc_user{}) of
+			#muc_user{destroy = Destroy,
+				  status_codes = Codes} ->
+			    case Destroy /= undefined orelse
+				 (lists:member(110,Codes) andalso
+				  not lists:member(303, Codes)) of
+				true ->
+				    ejabberd_router:route(
+				      #presence{from = State#state.jid, to = To,
+						id = randoms:get_string(),
+						type = unavailable});
+				false ->
+				    ok
+			    end;
+			_ ->
+			    false
+		    end;
+		_ ->
+		    ok
+	    end,
+	    ejabberd_router:route(xmpp:set_from_to(Packet, From, To))
+    end.
+
+-spec wrap(jid(), jid(), stanza(), binary()) -> message().
+wrap(From, To, Packet, Node) ->
+    El = xmpp:set_from_to(Packet, From, To),
+    #message{
+       sub_els = [#ps_event{
+		     items = #ps_items{
+				node = Node,
+				items = [#ps_item{
+					    id = randoms:get_string(),
+					    sub_els = [El]}]}}]}.
+
+%% -spec send_multiple(jid(), binary(), [#user{}], stanza()) -> ok.
+%% send_multiple(From, Server, Users, Packet) ->
+%%     JIDs = [ User#user.jid || {_, User} <- ?DICT:to_list(Users)],
+%%     ejabberd_router_multicast:route_multicast(From, Server, JIDs, Packet).
+
+-spec send_wrapped_multiple(jid(), dict:dict(), stanza(), binary(), state()) -> ok.
+send_wrapped_multiple(From, Users, Packet, Node, State) ->
+    lists:foreach(
+      fun({_, #user{jid = To}}) ->
+	      send_wrapped(From, To, Packet, Node, State)
+      end, ?DICT:to_list(Users)).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+%% Detect messange stanzas that don't have meaninful content
+-spec has_body_or_subject(message()) -> boolean().
+has_body_or_subject(#message{body = Body, subject = Subj}) ->
+    Body /= [] orelse Subj /= [].
diff --git a/src/mod_roster.erl b/src/mod_roster.erl
index 38c3a78b04..f02f2cd365 100644
--- a/src/mod_roster.erl
+++ b/src/mod_roster.erl
@@ -66,6 +66,8 @@
 -define(ROSTER_ITEM_CACHE, roster_item_cache).
 -define(ROSTER_VERSION_CACHE, roster_version_cache).
 
+-include("mod_logdb.hrl").
+
 -export_type([subscription/0]).
 
 -callback init(binary(), gen_mod:opts()) -> any().
@@ -911,6 +913,14 @@ user_roster(User, Server, Query, Lang) ->
 				  Query),
     Items = get_roster(LUser, LServer),
     SItems = lists:sort(Items),
+
+    Settings = case gen_mod:is_loaded(Server, mod_logdb) of
+         true ->
+             mod_logdb:get_user_settings(User, Server);
+         false ->
+             []
+    end,
+
     FItems = case SItems of
 	       [] -> [?CT(<<"None">>)];
 	       _ ->
@@ -968,7 +978,33 @@ user_roster(User, Server, Query, Lang) ->
 							  [?INPUTT(<<"submit">>,
 								   <<"remove",
 								     (ejabberd_web_admin:term_to_id(R#roster.jid))/binary>>,
-								   <<"Remove">>)])])
+								     <<"Remove">>)]),
+                             case gen_mod:is_loaded(Server, mod_logdb) of
+                                  true ->
+                                     Peer = jid:encode(R#roster.jid),
+                                     A = lists:member(Peer, Settings#user_settings.dolog_list),
+                                     B = lists:member(Peer, Settings#user_settings.donotlog_list),
+                                     {Name, Value} =
+                                       if
+                                         A ->
+                                           {<<"donotlog">>, <<"Do Not Log Messages">>};
+                                         B ->
+                                           {<<"dolog">>, <<"Log Messages">>};
+                                         Settings#user_settings.dolog_default == true ->
+                                           {<<"donotlog">>, <<"Do Not Log Messages">>};
+                                         Settings#user_settings.dolog_default == false ->
+                                           {<<"dolog">>, <<"Log Messages">>}
+                                       end,
+
+                                     ?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
+                                          [?INPUTT(<<"submit">>,
+                                                   <<Name/binary,
+                                                   (ejabberd_web_admin:term_to_id(R#roster.jid))/binary>>,
+                                                   Value)]);
+                                  false ->
+                                     ?X([])
+                             end
+                           ])
 					end,
 					SItems)))])]
 	     end,
@@ -1075,9 +1111,42 @@ user_roster_item_parse_query(User, Server, Items,
 					    sub_els = [#roster_query{
 							  items = [RosterItem]}]}),
 				      throw(submitted);
-				  false -> ok
-				end
-			  end
+                  false ->
+                    case lists:keysearch(
+                           <<"donotlog", (ejabberd_web_admin:term_to_id(JID))/binary>>, 1, Query) of
+                        {value, _} ->
+                             Peer = jid:encode(JID),
+                             Settings = mod_logdb:get_user_settings(User, Server),
+                             DNLL = case lists:member(Peer, Settings#user_settings.donotlog_list) of
+                                         false -> lists:append(Settings#user_settings.donotlog_list, [Peer]);
+                                         true -> Settings#user_settings.donotlog_list
+                                    end,
+                             DLL = lists:delete(jid:encode(JID), Settings#user_settings.dolog_list),
+                             Sett = Settings#user_settings{donotlog_list=DNLL, dolog_list=DLL},
+                             % TODO: check returned value
+                             ok = mod_logdb:set_user_settings(User, Server, Sett),
+                             throw(nothing);
+                        false ->
+                           case lists:keysearch(
+                                  <<"dolog", (ejabberd_web_admin:term_to_id(JID))/binary>>, 1, Query) of
+                               {value, _} ->
+                                  Peer = jid:encode(JID),
+                                  Settings = mod_logdb:get_user_settings(User, Server),
+                                  DLL = case lists:member(Peer, Settings#user_settings.dolog_list) of
+                                             false -> lists:append(Settings#user_settings.dolog_list, [Peer]);
+                                             true -> Settings#user_settings.dolog_list
+                                        end,
+                                  DNLL = lists:delete(jid:encode(JID), Settings#user_settings.donotlog_list),
+                                  Sett = Settings#user_settings{donotlog_list=DNLL, dolog_list=DLL},
+                                  % TODO: check returned value
+                                  ok = mod_logdb:set_user_settings(User, Server, Sett),
+                                  throw(nothing);
+                               false ->
+                                   ok
+                           end % dolog
+                    end % donotlog
+                end % remove
+              end % validate
 		  end,
 		  Items),
     nothing.
diff --git a/src/mod_roster.erl.orig b/src/mod_roster.erl.orig
new file mode 100644
index 0000000000..38c3a78b04
--- /dev/null
+++ b/src/mod_roster.erl.orig
@@ -0,0 +1,1224 @@
+%%%----------------------------------------------------------------------
+%%% File    : mod_roster.erl
+%%% Author  : Alexey Shchepin <alexey@process-one.net>
+%%% Purpose : Roster management
+%%% Created : 11 Dec 2002 by Alexey Shchepin <alexey@process-one.net>
+%%%
+%%%
+%%% ejabberd, Copyright (C) 2002-2018   ProcessOne
+%%%
+%%% This program is free software; you can redistribute it and/or
+%%% modify it under the terms of the GNU General Public License as
+%%% published by the Free Software Foundation; either version 2 of the
+%%% License, or (at your option) any later version.
+%%%
+%%% This program is distributed in the hope that it will be useful,
+%%% but WITHOUT ANY WARRANTY; without even the implied warranty of
+%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+%%% General Public License for more details.
+%%%
+%%% You should have received a copy of the GNU General Public License along
+%%% with this program; if not, write to the Free Software Foundation, Inc.,
+%%% 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+%%%
+%%%----------------------------------------------------------------------
+
+%%% @doc Roster management (Mnesia storage).
+%%%
+%%% Includes support for XEP-0237: Roster Versioning.
+%%% The roster versioning follows an all-or-nothing strategy:
+%%%  - If the version supplied by the client is the latest, return an empty response.
+%%%  - If not, return the entire new roster (with updated version string).
+%%% Roster version is a hash digest of the entire roster.
+%%% No additional data is stored in DB.
+
+-module(mod_roster).
+
+-protocol({xep, 237, '1.3'}).
+
+-author('alexey@process-one.net').
+
+-behaviour(gen_mod).
+
+-export([start/2, stop/1, reload/3, process_iq/1, export/1,
+	 import_info/0, process_local_iq/1, get_user_roster/2,
+	 import/5, get_roster/2, push_item/3,
+	 import_start/2, import_stop/2, is_subscribed/2,
+	 c2s_self_presence/1, in_subscription/2,
+	 out_subscription/1, set_items/3, remove_user/2,
+	 get_jid_info/4, encode_item/1, webadmin_page/3,
+	 webadmin_user/4, get_versioning_feature/2,
+	 roster_versioning_enabled/1, roster_version/2,
+	 mod_opt_type/1, mod_options/1, set_roster/1, del_roster/3,
+	 depends/2]).
+
+-include("logger.hrl").
+
+-include("xmpp.hrl").
+
+-include("mod_roster.hrl").
+
+-include("ejabberd_http.hrl").
+
+-include("ejabberd_web_admin.hrl").
+
+-define(ROSTER_CACHE, roster_cache).
+-define(ROSTER_ITEM_CACHE, roster_item_cache).
+-define(ROSTER_VERSION_CACHE, roster_version_cache).
+
+-export_type([subscription/0]).
+
+-callback init(binary(), gen_mod:opts()) -> any().
+-callback import(binary(), binary(), #roster{} | [binary()]) -> ok.
+-callback read_roster_version(binary(), binary()) -> {ok, binary()} | error.
+-callback write_roster_version(binary(), binary(), boolean(), binary()) -> any().
+-callback get_roster(binary(), binary()) -> {ok, [#roster{}]} | error.
+-callback get_roster_item(binary(), binary(), ljid()) -> {ok, #roster{}} | error.
+-callback read_subscription_and_groups(binary(), binary(), ljid())
+          -> {ok, {subscription(), ask(), [binary()]}} | error.
+-callback roster_subscribe(binary(), binary(), ljid(), #roster{}) -> any().
+-callback transaction(binary(), function()) -> {atomic, any()} | {aborted, any()}.
+-callback remove_user(binary(), binary()) -> any().
+-callback update_roster(binary(), binary(), ljid(), #roster{}) -> any().
+-callback del_roster(binary(), binary(), ljid()) -> any().
+-callback use_cache(binary(), roster | roster_version) -> boolean().
+-callback cache_nodes(binary()) -> [node()].
+
+-optional_callbacks([use_cache/2, cache_nodes/1]).
+
+start(Host, Opts) ->
+    Mod = gen_mod:db_mod(Host, Opts, ?MODULE),
+    Mod:init(Host, Opts),
+    init_cache(Mod, Host, Opts),
+    ejabberd_hooks:add(roster_get, Host, ?MODULE,
+		       get_user_roster, 50),
+    ejabberd_hooks:add(roster_in_subscription, Host,
+		       ?MODULE, in_subscription, 50),
+    ejabberd_hooks:add(roster_out_subscription, Host,
+		       ?MODULE, out_subscription, 50),
+    ejabberd_hooks:add(roster_get_jid_info, Host, ?MODULE,
+		       get_jid_info, 50),
+    ejabberd_hooks:add(remove_user, Host, ?MODULE,
+		       remove_user, 50),
+    ejabberd_hooks:add(c2s_self_presence, Host, ?MODULE,
+		       c2s_self_presence, 50),
+    ejabberd_hooks:add(c2s_post_auth_features, Host,
+		       ?MODULE, get_versioning_feature, 50),
+    ejabberd_hooks:add(webadmin_page_host, Host, ?MODULE,
+		       webadmin_page, 50),
+    ejabberd_hooks:add(webadmin_user, Host, ?MODULE,
+		       webadmin_user, 50),
+    gen_iq_handler:add_iq_handler(ejabberd_sm, Host,
+				  ?NS_ROSTER, ?MODULE, process_iq).
+
+stop(Host) ->
+    ejabberd_hooks:delete(roster_get, Host, ?MODULE,
+			  get_user_roster, 50),
+    ejabberd_hooks:delete(roster_in_subscription, Host,
+			  ?MODULE, in_subscription, 50),
+    ejabberd_hooks:delete(roster_out_subscription, Host,
+			  ?MODULE, out_subscription, 50),
+    ejabberd_hooks:delete(roster_get_jid_info, Host,
+			  ?MODULE, get_jid_info, 50),
+    ejabberd_hooks:delete(remove_user, Host, ?MODULE,
+			  remove_user, 50),
+    ejabberd_hooks:delete(c2s_self_presence, Host, ?MODULE,
+			  c2s_self_presence, 50),
+    ejabberd_hooks:delete(c2s_post_auth_features,
+			  Host, ?MODULE, get_versioning_feature, 50),
+    ejabberd_hooks:delete(webadmin_page_host, Host, ?MODULE,
+			  webadmin_page, 50),
+    ejabberd_hooks:delete(webadmin_user, Host, ?MODULE,
+			  webadmin_user, 50),
+    gen_iq_handler:remove_iq_handler(ejabberd_sm, Host,
+				     ?NS_ROSTER).
+
+reload(Host, NewOpts, OldOpts) ->
+    NewMod = gen_mod:db_mod(Host, NewOpts, ?MODULE),
+    OldMod = gen_mod:db_mod(Host, OldOpts, ?MODULE),
+    if NewMod /= OldMod ->
+	    NewMod:init(Host, NewOpts);
+       true ->
+	    ok
+    end.
+
+depends(_Host, _Opts) ->
+    [].
+
+process_iq(#iq{from = #jid{luser = U, lserver = S},
+	       to =   #jid{luser = U, lserver = S}} = IQ) ->
+    process_local_iq(IQ);
+process_iq(#iq{lang = Lang, to = To} = IQ) ->
+    case ejabberd_hooks:run_fold(roster_remote_access,
+				 To#jid.lserver, false, [IQ]) of
+	false ->
+	    Txt = <<"Query to another users is forbidden">>,
+	    xmpp:make_error(IQ, xmpp:err_forbidden(Txt, Lang));
+	true ->
+	    process_local_iq(IQ)
+    end.
+
+process_local_iq(#iq{type = set,lang = Lang,
+		     sub_els = [#roster_query{
+				   items = [#roster_item{ask = Ask}]}]} = IQ)
+  when Ask /= undefined ->
+    Txt = <<"Possessing 'ask' attribute is not allowed by RFC6121">>,
+    xmpp:make_error(IQ, xmpp:err_bad_request(Txt, Lang));
+process_local_iq(#iq{type = set, from = From, lang = Lang,
+		     sub_els = [#roster_query{
+				   items = [#roster_item{} = Item]}]} = IQ) ->
+    case has_duplicated_groups(Item#roster_item.groups) of
+	true ->
+	    Txt = <<"Duplicated groups are not allowed by RFC6121">>,
+	    xmpp:make_error(IQ, xmpp:err_bad_request(Txt, Lang));
+	false ->
+	    #jid{lserver = LServer} = From,
+	    Access = gen_mod:get_module_opt(LServer, ?MODULE, access),
+	    case acl:match_rule(LServer, Access, From) of
+		deny ->
+		    Txt = <<"Access denied by service policy">>,
+		    xmpp:make_error(IQ, xmpp:err_not_allowed(Txt, Lang));
+		allow ->
+		    process_iq_set(IQ)
+	    end
+    end;
+process_local_iq(#iq{type = set, lang = Lang,
+		     sub_els = [#roster_query{items = [_|_]}]} = IQ) ->
+    Txt = <<"Multiple <item/> elements are not allowed by RFC6121">>,
+    xmpp:make_error(IQ, xmpp:err_bad_request(Txt, Lang));
+process_local_iq(#iq{type = get, lang = Lang,
+		     sub_els = [#roster_query{items = Items}]} = IQ) ->
+    case Items of
+	[] ->
+	    process_iq_get(IQ);
+	[_|_] ->
+	    Txt = <<"The query must not contain <item/> elements">>,
+	    xmpp:make_error(IQ, xmpp:err_bad_request(Txt, Lang))
+    end;
+process_local_iq(#iq{lang = Lang} = IQ) ->
+    Txt = <<"No module is handling this query">>,
+    xmpp:make_error(IQ, xmpp:err_service_unavailable(Txt, Lang)).
+
+roster_hash(Items) ->
+    str:sha(term_to_binary(lists:sort([R#roster{groups =
+						    lists:sort(Grs)}
+				       || R = #roster{groups = Grs}
+					      <- Items]))).
+
+roster_versioning_enabled(Host) ->
+    gen_mod:get_module_opt(Host, ?MODULE, versioning).
+
+roster_version_on_db(Host) ->
+    gen_mod:get_module_opt(Host, ?MODULE, store_current_id).
+
+%% Returns a list that may contain an xmlelement with the XEP-237 feature if it's enabled.
+-spec get_versioning_feature([xmpp_element()], binary()) -> [xmpp_element()].
+get_versioning_feature(Acc, Host) ->
+    case gen_mod:is_loaded(Host, ?MODULE) of
+	true ->
+    case roster_versioning_enabled(Host) of
+      true ->
+	  [#rosterver_feature{}|Acc];
+		false ->
+		    Acc
+	    end;
+	false ->
+	    Acc
+    end.
+
+roster_version(LServer, LUser) ->
+    US = {LUser, LServer},
+    case roster_version_on_db(LServer) of
+      true ->
+	  case read_roster_version(LUser, LServer) of
+	    error -> not_found;
+	    {ok, V} -> V
+	  end;
+      false ->
+	  roster_hash(ejabberd_hooks:run_fold(roster_get, LServer,
+					      [], [US]))
+    end.
+
+read_roster_version(LUser, LServer) ->
+    ets_cache:lookup(
+      ?ROSTER_VERSION_CACHE, {LUser, LServer},
+      fun() ->
+	      Mod = gen_mod:db_mod(LServer, ?MODULE),
+	      Mod:read_roster_version(LUser, LServer)
+      end).
+
+write_roster_version(LUser, LServer) ->
+    write_roster_version(LUser, LServer, false).
+
+write_roster_version_t(LUser, LServer) ->
+    write_roster_version(LUser, LServer, true).
+
+write_roster_version(LUser, LServer, InTransaction) ->
+    Ver = str:sha(term_to_binary(p1_time_compat:unique_integer())),
+    Mod = gen_mod:db_mod(LServer, ?MODULE),
+    Mod:write_roster_version(LUser, LServer, InTransaction, Ver),
+    if InTransaction -> ok;
+       true ->
+	    ets_cache:delete(?ROSTER_VERSION_CACHE, {LUser, LServer},
+			     cache_nodes(Mod, LServer))
+    end,
+    Ver.
+
+%% Load roster from DB only if necessary.
+%% It is necessary if
+%%     - roster versioning is disabled in server OR
+%%     - roster versioning is not used by the client OR
+%%     - roster versioning is used by server and client, BUT the server isn't storing versions on db OR
+%%     - the roster version from client don't match current version.
+process_iq_get(#iq{to = To, lang = Lang,
+		   sub_els = [#roster_query{ver = RequestedVersion}]} = IQ) ->
+    LUser = To#jid.luser,
+    LServer = To#jid.lserver,
+    US = {LUser, LServer},
+    try {ItemsToSend, VersionToSend} =
+	     case {roster_versioning_enabled(LServer),
+		   roster_version_on_db(LServer)} of
+		 {true, true} when RequestedVersion /= undefined ->
+		     case read_roster_version(LUser, LServer) of
+			 error ->
+			     RosterVersion = write_roster_version(LUser, LServer),
+			     {lists:map(fun encode_item/1,
+					ejabberd_hooks:run_fold(
+					  roster_get, To#jid.lserver, [], [US])),
+			      RosterVersion};
+			 {ok, RequestedVersion} ->
+			     {false, false};
+			 {ok, NewVersion} ->
+			     {lists:map(fun encode_item/1,
+					ejabberd_hooks:run_fold(
+					  roster_get, To#jid.lserver, [], [US])),
+			      NewVersion}
+		     end;
+		 {true, false} when RequestedVersion /= undefined ->
+		     RosterItems = ejabberd_hooks:run_fold(
+				     roster_get, To#jid.lserver, [], [US]),
+		     case roster_hash(RosterItems) of
+			 RequestedVersion ->
+			     {false, false};
+			 New ->
+			     {lists:map(fun encode_item/1, RosterItems), New}
+		     end;
+		 _ ->
+		     {lists:map(fun encode_item/1,
+				ejabberd_hooks:run_fold(
+				  roster_get, To#jid.lserver, [], [US])),
+		      false}
+	     end,
+	 xmpp:make_iq_result(
+	   IQ,
+	   case {ItemsToSend, VersionToSend} of
+	       {false, false} ->
+		   undefined;
+	       {Items, false} ->
+		   #roster_query{items = Items};
+	       {Items, Version} ->
+		   #roster_query{items = Items,
+				 ver = Version}
+	   end)
+    catch E:R ->
+	    ?ERROR_MSG("failed to process roster get for ~s: ~p",
+		       [jid:encode(To), {E, {R, erlang:get_stacktrace()}}]),
+	    Txt = <<"Roster module has failed">>,
+	    xmpp:make_error(IQ, xmpp:err_internal_server_error(Txt, Lang))
+    end.
+
+-spec get_user_roster([#roster{}], {binary(), binary()}) -> [#roster{}].
+get_user_roster(Acc, {LUser, LServer}) ->
+    Items = get_roster(LUser, LServer),
+    lists:filter(fun (#roster{subscription = none,
+			      ask = in}) ->
+			 false;
+		     (_) -> true
+		 end,
+		 Items)
+      ++ Acc.
+
+get_roster(LUser, LServer) ->
+    Mod = gen_mod:db_mod(LServer, ?MODULE),
+    R = case use_cache(Mod, LServer, roster) of
+	    true ->
+		ets_cache:lookup(
+		  ?ROSTER_CACHE, {LUser, LServer},
+		  fun() -> Mod:get_roster(LUser, LServer) end);
+	    false ->
+		Mod:get_roster(LUser, LServer)
+	end,
+    case R of
+	{ok, Items} -> Items;
+	error -> []
+    end.
+
+get_roster_item(LUser, LServer, LJID) ->
+    Mod = gen_mod:db_mod(LServer, ?MODULE),
+    case Mod:get_roster_item(LUser, LServer, LJID) of
+	{ok, Item} ->
+	    Item;
+	error ->
+	    LBJID = jid:remove_resource(LJID),
+	    #roster{usj = {LUser, LServer, LBJID},
+		    us = {LUser, LServer}, jid = LBJID}
+    end.
+
+get_subscription_and_groups(LUser, LServer, LJID) ->
+    LBJID = jid:remove_resource(LJID),
+    Mod = gen_mod:db_mod(LServer, ?MODULE),
+    Res = case use_cache(Mod, LServer, roster) of
+	      true ->
+		  ets_cache:lookup(
+		    ?ROSTER_ITEM_CACHE, {LUser, LServer, LBJID},
+		    fun() ->
+			    Items = get_roster(LUser, LServer),
+			    case lists:keyfind(LBJID, #roster.jid, Items) of
+				#roster{subscription = Sub,
+					ask = Ask,
+					groups = Groups} ->
+				    {ok, {Sub, Ask, Groups}};
+				false ->
+				    error
+			    end
+		    end);
+	      false ->
+		  case Mod:read_subscription_and_groups(LUser, LServer, LBJID) of
+		      {ok, {Sub, Groups}} ->
+			  %% Backward compatibility for third-party backends
+			  {ok, {Sub, none, Groups}};
+		      Other ->
+			  Other
+		  end
+	  end,
+    case Res of
+	{ok, SubAndGroups} ->
+	    SubAndGroups;
+	error ->
+	    {none, none, []}
+    end.
+
+set_roster(#roster{us = {LUser, LServer}, jid = LJID} = Item) ->
+    transaction(
+      LUser, LServer, [LJID],
+      fun() ->
+	      update_roster_t(LUser, LServer, LJID, Item)
+      end).
+
+del_roster(LUser, LServer, LJID) ->
+    transaction(
+      LUser, LServer, [LJID],
+      fun() ->
+	      del_roster_t(LUser, LServer, LJID)
+      end).
+
+encode_item(Item) ->
+    #roster_item{jid = jid:make(Item#roster.jid),
+		 name = Item#roster.name,
+		 subscription = Item#roster.subscription,
+		 ask = case ask_to_pending(Item#roster.ask) of
+			   out -> subscribe;
+			   both -> subscribe;
+			   _ -> undefined
+		       end,
+		 groups = Item#roster.groups}.
+
+decode_item(#roster_item{subscription = remove} = Item, R, _) ->
+    R#roster{jid = jid:tolower(Item#roster_item.jid),
+	     name = <<"">>,
+	     subscription = remove,
+	     ask = none,
+	     groups = [],
+	     askmessage = <<"">>,
+	     xs = []};
+decode_item(Item, R, Managed) ->
+    R#roster{jid = jid:tolower(Item#roster_item.jid),
+	     name = Item#roster_item.name,
+	     subscription = case Item#roster_item.subscription of
+				Sub when Managed -> Sub;
+				_ -> R#roster.subscription
+			    end,
+	     groups = Item#roster_item.groups}.
+
+process_iq_set(#iq{from = _From, to = To,
+		   sub_els = [#roster_query{items = [QueryItem]}]} = IQ) ->
+    #jid{luser = LUser, lserver = LServer} = To,
+    LJID = jid:tolower(QueryItem#roster_item.jid),
+    F = fun () ->
+		Item = get_roster_item(LUser, LServer, LJID),
+		Item2 = decode_item(QueryItem, Item, false),
+		Item3 = ejabberd_hooks:run_fold(roster_process_item,
+						LServer, Item2,
+						[LServer]),
+		case Item3#roster.subscription of
+		    remove -> del_roster_t(LUser, LServer, LJID);
+		    _ -> update_roster_t(LUser, LServer, LJID, Item3)
+		end,
+		case roster_version_on_db(LServer) of
+		    true -> write_roster_version_t(LUser, LServer);
+		    false -> ok
+		end,
+		{Item, Item3}
+	end,
+    case transaction(LUser, LServer, [LJID], F) of
+	{atomic, {OldItem, Item}} ->
+	    push_item(To, OldItem, Item),
+	    case Item#roster.subscription of
+		remove ->
+		    send_unsubscribing_presence(To, OldItem);
+		_ ->
+		    ok
+	    end,
+	    xmpp:make_iq_result(IQ);
+	E ->
+	    ?ERROR_MSG("roster set failed:~nIQ = ~s~nError = ~p",
+		       [xmpp:pp(IQ), E]),
+	    xmpp:make_error(IQ, xmpp:err_internal_server_error())
+    end.
+
+push_item(To, OldItem, NewItem) ->
+    #jid{luser = LUser, lserver = LServer} = To,
+    Ver = case roster_versioning_enabled(LServer) of
+	      true -> roster_version(LServer, LUser);
+	      false -> undefined
+	  end,
+    lists:foreach(
+      fun(Resource) ->
+	      To1 = jid:replace_resource(To, Resource),
+	      push_item(To1, OldItem, NewItem, Ver)
+      end, ejabberd_sm:get_user_resources(LUser, LServer)).
+
+push_item(To, OldItem, NewItem, Ver) ->
+    route_presence_change(To, OldItem, NewItem),
+    IQ = #iq{type = set, to = To,
+	     from = jid:remove_resource(To),
+	     id = <<"push", (randoms:get_string())/binary>>,
+	     sub_els = [#roster_query{ver = Ver,
+				      items = [encode_item(NewItem)]}]},
+    ejabberd_router:route(IQ).
+
+-spec route_presence_change(jid(), #roster{}, #roster{}) -> ok.
+route_presence_change(From, OldItem, NewItem) ->
+    OldSub = OldItem#roster.subscription,
+    NewSub = NewItem#roster.subscription,
+    To = jid:make(NewItem#roster.jid),
+    NewIsFrom = NewSub == both orelse NewSub == from,
+    OldIsFrom = OldSub == both orelse OldSub == from,
+    if NewIsFrom andalso not OldIsFrom ->
+	    case ejabberd_sm:get_session_pid(
+		   From#jid.luser, From#jid.lserver, From#jid.lresource) of
+		none ->
+		    ok;
+		Pid ->
+		    ejabberd_c2s:resend_presence(Pid, To)
+	    end;
+       OldIsFrom andalso not NewIsFrom ->
+	    PU = #presence{from = From, to = To, type = unavailable},
+	    case ejabberd_hooks:run_fold(
+		   privacy_check_packet, allow,
+		   [From, PU, out]) of
+		deny ->
+		    ok;
+		allow ->
+		    ejabberd_router:route(PU)
+	    end;
+       true ->
+	    ok
+    end.
+
+ask_to_pending(subscribe) -> out;
+ask_to_pending(unsubscribe) -> none;
+ask_to_pending(Ask) -> Ask.
+
+roster_subscribe_t(LUser, LServer, LJID, Item) ->
+    Mod = gen_mod:db_mod(LServer, ?MODULE),
+    Mod:roster_subscribe(LUser, LServer, LJID, Item).
+
+transaction(LUser, LServer, LJIDs, F) ->
+    Mod = gen_mod:db_mod(LServer, ?MODULE),
+    case Mod:transaction(LServer, F) of
+	{atomic, _} = Result ->
+	    delete_cache(Mod, LUser, LServer, LJIDs),
+	    Result;
+	Err ->
+	    Err
+    end.
+
+-spec in_subscription(boolean(), presence()) -> boolean().
+in_subscription(_, #presence{from = JID, to = To,
+			     type = Type, status = Status}) ->
+    #jid{user = User, server = Server} = To,
+    Reason = if Type == subscribe -> xmpp:get_text(Status);
+		true -> <<"">>
+	     end,
+    process_subscription(in, User, Server, JID, Type,
+			 Reason).
+
+-spec out_subscription(presence()) -> boolean().
+out_subscription(#presence{from = From, to = JID, type = Type}) ->
+    #jid{user = User, server = Server} = From,
+    process_subscription(out, User, Server, JID, Type, <<"">>).
+
+process_subscription(Direction, User, Server, JID1,
+		     Type, Reason) ->
+    LUser = jid:nodeprep(User),
+    LServer = jid:nameprep(Server),
+    LJID = jid:tolower(jid:remove_resource(JID1)),
+    F = fun () ->
+		Item = get_roster_item(LUser, LServer, LJID),
+		NewState = case Direction of
+			     out ->
+				 out_state_change(Item#roster.subscription,
+						  Item#roster.ask, Type);
+			     in ->
+				 in_state_change(Item#roster.subscription,
+						 Item#roster.ask, Type)
+			   end,
+		AutoReply = case Direction of
+			      out -> none;
+			      in ->
+				  in_auto_reply(Item#roster.subscription,
+						Item#roster.ask, Type)
+			    end,
+		AskMessage = case NewState of
+			       {_, both} -> Reason;
+			       {_, in} -> Reason;
+			       _ -> <<"">>
+			     end,
+		case NewState of
+		    none ->
+			{none, AutoReply};
+		    {none, none} when Item#roster.subscription == none,
+				      Item#roster.ask == in ->
+			del_roster_t(LUser, LServer, LJID), {none, AutoReply};
+		    {Subscription, Pending} ->
+			NewItem = Item#roster{subscription = Subscription,
+					      ask = Pending,
+					      askmessage = AskMessage},
+			roster_subscribe_t(LUser, LServer, LJID, NewItem),
+			case roster_version_on_db(LServer) of
+			    true -> write_roster_version_t(LUser, LServer);
+			    false -> ok
+			end,
+			{{push, Item, NewItem}, AutoReply}
+		end
+	end,
+    case transaction(LUser, LServer, [LJID], F) of
+	{atomic, {Push, AutoReply}} ->
+	    case AutoReply of
+		none -> ok;
+		_ ->
+		    ejabberd_router:route(
+		      #presence{type = AutoReply,
+				from = jid:make(User, Server),
+				to = JID1})
+	    end,
+	    case Push of
+		{push, OldItem, NewItem} ->
+		    if NewItem#roster.subscription == none,
+		       NewItem#roster.ask == in ->
+			    ok;
+		       true ->
+			    push_item(jid:make(User, Server), OldItem, NewItem)
+		    end,
+		    true;
+		none ->
+		    false
+	    end;
+	_ ->
+	    false
+    end.
+
+%% in_state_change(Subscription, Pending, Type) -> NewState
+%% NewState = none | {NewSubscription, NewPending}
+-ifdef(ROSTER_GATEWAY_WORKAROUND).
+
+-define(NNSD, {to, none}).
+
+-define(NISD, {to, in}).
+
+-else.
+
+-define(NNSD, none).
+
+-define(NISD, none).
+
+-endif.
+
+in_state_change(none, none, subscribe) -> {none, in};
+in_state_change(none, none, subscribed) -> ?NNSD;
+in_state_change(none, none, unsubscribe) -> none;
+in_state_change(none, none, unsubscribed) -> none;
+in_state_change(none, out, subscribe) -> {none, both};
+in_state_change(none, out, subscribed) -> {to, none};
+in_state_change(none, out, unsubscribe) -> none;
+in_state_change(none, out, unsubscribed) ->
+    {none, none};
+in_state_change(none, in, subscribe) -> none;
+in_state_change(none, in, subscribed) -> ?NISD;
+in_state_change(none, in, unsubscribe) -> {none, none};
+in_state_change(none, in, unsubscribed) -> none;
+in_state_change(none, both, subscribe) -> none;
+in_state_change(none, both, subscribed) -> {to, in};
+in_state_change(none, both, unsubscribe) -> {none, out};
+in_state_change(none, both, unsubscribed) -> {none, in};
+in_state_change(to, none, subscribe) -> {to, in};
+in_state_change(to, none, subscribed) -> none;
+in_state_change(to, none, unsubscribe) -> none;
+in_state_change(to, none, unsubscribed) -> {none, none};
+in_state_change(to, in, subscribe) -> none;
+in_state_change(to, in, subscribed) -> none;
+in_state_change(to, in, unsubscribe) -> {to, none};
+in_state_change(to, in, unsubscribed) -> {none, in};
+in_state_change(from, none, subscribe) -> none;
+in_state_change(from, none, subscribed) -> {both, none};
+in_state_change(from, none, unsubscribe) ->
+    {none, none};
+in_state_change(from, none, unsubscribed) -> none;
+in_state_change(from, out, subscribe) -> none;
+in_state_change(from, out, subscribed) -> {both, none};
+in_state_change(from, out, unsubscribe) -> {none, out};
+in_state_change(from, out, unsubscribed) ->
+    {from, none};
+in_state_change(both, none, subscribe) -> none;
+in_state_change(both, none, subscribed) -> none;
+in_state_change(both, none, unsubscribe) -> {to, none};
+in_state_change(both, none, unsubscribed) ->
+    {from, none}.
+
+out_state_change(none, none, subscribe) -> {none, out};
+out_state_change(none, none, subscribed) -> none;
+out_state_change(none, none, unsubscribe) -> none;
+out_state_change(none, none, unsubscribed) -> none;
+out_state_change(none, out, subscribe) ->
+    {none,
+     out}; %% We need to resend query (RFC3921, section 9.2)
+out_state_change(none, out, subscribed) -> none;
+out_state_change(none, out, unsubscribe) ->
+    {none, none};
+out_state_change(none, out, unsubscribed) -> none;
+out_state_change(none, in, subscribe) -> {none, both};
+out_state_change(none, in, subscribed) -> {from, none};
+out_state_change(none, in, unsubscribe) -> none;
+out_state_change(none, in, unsubscribed) ->
+    {none, none};
+out_state_change(none, both, subscribe) -> none;
+out_state_change(none, both, subscribed) -> {from, out};
+out_state_change(none, both, unsubscribe) -> {none, in};
+out_state_change(none, both, unsubscribed) ->
+    {none, out};
+out_state_change(to, none, subscribe) -> none;
+out_state_change(to, none, subscribed) -> {both, none};
+out_state_change(to, none, unsubscribe) -> {none, none};
+out_state_change(to, none, unsubscribed) -> none;
+out_state_change(to, in, subscribe) -> none;
+out_state_change(to, in, subscribed) -> {both, none};
+out_state_change(to, in, unsubscribe) -> {none, in};
+out_state_change(to, in, unsubscribed) -> {to, none};
+out_state_change(from, none, subscribe) -> {from, out};
+out_state_change(from, none, subscribed) -> none;
+out_state_change(from, none, unsubscribe) -> none;
+out_state_change(from, none, unsubscribed) ->
+    {none, none};
+out_state_change(from, out, subscribe) -> none;
+out_state_change(from, out, subscribed) -> none;
+out_state_change(from, out, unsubscribe) ->
+    {from, none};
+out_state_change(from, out, unsubscribed) ->
+    {none, out};
+out_state_change(both, none, subscribe) -> none;
+out_state_change(both, none, subscribed) -> none;
+out_state_change(both, none, unsubscribe) ->
+    {from, none};
+out_state_change(both, none, unsubscribed) ->
+    {to, none}.
+
+in_auto_reply(from, none, subscribe) -> subscribed;
+in_auto_reply(from, out, subscribe) -> subscribed;
+in_auto_reply(both, none, subscribe) -> subscribed;
+in_auto_reply(none, in, unsubscribe) -> unsubscribed;
+in_auto_reply(none, both, unsubscribe) -> unsubscribed;
+in_auto_reply(to, in, unsubscribe) -> unsubscribed;
+in_auto_reply(from, none, unsubscribe) -> unsubscribed;
+in_auto_reply(from, out, unsubscribe) -> unsubscribed;
+in_auto_reply(both, none, unsubscribe) -> unsubscribed;
+in_auto_reply(_, _, _) -> none.
+
+-spec remove_user(binary(), binary()) -> ok.
+remove_user(User, Server) ->
+    LUser = jid:nodeprep(User),
+    LServer = jid:nameprep(Server),
+    Items = get_user_roster([], {LUser, LServer}),
+    send_unsubscription_to_rosteritems(LUser, LServer, Items),
+    Mod = gen_mod:db_mod(LServer, ?MODULE),
+    Mod:remove_user(LUser, LServer),
+    delete_cache(Mod, LUser, LServer, [Item#roster.jid || Item <- Items]).
+
+%% For each contact with Subscription:
+%% Both or From, send a "unsubscribed" presence stanza;
+%% Both or To, send a "unsubscribe" presence stanza.
+send_unsubscription_to_rosteritems(LUser, LServer, RosterItems) ->
+    From = jid:make({LUser, LServer, <<"">>}),
+    lists:foreach(fun (RosterItem) ->
+			  send_unsubscribing_presence(From, RosterItem)
+		  end,
+		  RosterItems).
+
+send_unsubscribing_presence(From, Item) ->
+    IsTo = case Item#roster.subscription of
+	     both -> true;
+	     to -> true;
+	     _ -> false
+	   end,
+    IsFrom = case Item#roster.subscription of
+	       both -> true;
+	       from -> true;
+	       _ -> false
+	     end,
+    if IsTo ->
+	    ejabberd_router:route(
+	      #presence{type = unsubscribe,
+			from = jid:remove_resource(From),
+			to = jid:make(Item#roster.jid)});
+       true -> ok
+    end,
+    if IsFrom ->
+	    ejabberd_router:route(
+	      #presence{type = unsubscribed,
+			from = jid:remove_resource(From),
+			to = jid:make(Item#roster.jid)});
+       true -> ok
+    end,
+    ok.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+-spec set_items(binary(), binary(), roster_query()) -> any().
+set_items(User, Server, #roster_query{items = Items}) ->
+    LUser = jid:nodeprep(User),
+    LServer = jid:nameprep(Server),
+    LJIDs = [jid:tolower(Item#roster_item.jid) || Item <- Items],
+    F = fun () ->
+		lists:foreach(
+		  fun(Item) ->
+			  process_item_set_t(LUser, LServer, Item)
+		  end, Items)
+	end,
+    transaction(LUser, LServer, LJIDs, F).
+
+update_roster_t(LUser, LServer, LJID, Item) ->
+    Mod = gen_mod:db_mod(LServer, ?MODULE),
+    Mod:update_roster(LUser, LServer, LJID, Item).
+
+del_roster_t(LUser, LServer, LJID) ->
+    Mod = gen_mod:db_mod(LServer, ?MODULE),
+    Mod:del_roster(LUser, LServer, LJID).
+
+process_item_set_t(LUser, LServer, #roster_item{jid = JID1} = QueryItem) ->
+    JID = {JID1#jid.user, JID1#jid.server, <<>>},
+    LJID = {JID1#jid.luser, JID1#jid.lserver, <<>>},
+    Item = #roster{usj = {LUser, LServer, LJID},
+		   us = {LUser, LServer}, jid = JID},
+    Item2 = decode_item(QueryItem, Item, _Managed = true),
+    case Item2#roster.subscription of
+	remove -> del_roster_t(LUser, LServer, LJID);
+	_ -> update_roster_t(LUser, LServer, LJID, Item2)
+    end;
+process_item_set_t(_LUser, _LServer, _) -> ok.
+
+-spec c2s_self_presence({presence(), ejabberd_c2s:state()})
+      -> {presence(), ejabberd_c2s:state()}.
+c2s_self_presence({_, #{pres_last := _}} = Acc) ->
+    Acc;
+c2s_self_presence({#presence{type = available} = Pkt, State}) ->
+    Prio = get_priority_from_presence(Pkt),
+    if Prio >= 0 ->
+	    State1 = resend_pending_subscriptions(State),
+	    {Pkt, State1};
+       true ->
+	    {Pkt, State}
+    end;
+c2s_self_presence(Acc) ->
+    Acc.
+
+-spec resend_pending_subscriptions(ejabberd_c2s:state()) -> ejabberd_c2s:state().
+resend_pending_subscriptions(#{jid := JID} = State) ->
+    BareJID = jid:remove_resource(JID),
+    Result = get_roster(JID#jid.luser, JID#jid.lserver),
+    lists:foldl(
+      fun(#roster{ask = Ask} = R, AccState) when Ask == in; Ask == both ->
+		    Message = R#roster.askmessage,
+		    Status = if is_binary(Message) -> (Message);
+				true -> <<"">>
+			     end,
+	      Sub = #presence{from = jid:make(R#roster.jid),
+			      to = BareJID,
+			      type = subscribe,
+			      status = xmpp:mk_text(Status)},
+	      ejabberd_c2s:send(AccState, Sub);
+	 (_, AccState) ->
+	      AccState
+      end, State, Result).
+
+-spec get_priority_from_presence(presence()) -> integer().
+get_priority_from_presence(#presence{priority = Prio}) ->
+    case Prio of
+	undefined -> 0;
+	_ -> Prio
+    end.
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+-spec get_jid_info({subscription(), ask(), [binary()]}, binary(), binary(), jid())
+      -> {subscription(), ask(), [binary()]}.
+get_jid_info(_, User, Server, JID) ->
+    LUser = jid:nodeprep(User),
+    LServer = jid:nameprep(Server),
+    LJID = jid:tolower(JID),
+    get_subscription_and_groups(LUser, LServer, LJID).
+
+%% Check if `From` is subscriberd to `To`s presence
+%% note 1: partial subscriptions are also considered, i.e.
+%%         `To` has already sent a subscription request to `From`
+%% note 2: it's assumed a user is subscribed to self
+%% note 3: `To` MUST be a local user, `From` can be any user
+-spec is_subscribed(jid(), jid()) -> boolean().
+is_subscribed(#jid{luser = LUser, lserver = LServer},
+	      #jid{luser = LUser, lserver = LServer}) ->
+    true;
+is_subscribed(From, #jid{luser = LUser, lserver = LServer}) ->
+    {Sub, Ask, _} = ejabberd_hooks:run_fold(
+		      roster_get_jid_info, LServer,
+		      {none, none, []},
+		      [LUser, LServer, From]),
+    (Sub /= none) orelse (Ask == subscribe)
+	orelse (Ask == out) orelse (Ask == both).
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+webadmin_page(_, Host,
+	      #request{us = _US, path = [<<"user">>, U, <<"roster">>],
+		       q = Query, lang = Lang} =
+		  _Request) ->
+    Res = user_roster(U, Host, Query, Lang), {stop, Res};
+webadmin_page(Acc, _, _) -> Acc.
+
+user_roster(User, Server, Query, Lang) ->
+    LUser = jid:nodeprep(User),
+    LServer = jid:nameprep(Server),
+    US = {LUser, LServer},
+    Items1 = get_roster(LUser, LServer),
+    Res = user_roster_parse_query(User, Server, Items1,
+				  Query),
+    Items = get_roster(LUser, LServer),
+    SItems = lists:sort(Items),
+    FItems = case SItems of
+	       [] -> [?CT(<<"None">>)];
+	       _ ->
+		   [?XE(<<"table">>,
+			[?XE(<<"thead">>,
+			     [?XE(<<"tr">>,
+				  [?XCT(<<"td">>, <<"Jabber ID">>),
+				   ?XCT(<<"td">>, <<"Nickname">>),
+				   ?XCT(<<"td">>, <<"Subscription">>),
+				   ?XCT(<<"td">>, <<"Pending">>),
+				   ?XCT(<<"td">>, <<"Groups">>)])]),
+			 ?XE(<<"tbody">>,
+			     (lists:map(fun (R) ->
+						Groups = lists:flatmap(fun
+									 (Group) ->
+									     [?C(Group),
+									      ?BR]
+								       end,
+								       R#roster.groups),
+						Pending =
+						    ask_to_pending(R#roster.ask),
+						TDJID =
+						    build_contact_jid_td(R#roster.jid),
+						?XE(<<"tr">>,
+						    [TDJID,
+						     ?XAC(<<"td">>,
+							  [{<<"class">>,
+							    <<"valign">>}],
+							  (R#roster.name)),
+						     ?XAC(<<"td">>,
+							  [{<<"class">>,
+							    <<"valign">>}],
+							  (iolist_to_binary(atom_to_list(R#roster.subscription)))),
+						     ?XAC(<<"td">>,
+							  [{<<"class">>,
+							    <<"valign">>}],
+							  (iolist_to_binary(atom_to_list(Pending)))),
+						     ?XAE(<<"td">>,
+							  [{<<"class">>,
+							    <<"valign">>}],
+							  Groups),
+						     if Pending == in ->
+							    ?XAE(<<"td">>,
+								 [{<<"class">>,
+								   <<"valign">>}],
+								 [?INPUTT(<<"submit">>,
+									  <<"validate",
+									    (ejabberd_web_admin:term_to_id(R#roster.jid))/binary>>,
+									  <<"Validate">>)]);
+							true -> ?X(<<"td">>)
+						     end,
+						     ?XAE(<<"td">>,
+							  [{<<"class">>,
+							    <<"valign">>}],
+							  [?INPUTT(<<"submit">>,
+								   <<"remove",
+								     (ejabberd_web_admin:term_to_id(R#roster.jid))/binary>>,
+								   <<"Remove">>)])])
+					end,
+					SItems)))])]
+	     end,
+    [?XC(<<"h1">>,
+	 (<<(?T(<<"Roster of ">>))/binary, (us_to_list(US))/binary>>))]
+      ++
+      case Res of
+	ok -> [?XREST(<<"Submitted">>)];
+	error -> [?XREST(<<"Bad format">>)];
+	nothing -> []
+      end
+	++
+	[?XAE(<<"form">>,
+	      [{<<"action">>, <<"">>}, {<<"method">>, <<"post">>}],
+	      (FItems ++
+		 [?P, ?INPUT(<<"text">>, <<"newjid">>, <<"">>),
+		  ?C(<<" ">>),
+		  ?INPUTT(<<"submit">>, <<"addjid">>,
+			  <<"Add Jabber ID">>)]))].
+
+build_contact_jid_td(RosterJID) ->
+    ContactJID = jid:make(RosterJID),
+    JIDURI = case {ContactJID#jid.luser,
+		   ContactJID#jid.lserver}
+		 of
+	       {<<"">>, _} -> <<"">>;
+	       {CUser, CServer} ->
+		   case lists:member(CServer, ejabberd_config:get_myhosts()) of
+		     false -> <<"">>;
+		     true ->
+			 <<"/admin/server/", CServer/binary, "/user/",
+			   CUser/binary, "/">>
+		   end
+	     end,
+    case JIDURI of
+      <<>> ->
+	  ?XAC(<<"td">>, [{<<"class">>, <<"valign">>}],
+	       (jid:encode(RosterJID)));
+      URI when is_binary(URI) ->
+	  ?XAE(<<"td">>, [{<<"class">>, <<"valign">>}],
+	       [?AC(JIDURI, (jid:encode(RosterJID)))])
+    end.
+
+user_roster_parse_query(User, Server, Items, Query) ->
+    case lists:keysearch(<<"addjid">>, 1, Query) of
+      {value, _} ->
+	  case lists:keysearch(<<"newjid">>, 1, Query) of
+	    {value, {_, SJID}} ->
+		try jid:decode(SJID) of
+		  JID ->
+		      user_roster_subscribe_jid(User, Server, JID), ok
+		catch _:{bad_jid, _} ->
+			error
+		end;
+	    false -> error
+	  end;
+      false ->
+	  case catch user_roster_item_parse_query(User, Server,
+						  Items, Query)
+	      of
+	    submitted -> ok;
+	    {'EXIT', _Reason} -> error;
+	    _ -> nothing
+	  end
+    end.
+
+user_roster_subscribe_jid(User, Server, JID) ->
+    UJID = jid:make(User, Server),
+    Presence = #presence{from = UJID, to = JID, type = subscribe},
+    out_subscription(Presence),
+    ejabberd_router:route(Presence).
+
+user_roster_item_parse_query(User, Server, Items,
+			     Query) ->
+    lists:foreach(fun (R) ->
+			  JID = R#roster.jid,
+			  case lists:keysearch(<<"validate",
+						 (ejabberd_web_admin:term_to_id(JID))/binary>>,
+					       1, Query)
+			      of
+			    {value, _} ->
+				JID1 = jid:make(JID),
+				UJID = jid:make(User, Server),
+				Pres = #presence{from = UJID, to = JID1,
+						 type = subscribed},
+				out_subscription(Pres),
+				ejabberd_router:route(Pres),
+				throw(submitted);
+			    false ->
+				case lists:keysearch(<<"remove",
+						       (ejabberd_web_admin:term_to_id(JID))/binary>>,
+						     1, Query)
+				    of
+				  {value, _} ->
+				      UJID = jid:make(User, Server),
+				      RosterItem = #roster_item{
+						      jid = jid:make(JID),
+						      subscription = remove},
+				      process_iq_set(
+					#iq{type = set,
+					    from = UJID,
+					    to = UJID,
+					    id = randoms:get_string(),
+					    sub_els = [#roster_query{
+							  items = [RosterItem]}]}),
+				      throw(submitted);
+				  false -> ok
+				end
+			  end
+		  end,
+		  Items),
+    nothing.
+
+us_to_list({User, Server}) ->
+    jid:encode({User, Server, <<"">>}).
+
+webadmin_user(Acc, _User, _Server, Lang) ->
+    Acc ++
+      [?XE(<<"h3">>, [?ACT(<<"roster/">>, <<"Roster">>)])].
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+has_duplicated_groups(Groups) ->
+    GroupsPrep = lists:usort([jid:resourceprep(G) || G <- Groups]),
+    not (length(GroupsPrep) == length(Groups)).
+
+-spec init_cache(module(), binary(), gen_mod:opts()) -> ok.
+init_cache(Mod, Host, Opts) ->
+    CacheOpts = cache_opts(Opts),
+    case use_cache(Mod, Host, roster_version) of
+	true ->
+	    ets_cache:new(?ROSTER_VERSION_CACHE, CacheOpts);
+	false ->
+	    ets_cache:delete(?ROSTER_VERSION_CACHE)
+    end,
+    case use_cache(Mod, Host, roster) of
+	true ->
+	    ets_cache:new(?ROSTER_CACHE, CacheOpts),
+	    ets_cache:new(?ROSTER_ITEM_CACHE, CacheOpts);
+	false ->
+	    ets_cache:delete(?ROSTER_CACHE),
+	    ets_cache:delete(?ROSTER_ITEM_CACHE)
+    end.
+
+-spec cache_opts(gen_mod:opts()) -> [proplists:property()].
+cache_opts(Opts) ->
+    MaxSize = gen_mod:get_opt(cache_size, Opts),
+    CacheMissed = gen_mod:get_opt(cache_missed, Opts),
+    LifeTime = case gen_mod:get_opt(cache_life_time, Opts) of
+		   infinity -> infinity;
+		   I -> timer:seconds(I)
+	       end,
+    [{max_size, MaxSize}, {cache_missed, CacheMissed}, {life_time, LifeTime}].
+
+-spec use_cache(module(), binary(), roster | roster_version) -> boolean().
+use_cache(Mod, Host, Table) ->
+    case erlang:function_exported(Mod, use_cache, 2) of
+	true -> Mod:use_cache(Host, Table);
+	false -> gen_mod:get_module_opt(Host, ?MODULE, use_cache)
+    end.
+
+-spec cache_nodes(module(), binary()) -> [node()].
+cache_nodes(Mod, Host) ->
+    case erlang:function_exported(Mod, cache_nodes, 1) of
+	true -> Mod:cache_nodes(Host);
+	false -> ejabberd_cluster:get_nodes()
+    end.
+
+-spec delete_cache(module(), binary(), binary(), [ljid()]) -> ok.
+delete_cache(Mod, LUser, LServer, LJIDs) ->
+    case use_cache(Mod, LServer, roster_version) of
+	true ->
+	    ets_cache:delete(?ROSTER_VERSION_CACHE, {LUser, LServer},
+			     cache_nodes(Mod, LServer));
+	false ->
+	    ok
+    end,
+    case use_cache(Mod, LServer, roster) of
+	true ->
+	    Nodes = cache_nodes(Mod, LServer),
+	    ets_cache:delete(?ROSTER_CACHE, {LUser, LServer}, Nodes),
+	    lists:foreach(
+	      fun(LJID) ->
+		      ets_cache:delete(
+			?ROSTER_ITEM_CACHE,
+			{LUser, LServer, jid:remove_resource(LJID)},
+			Nodes)
+	      end, LJIDs);
+	false ->
+	    ok
+    end.
+
+export(LServer) ->
+    Mod = gen_mod:db_mod(LServer, ?MODULE),
+    Mod:export(LServer).
+
+import_info() ->
+    [{<<"roster_version">>, 2},
+     {<<"rostergroups">>, 3},
+     {<<"rosterusers">>, 10}].
+
+import_start(LServer, DBType) ->
+    Mod = gen_mod:db_mod(DBType, ?MODULE),
+    ets:new(rostergroups_tmp, [private, named_table, bag]),
+    Mod:init(LServer, []),
+    ok.
+
+import_stop(_LServer, _DBType) ->
+    ets:delete(rostergroups_tmp),
+    ok.
+
+row_length() ->
+    case ejabberd_sql:use_new_schema() of
+        true -> 10;
+        false -> 9
+    end.
+
+import(LServer, {sql, _}, _DBType, <<"rostergroups">>, [LUser, SJID, Group]) ->
+    LJID = jid:tolower(jid:decode(SJID)),
+    ets:insert(rostergroups_tmp, {{LUser, LServer, LJID}, Group}),
+    ok;
+import(LServer, {sql, _}, DBType, <<"rosterusers">>, Row) ->
+    I = mod_roster_sql:raw_to_record(LServer, lists:sublist(Row, row_length())),
+    Groups = [G || {_, G} <- ets:lookup(rostergroups_tmp, I#roster.usj)],
+    RosterItem = I#roster{groups = Groups},
+    Mod = gen_mod:db_mod(DBType, ?MODULE),
+    Mod:import(LServer, <<"rosterusers">>, RosterItem);
+import(LServer, {sql, _}, DBType, <<"roster_version">>, [LUser, Ver]) ->
+    Mod = gen_mod:db_mod(DBType, ?MODULE),
+    Mod:import(LServer, <<"roster_version">>, [LUser, Ver]).
+
+mod_opt_type(access) ->
+    fun acl:access_rules_validator/1;
+mod_opt_type(db_type) -> fun(T) -> ejabberd_config:v_db(?MODULE, T) end;
+mod_opt_type(store_current_id) ->
+    fun (B) when is_boolean(B) -> B end;
+mod_opt_type(versioning) ->
+    fun (B) when is_boolean(B) -> B end;
+mod_opt_type(O) when O == cache_life_time; O == cache_size ->
+    fun (I) when is_integer(I), I > 0 -> I;
+        (infinity) -> infinity
+    end;
+mod_opt_type(O) when O == use_cache; O == cache_missed ->
+    fun (B) when is_boolean(B) -> B end.
+
+mod_options(Host) ->
+    [{access, all},
+     {store_current_id, false},
+     {versioning, false},
+     {db_type, ejabberd_config:default_db(Host, ?MODULE)},
+     {use_cache, ejabberd_config:use_cache(Host)},
+     {cache_size, ejabberd_config:cache_size(Host)},
+     {cache_missed, ejabberd_config:cache_missed(Host)},
+     {cache_life_time, ejabberd_config:cache_life_time(Host)}].

From 8d270c65a7249c34769af7e8030f3fbd6bfd9587 Mon Sep 17 00:00:00 2001
From: Oleg Palij <o.palij@gmail.com>
Date: Mon, 23 Jul 2018 11:19:10 +0300
Subject: [PATCH 2/2] Get rid of jlib.hrl/ejabberd.hrl

---
 src/mod_logdb.erl        | 1 -
 src/mod_logdb_mnesia.erl | 2 --
 src/mod_logdb_mysql.erl  | 2 --
 src/mod_logdb_mysql5.erl | 2 --
 src/mod_logdb_pgsql.erl  | 2 --
 5 files changed, 9 deletions(-)

diff --git a/src/mod_logdb.erl b/src/mod_logdb.erl
index d5983820ae..bf0240d139 100644
--- a/src/mod_logdb.erl
+++ b/src/mod_logdb.erl
@@ -57,7 +57,6 @@
          user_messages_stats_at/5]).
 
 -include("mod_logdb.hrl").
--include("ejabberd.hrl").
 -include("xmpp.hrl").
 -include("mod_roster.hrl").
 -include("ejabberd_commands.hrl").
diff --git a/src/mod_logdb_mnesia.erl b/src/mod_logdb_mnesia.erl
index ea167d889d..a08d5262c2 100644
--- a/src/mod_logdb_mnesia.erl
+++ b/src/mod_logdb_mnesia.erl
@@ -9,8 +9,6 @@
 -author('o.palij@gmail.com').
 
 -include("mod_logdb.hrl").
--include("ejabberd.hrl").
--include("jlib.hrl").
 -include("logger.hrl").
 
 -behaviour(gen_logdb).
diff --git a/src/mod_logdb_mysql.erl b/src/mod_logdb_mysql.erl
index 09036211ff..21d65e6578 100644
--- a/src/mod_logdb_mysql.erl
+++ b/src/mod_logdb_mysql.erl
@@ -9,8 +9,6 @@
 -author('o.palij@gmail.com').
 
 -include("mod_logdb.hrl").
--include("ejabberd.hrl").
--include("jlib.hrl").
 -include("logger.hrl").
 
 -behaviour(gen_logdb).
diff --git a/src/mod_logdb_mysql5.erl b/src/mod_logdb_mysql5.erl
index b6025a3d2e..c05ab958e2 100644
--- a/src/mod_logdb_mysql5.erl
+++ b/src/mod_logdb_mysql5.erl
@@ -9,8 +9,6 @@
 -author('o.palij@gmail.com').
 
 -include("mod_logdb.hrl").
--include("ejabberd.hrl").
--include("jlib.hrl").
 -include("logger.hrl").
 
 -behaviour(gen_logdb).
diff --git a/src/mod_logdb_pgsql.erl b/src/mod_logdb_pgsql.erl
index 61a71fffb0..202c6ed4a8 100644
--- a/src/mod_logdb_pgsql.erl
+++ b/src/mod_logdb_pgsql.erl
@@ -12,8 +12,6 @@
 -author('o.palij@gmail.com').
 
 -include("mod_logdb.hrl").
--include("ejabberd.hrl").
--include("jlib.hrl").
 -include("logger.hrl").
 
 -behaviour(gen_logdb).
